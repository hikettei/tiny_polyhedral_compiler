<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Integer Set Library: Manual [version isl-0.27]</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#Introduction">Introduction</a>
    <ul>
      <li><a href="#Backward-Incompatible-Changes">Backward Incompatible Changes</a>
        <ul>
          <li><a href="#Changes-since-isl-0.02">Changes since isl-0.02</a></li>
          <li><a href="#Changes-since-isl-0.03">Changes since isl-0.03</a></li>
          <li><a href="#Changes-since-isl-0.04">Changes since isl-0.04</a></li>
          <li><a href="#Changes-since-isl-0.05">Changes since isl-0.05</a></li>
          <li><a href="#Changes-since-isl-0.06">Changes since isl-0.06</a></li>
          <li><a href="#Changes-since-isl-0.07">Changes since isl-0.07</a></li>
          <li><a href="#Changes-since-isl-0.09">Changes since isl-0.09</a></li>
          <li><a href="#Changes-since-isl-0.10">Changes since isl-0.10</a></li>
          <li><a href="#Changes-since-isl-0.12">Changes since isl-0.12</a></li>
          <li><a href="#Changes-since-isl-0.14">Changes since isl-0.14</a></li>
          <li><a href="#Changes-since-isl-0.17">Changes since isl-0.17</a></li>
          <li><a href="#Changes-since-isl-0.19">Changes since isl-0.19</a></li>
          <li><a href="#Changes-since-isl-0.20">Changes since isl-0.20</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#License">License</a></li>
  <li><a href="#Installation">Installation</a>
    <ul>
      <li><a href="#Installation-from-the-git-repository">Installation from the git repository</a></li>
      <li><a href="#Common-installation-instructions">Common installation instructions</a></li>
      <li><a href="#Building-the-foreign-language-bindings">Building the foreign language bindings</a></li>
    </ul>
  </li>
  <li><a href="#Integer-Set-Library">Integer Set Library</a>
    <ul>
      <li><a href="#Memory-Management">Memory Management</a></li>
      <li><a href="#Initialization">Initialization</a></li>
      <li><a href="#Return-Types">Return Types</a></li>
      <li><a href="#Values">Values</a>
        <ul>
          <li><a href="#GMP-specific-functions">GMP specific functions</a></li>
        </ul>
      </li>
      <li><a href="#Sets-and-Relations">Sets and Relations</a></li>
      <li><a href="#Error-Handling">Error Handling</a></li>
      <li><a href="#Identifiers">Identifiers</a></li>
      <li><a href="#Spaces">Spaces</a></li>
      <li><a href="#Local-Spaces">Local Spaces</a></li>
      <li><a href="#Creating-New-Sets-and-Relations">Creating New Sets and Relations</a></li>
      <li><a href="#Inspecting-Sets-and-Relations">Inspecting Sets and Relations</a></li>
      <li><a href="#Points">Points</a></li>
      <li><a href="#Functions">Functions</a>
        <ul>
          <li><a href="#Primitive-Functions">Primitive Functions</a></li>
          <li><a href="#Reductions">Reductions</a></li>
          <li><a href="#Multiple-Expressions">Multiple Expressions</a></li>
          <li><a href="#Piecewise-Expressions">Piecewise Expressions</a></li>
          <li><a href="#Union-Expressions">Union Expressions</a></li>
        </ul>
      </li>
      <li><a href="#Input-and-Output">Input and Output</a>
        <ul>
          <li><a href="#isl-format">isl format</a></li>
          <li><a href="#PolyLib-format">PolyLib format</a></li>
          <li><a href="#Extended-PolyLib-format">Extended PolyLib format</a></li>
          <li><a href="#Input">Input</a></li>
          <li><a href="#Output">Output</a></li>
        </ul>
      </li>
      <li><a href="#Properties">Properties</a>
        <ul>
          <li><a href="#Unary-Properties">Unary Properties</a></li>
          <li><a href="#Binary-Properties">Binary Properties</a></li>
        </ul>
      </li>
      <li><a href="#Unary-Operations">Unary Operations</a></li>
      <li><a href="#Binary-Operations">Binary Operations</a>
        <ul>
          <li><a href="#Basic-Operations">Basic Operations</a></li>
          <li><a href="#Lexicographic-Optimization">Lexicographic Optimization</a></li>
        </ul>
      </li>
      <li><a href="#Ternary-Operations">Ternary Operations</a></li>
      <li><a href="#Lists">Lists</a></li>
      <li><a href="#Associative-arrays">Associative arrays</a></li>
      <li><a href="#Vectors">Vectors</a></li>
      <li><a href="#Matrices">Matrices</a></li>
      <li><a href="#Bounds-on-Piecewise-Quasipolynomials-and-Piecewise-Quasipolynomial-Reductions">Bounds on Piecewise Quasipolynomials and Piecewise Quasipolynomial Reductions</a></li>
      <li><a href="#Parametric-Vertex-Enumeration">Parametric Vertex Enumeration</a></li>
    </ul>
  </li>
  <li><a href="#Polyhedral-Compilation-Library">Polyhedral Compilation Library</a>
    <ul>
      <li><a href="#Schedule-Trees">Schedule Trees</a></li>
      <li><a href="#Dependence-Analysis">Dependence Analysis</a>
        <ul>
          <li><a href="#High-level-Interface">High-level Interface</a></li>
          <li><a href="#Low-level-Interface">Low-level Interface</a></li>
          <li><a href="#Interaction-with-the-Low-level-Interface">Interaction with the Low-level Interface</a></li>
        </ul>
      </li>
      <li><a href="#Scheduling">Scheduling</a>
        <ul>
          <li><a href="#Options">Options</a></li>
        </ul>
      </li>
      <li><a href="#AST-Generation">AST Generation</a>
        <ul>
          <li><a href="#Inspecting-the-AST">Inspecting the AST</a></li>
          <li><a href="#Properties-of-ASTs">Properties of ASTs</a></li>
          <li><a href="#Manipulating-and-printing-the-AST">Manipulating and printing the AST</a></li>
          <li><a href="#Options1">Options</a></li>
          <li><a href="#AST-Generation-Options-Schedule-Tree">AST Generation Options (Schedule Tree)</a></li>
          <li><a href="#AST-Generation-Options-Schedule-Map">AST Generation Options (Schedule Map)</a></li>
          <li><a href="#Fine-grained-Control-over-AST-Generation">Fine-grained Control over AST Generation</a></li>
          <li><a href="#Nested-AST-Generation">Nested AST Generation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Applications">Applications</a>
    <ul>
      <li><a href="#isl_polyhedron_sample">isl_polyhedron_sample</a></li>
      <li><a href="#isl_pip">isl_pip</a></li>
      <li><a href="#isl_polyhedron_minimize">isl_polyhedron_minimize</a></li>
      <li><a href="#isl_polytope_scan">isl_polytope_scan</a></li>
      <li><a href="#isl_flow">isl_flow</a></li>
      <li><a href="#isl_codegen">isl_codegen</a></li>
      <li><a href="#isl_schedule">isl_schedule</a></li>
    </ul>
  </li>
</ul>

<h1 id="Introduction">Introduction</h1>

<p><code>isl</code> is a thread-safe C library for manipulating sets and relations of integer points bounded by affine constraints. The descriptions of the sets and relations may involve both parameters and existentially quantified variables. All computations are performed in exact integer arithmetic using <code>GMP</code> or <code>imath</code>. The <code>isl</code> library offers functionality that is similar to that offered by the <code>Omega</code> and <code>Omega+</code> libraries, but the underlying algorithms are in most cases completely different.</p>

<p>The library is by no means complete and some fairly basic functionality is still missing. Still, even in its current form, the library has been successfully used as a backend polyhedral library for the polyhedral scanner <code>CLooG</code> and as part of an equivalence checker of static affine programs. For bug reports, feature requests and questions, visit the discussion group at <a href="http://groups.google.com/group/isl-development">http://groups.google.com/group/isl-development</a>.</p>

<h2 id="Backward-Incompatible-Changes">Backward Incompatible Changes</h2>

<h3 id="Changes-since-isl-0.02">Changes since isl-0.02</h3>

<ul>

<li><p>The old printing functions have been deprecated and replaced by <code>isl_printer</code> functions, see <a href="#Input-and-Output">&quot;Input and Output&quot;</a>.</p>

</li>
<li><p>Most functions related to dependence analysis have acquired an extra <code>must</code> argument. To obtain the old behavior, this argument should be given the value 1. See <a href="#Dependence-Analysis">&quot;Dependence Analysis&quot;</a>.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.03">Changes since isl-0.03</h3>

<ul>

<li><p>The function <code>isl_pw_qpolynomial_fold_add</code> has been renamed to <code>isl_pw_qpolynomial_fold_fold</code>. Similarly, <code>isl_union_pw_qpolynomial_fold_add</code> has been renamed to <code>isl_union_pw_qpolynomial_fold_fold</code>.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.04">Changes since isl-0.04</h3>

<ul>

<li><p>All header files have been renamed from <code>isl_header.h</code> to <code>isl/header.h</code>.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.05">Changes since isl-0.05</h3>

<ul>

<li><p>The functions <code>isl_printer_print_basic_set</code> and <code>isl_printer_print_basic_map</code> no longer print a newline.</p>

</li>
<li><p>The functions <code>isl_flow_get_no_source</code> and <code>isl_union_map_compute_flow</code> now return the accesses for which no source could be found instead of the iterations where those accesses occur.</p>

</li>
<li><p>The functions <code>isl_basic_map_identity</code> and <code>isl_map_identity</code> now take a <b>map</b> space as input. An old call <code>isl_map_identity(space)</code> can be rewritten to <code>isl_map_identity(isl_space_map_from_set(space))</code>.</p>

</li>
<li><p>The function <code>isl_map_power</code> no longer takes a parameter position as input. Instead, the exponent is now expressed as the domain of the resulting relation.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.06">Changes since isl-0.06</h3>

<ul>

<li><p>The format of <code>isl_printer_print_qpolynomial</code>&#39;s <code>ISL_FORMAT_ISL</code> output has changed. Use <code>ISL_FORMAT_C</code> to obtain the old output.</p>

</li>
<li><p>The <code>*_fast_*</code> functions have been renamed to <code>*_plain_*</code>. Some of the old names have been kept for backward compatibility, but they will be removed in the future.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.07">Changes since isl-0.07</h3>

<ul>

<li><p>The function <code>isl_pw_aff_max</code> has been renamed to <code>isl_pw_aff_union_max</code>. Similarly, the function <code>isl_pw_aff_add</code> has been renamed to <code>isl_pw_aff_union_add</code>.</p>

</li>
<li><p>The <code>isl_dim</code> type has been renamed to <code>isl_space</code> along with the associated functions. Some of the old names have been kept for backward compatibility, but they will be removed in the future.</p>

</li>
<li><p>Spaces of maps, sets and parameter domains are now treated differently. The distinction between map spaces and set spaces has always been made on a conceptual level, but proper use of such spaces was never checked. Furthermore, up until isl-0.07 there was no way of explicitly creating a parameter space. These can now be created directly using <code>isl_space_params_alloc</code> or from other spaces using <code>isl_space_params</code>.</p>

</li>
<li><p>The space in which <code>isl_aff</code>, <code>isl_pw_aff</code>, <code>isl_qpolynomial</code>, <code>isl_pw_qpolynomial</code>, <code>isl_qpolynomial_fold</code> and <code>isl_pw_qpolynomial_fold</code> objects live is now a map space instead of a set space. This means, for example, that the dimensions of the domain of an <code>isl_aff</code> are now considered to be of type <code>isl_dim_in</code> instead of <code>isl_dim_set</code>. Extra functions have been added to obtain the domain space. Some of the constructors still take a domain space and have therefore been renamed.</p>

</li>
<li><p>The functions <code>isl_equality_alloc</code> and <code>isl_inequality_alloc</code> now take an <code>isl_local_space</code> instead of an <code>isl_space</code>. An <code>isl_local_space</code> can be created from an <code>isl_space</code> using <code>isl_local_space_from_space</code>.</p>

</li>
<li><p>The <code>isl_div</code> type has been removed. Functions that used to return an <code>isl_div</code> now return an <code>isl_aff</code>. Note that the space of an <code>isl_aff</code> is that of relation. When replacing a call to <code>isl_div_get_coefficient</code> by a call to <code>isl_aff_get_coefficient</code> any <code>isl_dim_set</code> argument needs to be replaced by <code>isl_dim_in</code>. A call to <code>isl_aff_from_div</code> can be replaced by a call to <code>isl_aff_floor</code>. A call to <code>isl_qpolynomial_div(div)</code> call be replaced by the nested call</p>

<pre><code>isl_qpolynomial_from_aff(isl_aff_floor(div))</code></pre>

<p>The function <code>isl_constraint_div</code> has also been renamed to <code>isl_constraint_get_div</code>.</p>

</li>
<li><p>The <code>nparam</code> argument has been removed from <code>isl_map_read_from_str</code> and similar functions. When reading input in the original PolyLib format, the result will have no parameters. If parameters are expected, the caller may want to perform dimension manipulation on the result.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.09">Changes since isl-0.09</h3>

<ul>

<li><p>The <code>schedule_split_parallel</code> option has been replaced by the <code>schedule_split_scaled</code> option.</p>

</li>
<li><p>The first argument of <code>isl_pw_aff_cond</code> is now an <code>isl_pw_aff</code> instead of an <code>isl_set</code>. A call <code>isl_pw_aff_cond(a, b, c)</code> can be replaced by</p>

<pre><code>isl_pw_aff_cond(isl_set_indicator_function(a), b, c)</code></pre>

</li>
</ul>

<h3 id="Changes-since-isl-0.10">Changes since isl-0.10</h3>

<ul>

<li><p>The functions <code>isl_set_dim_has_lower_bound</code> and <code>isl_set_dim_has_upper_bound</code> have been renamed to <code>isl_set_dim_has_any_lower_bound</code> and <code>isl_set_dim_has_any_upper_bound</code>. The new <code>isl_set_dim_has_lower_bound</code> and <code>isl_set_dim_has_upper_bound</code> have slightly different meanings.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.12">Changes since isl-0.12</h3>

<ul>

<li><p><code>isl_int</code> has been replaced by <code>isl_val</code>. Some of the old functions are still available in <code>isl/deprecated/*.h</code> but they will be removed in the future.</p>

</li>
<li><p>The functions <code>isl_pw_qpolynomial_eval</code>, <code>isl_union_pw_qpolynomial_eval</code>, <code>isl_pw_qpolynomial_fold_eval</code> and <code>isl_union_pw_qpolynomial_fold_eval</code> have been changed to return an <code>isl_val</code> instead of an <code>isl_qpolynomial</code>.</p>

</li>
<li><p>The function <code>isl_band_member_is_zero_distance</code> has been removed. Essentially the same functionality is available through <code>isl_band_member_is_coincident</code>, except that it requires setting up coincidence constraints. The option <code>schedule_outer_zero_distance</code> has accordingly been replaced by the option <code>schedule_outer_coincidence</code>.</p>

</li>
<li><p>The function <code>isl_vertex_get_expr</code> has been changed to return an <code>isl_multi_aff</code> instead of a rational <code>isl_basic_set</code>. The function <code>isl_vertex_get_domain</code> has been changed to return a regular basic set, rather than a rational basic set.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.14">Changes since isl-0.14</h3>

<ul>

<li><p>The function <code>isl_union_pw_multi_aff_add</code> now consistently computes the sum on the shared definition domain. The function <code>isl_union_pw_multi_aff_union_add</code> has been added to compute the sum on the union of definition domains. The original behavior of <code>isl_union_pw_multi_aff_add</code> was confused and is no longer available.</p>

</li>
<li><p>Band forests have been replaced by schedule trees.</p>

</li>
<li><p>The function <code>isl_union_map_compute_flow</code> has been replaced by the function <code>isl_union_access_info_compute_flow</code>. Note that the may dependence relation returned by <code>isl_union_flow_get_may_dependence</code> is the union of the two dependence relations returned by <code>isl_union_map_compute_flow</code>. Similarly for the no source relations. The function <code>isl_union_map_compute_flow</code> is still available for backward compatibility, but it will be removed in the future.</p>

</li>
<li><p>The function <code>isl_basic_set_drop_constraint</code> has been deprecated.</p>

</li>
<li><p>The function <code>isl_ast_build_ast_from_schedule</code> has been renamed to <code>isl_ast_build_node_from_schedule_map</code>. The original name is still available for backward compatibility, but it will be removed in the future.</p>

</li>
<li><p>The <code>separation_class</code> AST generation option has been deprecated.</p>

</li>
<li><p>The functions <code>isl_equality_alloc</code> and <code>isl_inequality_alloc</code> have been renamed to <code>isl_constraint_alloc_equality</code> and <code>isl_constraint_alloc_inequality</code>. The original names have been kept for backward compatibility, but they will be removed in the future.</p>

</li>
<li><p>The <code>schedule_fuse</code> option has been replaced by the <code>schedule_serialize_sccs</code> option. The effect of setting the <code>schedule_fuse</code> option to <code>ISL_SCHEDULE_FUSE_MIN</code> is now obtained by turning on the <code>schedule_serialize_sccs</code> option.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.17">Changes since isl-0.17</h3>

<ul>

<li><p>The function <code>isl_printer_print_ast_expr</code> no longer prints in C format by default. To print in C format, the output format of the printer needs to have been explicitly set to <code>ISL_FORMAT_C</code>. As a result, the function <code>isl_ast_expr_to_str</code> no longer prints the expression in C format. Use <code>isl_ast_expr_to_C_str</code> instead.</p>

</li>
<li><p>The functions <code>isl_set_align_divs</code> and <code>isl_map_align_divs</code> have been deprecated. The function <code>isl_set_lift</code> has an effect that is similar to <code>isl_set_align_divs</code> and could in some cases be used as an alternative.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.19">Changes since isl-0.19</h3>

<ul>

<li><p>Zero-dimensional objects of type <code>isl_multi_pw_aff</code> or <code>isl_multi_union_pw_aff</code> can now keep track of an explicit domain. This explicit domain, if present, is taken into account by various operations that take such objects as input.</p>

</li>
</ul>

<h3 id="Changes-since-isl-0.20">Changes since isl-0.20</h3>

<ul>

<li><p>Several functions that used to return <code>unsigned</code> now return <code>isl_size</code>. This means that these functions may now return a negative value in case an error occurred. The same holds for functions that used to return <code>int</code>, although some of those were already returning a negative value in case of error.</p>

</li>
<li><p>The <code>isl_ast_op_type</code> enumeration type has been renamed to <code>isl_ast_expr_op_type</code>. The corresponding enumeration constants have been similarly renamed. The old names are defined to the new names for backward compatibility.</p>

</li>
<li><p>Several functions returning an extra boolean value through an <code>int *</code> argument now do so through an <code>isl_bool *</code> argument. The returned values are the same, only the type of the pointer has been changed.</p>

</li>
</ul>

<h1 id="License">License</h1>

<p><code>isl</code> is released under the MIT license.</p>

<ul>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

</ul>

<p>Note that by default <code>isl</code> requires <code>GMP</code>, which is released under the GNU Lesser General Public License (LGPL). This means that code linked against <code>isl</code> is also linked against LGPL code.</p>

<p>When configuring with <code>--with-int=imath</code> or <code>--with-int=imath-32</code>, <code>isl</code> will link against <code>imath</code>, a library for exact integer arithmetic released under the MIT license.</p>

<h1 id="Installation">Installation</h1>

<p>The source of <code>isl</code> can be obtained either as a tarball or from the git repository. Both are available from <a href="https://libisl.sourceforge.io/">https://libisl.sourceforge.io/</a>. The installation process depends on how you obtained the source.</p>

<h2 id="Installation-from-the-git-repository">Installation from the git repository</h2>

<dl>

<dt id="Clone-or-update-the-repository">1 Clone or update the repository</dt>
<dd>

<p>The first time the source is obtained, you need to clone the repository.</p>

<pre><code>git clone git://repo.or.cz/isl.git</code></pre>

<p>To obtain updates, you need to pull in the latest changes</p>

<pre><code>git pull</code></pre>

</dd>
<dt id="Optionally-get-imath-submodule">2 Optionally get <code>imath</code> submodule</dt>
<dd>

<p>To build <code>isl</code> with <code>imath</code>, you need to obtain the <code>imath</code> submodule by running in the git source tree of <code>isl</code></p>

<pre><code>git submodule init
git submodule update</code></pre>

<p>This will fetch the required version of <code>imath</code> in a subdirectory of <code>isl</code>.</p>

</dd>
<dt id="Generate-configure">2 Generate <code>configure</code></dt>
<dd>

<pre><code>./autogen.sh</code></pre>

</dd>
</dl>

<p>After performing the above steps, continue with the <a href="#Common-installation-instructions">&quot;Common installation instructions&quot;</a>.</p>

<h2 id="Common-installation-instructions">Common installation instructions</h2>

<dl>

<dt id="Obtain-GMP">1 Obtain <code>GMP</code></dt>
<dd>

<p>By default, building <code>isl</code> requires <code>GMP</code>, including its headers files. Your distribution may not provide these header files by default and you may need to install a package called <code>gmp-devel</code> or something similar. Alternatively, <code>GMP</code> can be built from source, available from <a href="http://gmplib.org/">http://gmplib.org/</a>. <code>GMP</code> is not needed if you build <code>isl</code> with <code>imath</code>.</p>

</dd>
<dt id="Configure">2 Configure</dt>
<dd>

<p><code>isl</code> uses the standard <code>autoconf</code> <code>configure</code> script. To run it, just type</p>

<pre><code>./configure</code></pre>

<p>optionally followed by some configure options. A complete list of options can be obtained by running</p>

<pre><code>./configure --help</code></pre>

<p>Below we discuss some of the more common options.</p>

<dl>

<dt id="prefix"><code>--prefix</code></dt>
<dd>

<p>Installation prefix for <code>isl</code></p>

</dd>
<dt id="with-int-gmp-imath-imath-32"><code>--with-int=[gmp|imath|imath-32]</code></dt>
<dd>

<p>Select the integer library to be used by <code>isl</code>, the default is <code>gmp</code>. With <code>imath-32</code>, <code>isl</code> will use 32 bit integers, but fall back to <code>imath</code> for values out of the 32 bit range. In most applications, <code>isl</code> will run fastest with the <code>imath-32</code> option, followed by <code>gmp</code> and <code>imath</code>, the slowest.</p>

</dd>
<dt id="with-gmp-prefix-path"><code>--with-gmp-prefix=</code><i>path</i></dt>
<dd>

<p>Installation prefix for <code>GMP</code> (architecture-independent files).</p>

</dd>
<dt id="with-gmp-exec-prefix-path"><code>--with-gmp-exec-prefix=</code><i>path</i></dt>
<dd>

<p>Installation prefix for <code>GMP</code> (architecture-dependent files).</p>

</dd>
</dl>

</dd>
<dt id="Compile">3 Compile</dt>
<dd>

<pre><code>make</code></pre>

</dd>
<dt id="Test-optional">4 Test (optional)</dt>
<dd>

<pre><code>make check</code></pre>

</dd>
<dt id="Install-optional">5 Install (optional)</dt>
<dd>

<pre><code>make install</code></pre>

</dd>
</dl>

<h2 id="Building-the-foreign-language-bindings">Building the foreign language bindings</h2>

<p>The tarball already contains the generated foreign language bindings, but they are not included in the git repository. Building the C++ and Python bindings relies on the LLVM/clang libraries, see <code>http://clang.llvm.org/get_started.html</code>. The <code>configure</code> script will not assume that these are available on the system. To enable building the foreign language bindings, one of the following options needs to be specified.</p>

<dl>

<dt id="with-clang-system"><code>--with-clang=system</code></dt>
<dd>

<p>Use the system clang libraries (installed in a default location).</p>

</dd>
<dt id="with-clang-prefix-path"><code>--with-clang-prefix=</code><i>path</i></dt>
<dd>

<p>Use the system clang libraries installed in <i>path</i>.</p>

</dd>
</dl>

<p>It is best to use the latest release of the clang libraries (16.0), although any release since 3.5 should work as well. Note that if you build the clang libraries from source, then you need to make sure they are also installed (using <code>make install</code>). If the compiler that was used to compile the clang libraries is different from the default C++ compiler, then use <code>CXX_FOR_BUILD</code> to specify this non-default C++ compiler when running <code>isl</code>&#39;s <code>./configure</code>.</p>

<h1 id="Integer-Set-Library">Integer Set Library</h1>

<h2 id="Memory-Management">Memory Management</h2>

<p>Since a high-level operation on isl objects usually involves several substeps and since the user is usually not interested in the intermediate results, most functions that return a new object will also release all the objects passed as arguments. If the user still wants to use one or more of these arguments after the function call, she should pass along a copy of the object rather than the object itself. The user is then responsible for making sure that the original object gets used somewhere else or is explicitly freed.</p>

<p>The arguments and return values of all documented functions are annotated to make clear which arguments are released and which arguments are preserved. In particular, the following annotations are used</p>

<dl>

<dt id="isl_give"><code>__isl_give</code></dt>
<dd>

<p><code>__isl_give</code> means that a new object is returned. The user should make sure that the returned pointer is used exactly once as a value for an <code>__isl_take</code> argument. In between, it can be used as a value for as many <code>__isl_keep</code> arguments as the user likes. There is one exception, and that is the case where the pointer returned is <code>NULL</code>. In this case, the user is free to use it as an <code>__isl_take</code> argument or not. When applied to a <code>char *</code>, the returned pointer needs to be freed using <code>free</code>.</p>

</dd>
<dt id="isl_null"><code>__isl_null</code></dt>
<dd>

<p><code>__isl_null</code> means that a <code>NULL</code> value is returned.</p>

</dd>
<dt id="isl_take"><code>__isl_take</code></dt>
<dd>

<p><code>__isl_take</code> means that the object the argument points to is taken over by the function and may no longer be used by the user as an argument to any other function. The pointer value must be one returned by a function returning an <code>__isl_give</code> pointer. If the user passes in a <code>NULL</code> value, then this will be treated as an error in the sense that the function will not perform its usual operation. However, it will still make sure that all the other <code>__isl_take</code> arguments are released.</p>

</dd>
<dt id="isl_keep"><code>__isl_keep</code></dt>
<dd>

<p><code>__isl_keep</code> means that the function will only use the object temporarily. After the function has finished, the user can still use it as an argument to other functions. A <code>NULL</code> value will be treated in the same way as a <code>NULL</code> value for an <code>__isl_take</code> argument. This annotation may also be used on return values of type <code>const char *</code>, in which case the returned pointer should not be freed by the user and is only valid until the object from which it was derived is updated or freed.</p>

</dd>
</dl>

<h2 id="Initialization">Initialization</h2>

<p>All manipulations of integer sets and relations occur within the context of an <code>isl_ctx</code>. A given <code>isl_ctx</code> can only be used within a single thread. All arguments of a function are required to have been allocated within the same context. There are currently no functions available for moving an object from one <code>isl_ctx</code> to another <code>isl_ctx</code>. This means that there is currently no way of safely moving an object from one thread to another, unless the whole <code>isl_ctx</code> is moved.</p>

<p>An <code>isl_ctx</code> can be allocated using <code>isl_ctx_alloc</code> and freed using <code>isl_ctx_free</code>. All objects allocated within an <code>isl_ctx</code> should be freed before the <code>isl_ctx</code> itself is freed.</p>

<pre><code>isl_ctx *isl_ctx_alloc();
void isl_ctx_free(isl_ctx *ctx);</code></pre>

<p>The user can impose a bound on the number of low-level <i>operations</i> that can be performed by an <code>isl_ctx</code>. This bound can be set and retrieved using the following functions. A bound of zero means that no bound is imposed. The number of operations performed can be reset using <code>isl_ctx_reset_operations</code>. Note that the number of low-level operations needed to perform a high-level computation may differ significantly across different versions of <code>isl</code>, but it should be the same across different platforms for the same version of <code>isl</code>.</p>

<p>Warning: This feature is experimental. <code>isl</code> has good support to abort and bail out during the computation, but this feature may exercise error code paths that are normally not used that much. Consequently, it is not unlikely that hidden bugs will be exposed.</p>

<pre><code>void isl_ctx_set_max_operations(isl_ctx *ctx,
        unsigned long max_operations);
unsigned long isl_ctx_get_max_operations(isl_ctx *ctx);
void isl_ctx_reset_operations(isl_ctx *ctx);</code></pre>

<p>In order to be able to create an object in the same context as another object, most object types (described later in this document) provide a function to obtain the context in which the object was created.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_ctx *isl_val_get_ctx(__isl_keep isl_val *val);
isl_ctx *isl_multi_val_get_ctx(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/id.h&gt;
isl_ctx *isl_id_get_ctx(__isl_keep isl_id *id);
isl_ctx *isl_multi_id_get_ctx(
        __isl_keep isl_multi_id *mi);

#include &lt;isl/local_space.h&gt;
isl_ctx *isl_local_space_get_ctx(
        __isl_keep isl_local_space *ls);

#include &lt;isl/set.h&gt;
isl_ctx *isl_set_list_get_ctx(
        __isl_keep isl_set_list *list);

#include &lt;isl/aff.h&gt;
isl_ctx *isl_aff_get_ctx(__isl_keep isl_aff *aff);
isl_ctx *isl_multi_aff_get_ctx(
        __isl_keep isl_multi_aff *maff);
isl_ctx *isl_pw_aff_get_ctx(__isl_keep isl_pw_aff *pa);
isl_ctx *isl_pw_multi_aff_get_ctx(
        __isl_keep isl_pw_multi_aff *pma);
isl_ctx *isl_multi_pw_aff_get_ctx(
        __isl_keep isl_multi_pw_aff *mpa);
isl_ctx *isl_union_pw_aff_get_ctx(
        __isl_keep isl_union_pw_aff *upa);
isl_ctx *isl_union_pw_multi_aff_get_ctx(
        __isl_keep isl_union_pw_multi_aff *upma);
isl_ctx *isl_multi_union_pw_aff_get_ctx(
        __isl_keep isl_multi_union_pw_aff *mupa);

#include &lt;isl/id_to_ast_expr.h&gt;
isl_ctx *isl_id_to_ast_expr_get_ctx(
        __isl_keep isl_id_to_ast_expr *id2expr);

#include &lt;isl/point.h&gt;
isl_ctx *isl_point_get_ctx(__isl_keep isl_point *pnt);

#include &lt;isl/vec.h&gt;
isl_ctx *isl_vec_get_ctx(__isl_keep isl_vec *vec);

#include &lt;isl/mat.h&gt;
isl_ctx *isl_mat_get_ctx(__isl_keep isl_mat *mat);

#include &lt;isl/vertices.h&gt;
isl_ctx *isl_vertices_get_ctx(
        __isl_keep isl_vertices *vertices);
isl_ctx *isl_vertex_get_ctx(__isl_keep isl_vertex *vertex);
isl_ctx *isl_cell_get_ctx(__isl_keep isl_cell *cell);

#include &lt;isl/flow.h&gt;
isl_ctx *isl_restriction_get_ctx(
        __isl_keep isl_restriction *restr);
isl_ctx *isl_union_access_info_get_ctx(
        __isl_keep isl_union_access_info *access);
isl_ctx *isl_union_flow_get_ctx(
        __isl_keep isl_union_flow *flow);

#include &lt;isl/schedule.h&gt;
isl_ctx *isl_schedule_get_ctx(
        __isl_keep isl_schedule *sched);
isl_ctx *isl_schedule_constraints_get_ctx(
        __isl_keep isl_schedule_constraints *sc);

#include &lt;isl/schedule_node.h&gt;
isl_ctx *isl_schedule_node_get_ctx(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/ast_build.h&gt;
isl_ctx *isl_ast_build_get_ctx(
        __isl_keep isl_ast_build *build);

#include &lt;isl/ast.h&gt;
isl_ctx *isl_ast_expr_get_ctx(
        __isl_keep isl_ast_expr *expr);
isl_ctx *isl_ast_node_get_ctx(
        __isl_keep isl_ast_node *node);

#include &lt;isl/stride_info.h&gt;
isl_ctx *isl_stride_info_get_ctx(
        __isl_keep isl_stride_info *si);

#include &lt;isl/fixed_box.h&gt;
isl_ctx *isl_fixed_box_get_ctx(
        __isl_keep isl_fixed_box *box);</code></pre>

<h2 id="Return-Types">Return Types</h2>

<p><code>isl</code> uses the special return type <code>isl_size</code> for functions that return a non-negative value, typically a number or a position. Besides the regular non-negative return values, a special (negative) value <code>isl_size_error</code> may be returned, indicating that something went wrong.</p>

<p><code>isl</code> also uses two special return types for functions that either return a boolean or that in principle do not return anything. In particular, the <code>isl_bool</code> type has three possible values: <code>isl_bool_true</code> (a positive integer value), indicating <i>true</i> or <i>yes</i>; <code>isl_bool_false</code> (the integer value zero), indicating <i>false</i> or <i>no</i>; and <code>isl_bool_error</code> (a negative integer value), indicating that something went wrong. The following operations are defined on <code>isl_bool</code>. The function <code>isl_bool_not</code> can be used to negate an <code>isl_bool</code>, where the negation of <code>isl_bool_error</code> is <code>isl_bool_error</code> again. The function <code>isl_bool_ok</code> converts an integer to an <code>isl_bool</code>. Any non-zero values yields <code>isl_bool_true</code> and zero yields <code>isl_bool_false</code>.</p>

<pre><code>#include &lt;isl/ctx.h&gt;
isl_bool isl_bool_not(isl_bool b);
isl_bool isl_bool_ok(int b);</code></pre>

<p>The <code>isl_stat</code> type has two possible values: <code>isl_stat_ok</code> (the integer value zero), indicating a successful operation; and <code>isl_stat_error</code> (a negative integer value), indicating that something went wrong. The function <code>isl_stat_non_null</code> converts an isl object pointer to an <code>isl_stat</code>, returning <code>isl_stat_ok</code> if the object pointer is valid and <code>isl_stat_error</code> if it is <code>NULL</code>. Similarly, the function <code>isl_stat_non_error_bool</code> converts an <code>isl_bool</code> to an <code>isl_stat</code>, returning <code>isl_stat_ok</code> if the <code>isl_bool</code> represents a valid result and <code>isl_stat_error</code> if it is <code>isl_bool_error</code>.</p>

<pre><code>#include &lt;isl/ctx.h&gt;
isl_stat isl_stat_non_null(void *obj);
isl_stat isl_stat_non_error_bool(isl_bool b);</code></pre>

<p>See <a href="#Error-Handling">&quot;Error Handling&quot;</a> for more information on <code>isl_size_error</code>, <code>isl_bool_error</code> and <code>isl_stat_error</code>.</p>

<h2 id="Values">Values</h2>

<p>An <code>isl_val</code> represents an integer value, a rational value or one of three special values, infinity, negative infinity and NaN. Some predefined values can be created using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_zero(isl_ctx *ctx);
__isl_give isl_val *isl_val_one(isl_ctx *ctx);
__isl_give isl_val *isl_val_negone(isl_ctx *ctx);
__isl_give isl_val *isl_val_nan(isl_ctx *ctx);
__isl_give isl_val *isl_val_infty(isl_ctx *ctx);
__isl_give isl_val *isl_val_neginfty(isl_ctx *ctx);</code></pre>

<p>Specific integer values can be created using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_int_from_si(isl_ctx *ctx,
        long i);
__isl_give isl_val *isl_val_int_from_ui(isl_ctx *ctx,
        unsigned long u);
__isl_give isl_val *isl_val_int_from_chunks(isl_ctx *ctx,
        size_t n, size_t size, const void *chunks);</code></pre>

<p>The function <code>isl_val_int_from_chunks</code> constructs an <code>isl_val</code> from the <code>n</code> <i>digits</i>, each consisting of <code>size</code> bytes, stored at <code>chunks</code>. The least significant digit is assumed to be stored first.</p>

<p>Value objects can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_copy(__isl_keep isl_val *v);
__isl_null isl_val *isl_val_free(__isl_take isl_val *v);</code></pre>

<p>They can be inspected using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
long isl_val_get_num_si(__isl_keep isl_val *v);
long isl_val_get_den_si(__isl_keep isl_val *v);
__isl_give isl_val *isl_val_get_den_val(
        __isl_keep isl_val *v);
double isl_val_get_d(__isl_keep isl_val *v);
isl_size isl_val_n_abs_num_chunks(__isl_keep isl_val *v,
        size_t size);
isl_stat isl_val_get_abs_num_chunks(__isl_keep isl_val *v,
        size_t size, void *chunks);</code></pre>

<p><code>isl_val_n_abs_num_chunks</code> returns the number of <i>digits</i> of <code>size</code> bytes needed to store the absolute value of the numerator of <code>v</code>. <code>isl_val_get_abs_num_chunks</code> stores these digits at <code>chunks</code>, which is assumed to have been preallocated by the caller. The least significant digit is stored first. Note that <code>isl_val_get_num_si</code>, <code>isl_val_get_den_si</code>, <code>isl_val_get_d</code>, <code>isl_val_n_abs_num_chunks</code> and <code>isl_val_get_abs_num_chunks</code> can only be applied to rational values.</p>

<p>An <code>isl_val</code> can be modified using the following function.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_set_si(__isl_take isl_val *v,
        long i);</code></pre>

<p>The following unary properties are defined on <code>isl_val</code>s.</p>

<pre><code>#include &lt;isl/val.h&gt;
int isl_val_sgn(__isl_keep isl_val *v);
isl_bool isl_val_is_zero(__isl_keep isl_val *v);
isl_bool isl_val_is_one(__isl_keep isl_val *v);
isl_bool isl_val_is_negone(__isl_keep isl_val *v);
isl_bool isl_val_is_nonneg(__isl_keep isl_val *v);
isl_bool isl_val_is_nonpos(__isl_keep isl_val *v);
isl_bool isl_val_is_pos(__isl_keep isl_val *v);
isl_bool isl_val_is_neg(__isl_keep isl_val *v);
isl_bool isl_val_is_int(__isl_keep isl_val *v);
isl_bool isl_val_is_rat(__isl_keep isl_val *v);
isl_bool isl_val_is_nan(__isl_keep isl_val *v);
isl_bool isl_val_is_infty(__isl_keep isl_val *v);
isl_bool isl_val_is_neginfty(__isl_keep isl_val *v);</code></pre>

<p>Note that the sign of NaN is undefined.</p>

<p>The following binary properties are defined on pairs of <code>isl_val</code>s.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_bool isl_val_lt(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_le(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_gt(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_ge(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_eq(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_ne(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);
isl_bool isl_val_abs_eq(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);</code></pre>

<p>Comparisons to NaN always return false. That is, a NaN is not considered to hold any relative position with respect to any value. In particular, a NaN is neither considered to be equal to nor to be different from any value (including another NaN). The function <code>isl_val_abs_eq</code> checks whether its two arguments are equal in absolute value.</p>

<p>For integer <code>isl_val</code>s we additionally have the following binary property.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_bool isl_val_is_divisible_by(__isl_keep isl_val *v1,
        __isl_keep isl_val *v2);</code></pre>

<p>An <code>isl_val</code> can also be compared to an integer using the following functions. The result of <code>isl_val_cmp_si</code> is undefined for NaN.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_bool isl_val_gt_si(__isl_keep isl_val *v, long i);
isl_bool isl_val_eq_si(__isl_keep isl_val *v, long i);
int isl_val_cmp_si(__isl_keep isl_val *v, long i);</code></pre>

<p>The following unary operations are available on <code>isl_val</code>s.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_abs(__isl_take isl_val *v);
__isl_give isl_val *isl_val_neg(__isl_take isl_val *v);
__isl_give isl_val *isl_val_floor(__isl_take isl_val *v);
__isl_give isl_val *isl_val_ceil(__isl_take isl_val *v);
__isl_give isl_val *isl_val_trunc(__isl_take isl_val *v);
__isl_give isl_val *isl_val_inv(__isl_take isl_val *v);</code></pre>

<p>The following binary operations are available on <code>isl_val</code>s.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_min(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_max(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_add(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_add_ui(__isl_take isl_val *v1,
        unsigned long v2);
__isl_give isl_val *isl_val_sub(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_sub_ui(__isl_take isl_val *v1,
        unsigned long v2);
__isl_give isl_val *isl_val_mul(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_mul_ui(__isl_take isl_val *v1,
        unsigned long v2);
__isl_give isl_val *isl_val_div(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_div_ui(__isl_take isl_val *v1,
        unsigned long v2);</code></pre>

<p>On integer values, we additionally have the following operations.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_pow2(__isl_take isl_val *v);
__isl_give isl_val *isl_val_2exp(__isl_take isl_val *v);
__isl_give isl_val *isl_val_mod(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_gcd(__isl_take isl_val *v1,
        __isl_take isl_val *v2);
__isl_give isl_val *isl_val_gcdext(__isl_take isl_val *v1,
        __isl_take isl_val *v2, __isl_give isl_val **x,
        __isl_give isl_val **y);</code></pre>

<p><code>isl_val_2exp</code> is an alternative name for <code>isl_val_pow2</code>. The function <code>isl_val_gcdext</code> returns the greatest common divisor g of <code>v1</code> and <code>v2</code> as well as two integers <code>*x</code> and <code>*y</code> such that <code>*x</code> * <code>v1</code> + <code>*y</code> * <code>v2</code> = g.</p>

<h3 id="GMP-specific-functions">GMP specific functions</h3>

<p>These functions are only available if <code>isl</code> has been compiled with <code>GMP</code> support.</p>

<p>Specific integer and rational values can be created from <code>GMP</code> values using the following functions.</p>

<pre><code>#include &lt;isl/val_gmp.h&gt;
__isl_give isl_val *isl_val_int_from_gmp(isl_ctx *ctx,
        mpz_t z);
__isl_give isl_val *isl_val_from_gmp(isl_ctx *ctx,
        const mpz_t n, const mpz_t d);</code></pre>

<p>The numerator and denominator of a rational value can be extracted as <code>GMP</code> values using the following functions.</p>

<pre><code>#include &lt;isl/val_gmp.h&gt;
int isl_val_get_num_gmp(__isl_keep isl_val *v, mpz_t z);
int isl_val_get_den_gmp(__isl_keep isl_val *v, mpz_t z);</code></pre>

<h2 id="Sets-and-Relations">Sets and Relations</h2>

<p><code>isl</code> uses six types of objects for representing sets and relations, <code>isl_basic_set</code>, <code>isl_basic_map</code>, <code>isl_set</code>, <code>isl_map</code>, <code>isl_union_set</code> and <code>isl_union_map</code>. <code>isl_basic_set</code> and <code>isl_basic_map</code> represent sets and relations that can be described as a conjunction of affine constraints, while <code>isl_set</code> and <code>isl_map</code> represent unions of <code>isl_basic_set</code>s and <code>isl_basic_map</code>s, respectively. However, all <code>isl_basic_set</code>s or <code>isl_basic_map</code>s in the union need to live in the same space. <code>isl_union_set</code>s and <code>isl_union_map</code>s represent unions of <code>isl_set</code>s or <code>isl_map</code>s in <i>different</i> spaces, where spaces are considered different if they have a different number of dimensions and/or different names (see <a href="#Spaces">&quot;Spaces&quot;</a>). The difference between sets and relations (maps) is that sets have one set of variables, while relations have two sets of variables, input variables and output variables.</p>

<h2 id="Error-Handling">Error Handling</h2>

<p><code>isl</code> supports different ways to react in case a runtime error is triggered. Runtime errors arise, e.g., if a function such as <code>isl_map_intersect</code> is called with two maps that have incompatible spaces. There are three possible ways to react on error: to warn, to continue or to abort.</p>

<p>The default behavior is to warn. In this mode, <code>isl</code> prints a warning, stores the last error in the corresponding <code>isl_ctx</code> and the function in which the error was triggered returns a value indicating that some error has occurred. In case of functions returning a pointer, this value is <code>NULL</code>. In case of functions returning an <code>isl_size</code>, <code>isl_bool</code> or an <code>isl_stat</code>, this value is <code>isl_size_error</code>, <code>isl_bool_error</code> or <code>isl_stat_error</code>. An error does not corrupt internal state, such that isl can continue to be used. <code>isl</code> also provides functions to read the last error, including the specific error message, the isl source file where the error occurred and the line number, and to reset all information about the last error. The last error is only stored for information purposes. Its presence does not change the behavior of <code>isl</code>. Hence, resetting an error is not required to continue to use isl, but only to observe new errors.</p>

<pre><code>#include &lt;isl/ctx.h&gt;
enum isl_error isl_ctx_last_error(isl_ctx *ctx);
const char *isl_ctx_last_error_msg(isl_ctx *ctx);
const char *isl_ctx_last_error_file(isl_ctx *ctx);
int isl_ctx_last_error_line(isl_ctx *ctx);
void isl_ctx_reset_error(isl_ctx *ctx);</code></pre>

<p>If no error has occurred since the last call to <code>isl_ctx_reset_error</code>, then the functions <code>isl_ctx_last_error_msg</code> and <code>isl_ctx_last_error_file</code> return <code>NULL</code>.</p>

<p>Another option is to continue on error. This is similar to warn on error mode, except that <code>isl</code> does not print any warning. This allows a program to implement its own error reporting.</p>

<p>The last option is to directly abort the execution of the program from within the isl library. This makes it obviously impossible to recover from an error, but it allows to directly spot the error location. By aborting on error, debuggers break at the location the error occurred and can provide a stack trace. Other tools that automatically provide stack traces on abort or that do not want to continue execution after an error was triggered may also prefer to abort on error.</p>

<p>The on error behavior of isl can be specified by calling <code>isl_options_set_on_error</code> or by setting the command line option <code>--isl-on-error</code>. Valid arguments for the function call are <code>ISL_ON_ERROR_WARN</code>, <code>ISL_ON_ERROR_CONTINUE</code> and <code>ISL_ON_ERROR_ABORT</code>. The choices for the command line option are <code>warn</code>, <code>continue</code> and <code>abort</code>. It is also possible to query the current error mode.</p>

<pre><code>#include &lt;isl/options.h&gt;
isl_stat isl_options_set_on_error(isl_ctx *ctx, int val);
int isl_options_get_on_error(isl_ctx *ctx);</code></pre>

<h2 id="Identifiers">Identifiers</h2>

<p>Identifiers are used to identify both individual dimensions and tuples of dimensions. They consist of an optional name and an optional user pointer. The name and the user pointer cannot both be <code>NULL</code>, however. Identifiers with the same name but different pointer values are considered to be distinct. Similarly, identifiers with different names but the same pointer value are also considered to be distinct. Equal identifiers are represented using the same object. Pairs of identifiers can therefore be tested for equality using the <code>==</code> operator. Identifiers can be constructed, copied, freed, inspected and printed using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_id *isl_id_alloc(isl_ctx *ctx,
        __isl_keep const char *name, void *user);
__isl_give isl_id *isl_id_set_free_user(
        __isl_take isl_id *id,
        void (*free_user)(void *user));
void (*isl_id_get_free_user(__isl_keep isl_id *id))
        (void *user);
__isl_give isl_id *isl_id_copy(isl_id *id);
__isl_null isl_id *isl_id_free(__isl_take isl_id *id);

void *isl_id_get_user(__isl_keep isl_id *id);
__isl_keep const char *isl_id_get_name(__isl_keep isl_id *id);

__isl_give isl_printer *isl_printer_print_id(
        __isl_take isl_printer *p, __isl_keep isl_id *id);</code></pre>

<p>The callback set by <code>isl_id_set_free_user</code> is called on the user pointer when the last reference to the <code>isl_id</code> is freed. This callback can be retrieved using <code>isl_id_get_free_user</code>. Note that <code>isl_id_get_name</code> returns a pointer to some internal data structure, so the result can only be used while the corresponding <code>isl_id</code> is alive.</p>

<h2 id="Spaces">Spaces</h2>

<p>Whenever a new set, relation or similar object is created from scratch, the space in which it lives needs to be specified using an <code>isl_space</code>. Each space involves zero or more parameters and zero, one or two tuples of set or input/output dimensions. The parameters and dimensions are identified by an <code>isl_dim_type</code> and a position. The type <code>isl_dim_param</code> refers to parameters, the type <code>isl_dim_set</code> refers to set dimensions (for spaces with a single tuple of dimensions) and the types <code>isl_dim_in</code> and <code>isl_dim_out</code> refer to input and output dimensions (for spaces with two tuples of dimensions). Local spaces (see <a href="#Local-Spaces">&quot;Local Spaces&quot;</a>) also contain dimensions of type <code>isl_dim_div</code>. Note that parameters are only identified by their position within a given object. Across different objects, parameters are (usually) identified by their names or identifiers. Only unnamed parameters are identified by their positions across objects. The use of unnamed parameters is discouraged.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_unit(isl_ctx *ctx);
__isl_give isl_space *isl_space_alloc(isl_ctx *ctx,
        unsigned nparam, unsigned n_in, unsigned n_out);
__isl_give isl_space *isl_space_params_alloc(isl_ctx *ctx,
        unsigned nparam);
__isl_give isl_space *isl_space_set_alloc(isl_ctx *ctx,
        unsigned nparam, unsigned dim);
__isl_give isl_space *isl_space_copy(__isl_keep isl_space *space);
__isl_null isl_space *isl_space_free(__isl_take isl_space *space);</code></pre>

<p>The space used for creating a parameter domain needs to be created using <code>isl_space_unit</code> or <code>isl_space_params_alloc</code>. For other sets, the space needs to be created using <code>isl_space_set_alloc</code>, while for a relation, the space needs to be created using <code>isl_space_alloc</code>. The use of <code>isl_space_params_alloc</code>, <code>isl_space_set_alloc</code> and <code>isl_space_alloc</code> is discouraged as they allow for the introduction of unnamed parameters.</p>

<p>To check whether a given space is that of a set or a map or whether it is a parameter space, use these functions:</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_is_params(__isl_keep isl_space *space);
isl_bool isl_space_is_set(__isl_keep isl_space *space);
isl_bool isl_space_is_map(__isl_keep isl_space *space);</code></pre>

<p>Spaces can be compared using the following functions:</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_is_equal(__isl_keep isl_space *space1,
        __isl_keep isl_space *space2);
isl_bool isl_space_has_equal_params(
        __isl_keep isl_space *space1,
        __isl_keep isl_space *space2);
isl_bool isl_space_has_equal_tuples(
        __isl_keep isl_space *space1,
        __isl_keep isl_space *space2);
isl_bool isl_space_is_domain(__isl_keep isl_space *space1,
        __isl_keep isl_space *space2);
isl_bool isl_space_is_range(__isl_keep isl_space *space1,
        __isl_keep isl_space *space2);
isl_bool isl_space_tuple_is_equal(
        __isl_keep isl_space *space1,
        enum isl_dim_type type1,
        __isl_keep isl_space *space2,
        enum isl_dim_type type2);</code></pre>

<p><code>isl_space_is_domain</code> checks whether the first argument is equal to the domain of the second argument. This requires in particular that the first argument is a set space and that the second argument is a map space. <code>isl_space_tuple_is_equal</code> checks whether the given tuples (<code>isl_dim_in</code>, <code>isl_dim_out</code> or <code>isl_dim_set</code>) of the given spaces are the same. That is, it checks if they have the same identifier (if any), the same dimension and the same internal structure (if any). The function <code>isl_space_has_equal_params</code> checks whether two spaces have the same parameters in the same order. <code>isl_space_has_equal_tuples</code> check whether two spaces have the same tuples. In contrast to <code>isl_space_is_equal</code> below, it does not check the parameters. This is useful because many <code>isl</code> functions align the parameters before they perform their operations, such that equivalence is not necessary. <code>isl_space_is_equal</code> checks whether two spaces are identical, meaning that they have the same parameters and the same tuples. That is, it checks whether both <code>isl_space_has_equal_params</code> and <code>isl_space_has_equal_tuples</code> hold.</p>

<p>It is often useful to create objects that live in the same space as some other object. This can be accomplished by creating the new objects (see <a href="#Creating-New-Sets-and-Relations">&quot;Creating New Sets and Relations&quot;</a> or <a href="#Functions">&quot;Functions&quot;</a>) based on the space of the original object.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_space *isl_basic_set_get_space(
        __isl_keep isl_basic_set *bset);
__isl_give isl_space *isl_set_get_space(__isl_keep isl_set *set);

#include &lt;isl/union_set.h&gt;
__isl_give isl_space *isl_union_set_get_space(
        __isl_keep isl_union_set *uset);

#include &lt;isl/map.h&gt;
__isl_give isl_space *isl_basic_map_get_space(
        __isl_keep isl_basic_map *bmap);
__isl_give isl_space *isl_map_get_space(__isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_space *isl_union_map_get_space(
        __isl_keep isl_union_map *umap);

#include &lt;isl/constraint.h&gt;
__isl_give isl_space *isl_constraint_get_space(
        __isl_keep isl_constraint *constraint);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_space *isl_qpolynomial_get_domain_space(
        __isl_keep isl_qpolynomial *qp);
__isl_give isl_space *isl_qpolynomial_get_space(
        __isl_keep isl_qpolynomial *qp);
__isl_give isl_space *
isl_qpolynomial_fold_get_domain_space(
        __isl_keep isl_qpolynomial_fold *fold);
__isl_give isl_space *isl_qpolynomial_fold_get_space(
        __isl_keep isl_qpolynomial_fold *fold);
__isl_give isl_space *isl_pw_qpolynomial_get_domain_space(
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_give isl_space *isl_pw_qpolynomial_get_space(
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_give isl_space *isl_pw_qpolynomial_fold_get_domain_space(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
__isl_give isl_space *isl_pw_qpolynomial_fold_get_space(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
__isl_give isl_space *isl_union_pw_qpolynomial_get_space(
        __isl_keep isl_union_pw_qpolynomial *upwqp);
__isl_give isl_space *isl_union_pw_qpolynomial_fold_get_space(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);

#include &lt;isl/id.h&gt;
__isl_give isl_space *isl_multi_id_get_space(
        __isl_keep isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_space *isl_multi_val_get_space(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_space *isl_aff_get_domain_space(
        __isl_keep isl_aff *aff);
__isl_give isl_space *isl_aff_get_space(
        __isl_keep isl_aff *aff);
__isl_give isl_space *isl_pw_aff_get_domain_space(
        __isl_keep isl_pw_aff *pwaff);
__isl_give isl_space *isl_pw_aff_get_space(
        __isl_keep isl_pw_aff *pwaff);
__isl_give isl_space *isl_multi_aff_get_domain_space(
        __isl_keep isl_multi_aff *maff);
__isl_give isl_space *isl_multi_aff_get_space(
        __isl_keep isl_multi_aff *maff);
__isl_give isl_space *isl_pw_multi_aff_get_domain_space(
        __isl_keep isl_pw_multi_aff *pma);
__isl_give isl_space *isl_pw_multi_aff_get_space(
        __isl_keep isl_pw_multi_aff *pma);
__isl_give isl_space *isl_union_pw_aff_get_space(
        __isl_keep isl_union_pw_aff *upa);
__isl_give isl_space *isl_union_pw_multi_aff_get_space(
        __isl_keep isl_union_pw_multi_aff *upma);
__isl_give isl_space *isl_multi_pw_aff_get_domain_space(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_space *isl_multi_pw_aff_get_space(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_space *
isl_multi_union_pw_aff_get_domain_space(
        __isl_keep isl_multi_union_pw_aff *mupa);
__isl_give isl_space *
isl_multi_union_pw_aff_get_space(
        __isl_keep isl_multi_union_pw_aff *mupa);

#include &lt;isl/point.h&gt;
__isl_give isl_space *isl_point_get_space(
        __isl_keep isl_point *pnt);

#include &lt;isl/fixed_box.h&gt;
__isl_give isl_space *isl_fixed_box_get_space(
        __isl_keep isl_fixed_box *box);</code></pre>

<p>The number of dimensions of a given type of space may be read off from a space or an object that lives in a space using the following functions. In case of <code>isl_space_dim</code>, type may be <code>isl_dim_param</code>, <code>isl_dim_in</code> (only for relations), <code>isl_dim_out</code> (only for relations), <code>isl_dim_set</code> (only for sets) or <code>isl_dim_all</code>.</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_size isl_space_dim(__isl_keep isl_space *space,
        enum isl_dim_type type);

#include &lt;isl/local_space.h&gt;
isl_size isl_local_space_dim(__isl_keep isl_local_space *ls,
        enum isl_dim_type type);

#include &lt;isl/set.h&gt;
isl_size isl_basic_set_dim(__isl_keep isl_basic_set *bset,
        enum isl_dim_type type);
isl_size isl_set_tuple_dim(__isl_keep isl_set *set);
isl_size isl_set_dim(__isl_keep isl_set *set,
        enum isl_dim_type type);

#include &lt;isl/union_set.h&gt;
isl_size isl_union_set_dim(__isl_keep isl_union_set *uset,
        enum isl_dim_type type);

#include &lt;isl/map.h&gt;
isl_size isl_basic_map_dim(__isl_keep isl_basic_map *bmap,
        enum isl_dim_type type);
isl_size isl_map_domain_tuple_dim(
        __isl_keep isl_map *map);
isl_size isl_map_range_tuple_dim(
        __isl_keep isl_map *map);
isl_size isl_map_dim(__isl_keep isl_map *map,
        enum isl_dim_type type);

#include &lt;isl/union_map.h&gt;
isl_size isl_union_map_dim(__isl_keep isl_union_map *umap,
        enum isl_dim_type type);

#include &lt;isl/val.h&gt;
isl_size isl_multi_val_dim(__isl_keep isl_multi_val *mv,
        enum isl_dim_type type);

#include &lt;isl/aff.h&gt;
isl_size isl_aff_dim(__isl_keep isl_aff *aff,
        enum isl_dim_type type);
isl_size isl_multi_aff_dim(__isl_keep isl_multi_aff *maff,
        enum isl_dim_type type);
isl_size isl_pw_aff_dim(__isl_keep isl_pw_aff *pwaff,
        enum isl_dim_type type);
isl_size isl_pw_multi_aff_dim(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type);
isl_size isl_multi_pw_aff_dim(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type);
isl_size isl_union_pw_aff_dim(
        __isl_keep isl_union_pw_aff *upa,
        enum isl_dim_type type);
isl_size isl_union_pw_multi_aff_dim(
        __isl_keep isl_union_pw_multi_aff *upma,
        enum isl_dim_type type);
isl_size isl_multi_union_pw_aff_dim(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type);

#include &lt;isl/polynomial.h&gt;
isl_size isl_union_pw_qpolynomial_dim(
        __isl_keep isl_union_pw_qpolynomial *upwqp,
        enum isl_dim_type type);
isl_size isl_union_pw_qpolynomial_fold_dim(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf,
        enum isl_dim_type type);</code></pre>

<p>Note that an <code>isl_union_set</code>, an <code>isl_union_map</code>, an <code>isl_union_pw_multi_aff</code>, an <code>isl_union_pw_qpolynomial</code> and an <code>isl_union_pw_qpolynomial_fold</code> only have parameters.</p>

<p>Additional parameters can be added to a space using the following function.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_add_param_id(
        __isl_take isl_space *space,
        __isl_take isl_id *id);</code></pre>

<p>If a parameter with the given identifier already appears in the space, then it is not added again.</p>

<p>Conversely, all parameters can be removed from a space using the following function.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_drop_all_params(
        __isl_take isl_space *space);</code></pre>

<p>The identifiers or names of the individual dimensions of spaces may be set or read off using the following functions on spaces or objects that live in spaces. These functions are mostly useful to obtain the identifiers, positions or names of the parameters. Identifiers of individual dimensions are essentially only useful for printing. They are ignored by all other operations and may not be preserved across those operations. To keep track of a space along with names/identifiers of the set dimensions, use an <code>isl_multi_id</code> as described in <a href="#Functions">&quot;Functions&quot;</a>.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_set_dim_id(
        __isl_take isl_space *space,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
isl_bool isl_space_has_dim_id(__isl_keep isl_space *space,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_space_get_dim_id(
        __isl_keep isl_space *space,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_space *isl_space_set_dim_name(
        __isl_take isl_space *space,
         enum isl_dim_type type, unsigned pos,
         __isl_keep const char *name);
isl_bool isl_space_has_dim_name(__isl_keep isl_space *space,
        enum isl_dim_type type, unsigned pos);
__isl_keep const char *isl_space_get_dim_name(
        __isl_keep isl_space *space,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_set_dim_id(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
isl_bool isl_local_space_has_dim_id(
        __isl_keep isl_local_space *ls,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_local_space_get_dim_id(
        __isl_keep isl_local_space *ls,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_local_space *isl_local_space_set_dim_name(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned pos, const char *s);
isl_bool isl_local_space_has_dim_name(
        __isl_keep isl_local_space *ls,
        enum isl_dim_type type, unsigned pos)
const char *isl_local_space_get_dim_name(
        __isl_keep isl_local_space *ls,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/constraint.h&gt;
const char *isl_constraint_get_dim_name(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/set.h&gt;
__isl_give isl_id *isl_basic_set_get_dim_id(
        __isl_keep isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_set *isl_set_set_dim_id(
        __isl_take isl_set *set, enum isl_dim_type type,
        unsigned pos, __isl_take isl_id *id);
isl_bool isl_set_has_dim_id(__isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_set_get_dim_id(
        __isl_keep isl_set *set, enum isl_dim_type type,
        unsigned pos);
const char *isl_basic_set_get_dim_name(
        __isl_keep isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_set_has_dim_name(__isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);
const char *isl_set_get_dim_name(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_set_dim_id(
        __isl_take isl_map *map, enum isl_dim_type type,
        unsigned pos, __isl_take isl_id *id);
isl_bool isl_basic_map_has_dim_id(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_map_has_dim_id(__isl_keep isl_map *map,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_map_get_dim_id(
        __isl_keep isl_map *map, enum isl_dim_type type,
        unsigned pos);
__isl_give isl_id *isl_union_map_get_dim_id(
        __isl_keep isl_union_map *umap,
        enum isl_dim_type type, unsigned pos);
const char *isl_basic_map_get_dim_name(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_map_has_dim_name(__isl_keep isl_map *map,
        enum isl_dim_type type, unsigned pos);
const char *isl_map_get_dim_name(
        __isl_keep isl_map *map,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_set_dim_id(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
__isl_give isl_id *isl_multi_val_get_dim_id(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_multi_val *isl_multi_val_set_dim_name(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, unsigned pos, const char *s);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_set_dim_id(
        __isl_take isl_aff *aff, enum isl_dim_type type,
        unsigned pos, __isl_take isl_id *id);
__isl_give isl_multi_aff *isl_multi_aff_set_dim_id(
        __isl_take isl_multi_aff *maff,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
__isl_give isl_pw_aff *isl_pw_aff_set_dim_id(
        __isl_take isl_pw_aff *pma,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_set_dim_id(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_dim_id(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_id *id);
__isl_give isl_id *isl_multi_aff_get_dim_id(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_pw_aff_has_dim_id(__isl_keep isl_pw_aff *pa,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_pw_aff_get_dim_id(
        __isl_keep isl_pw_aff *pa,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_pw_multi_aff_get_dim_id(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_multi_pw_aff_get_dim_id(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_id *isl_multi_union_pw_aff_get_dim_id(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_aff *isl_aff_set_dim_name(
        __isl_take isl_aff *aff, enum isl_dim_type type,
        unsigned pos, const char *s);
__isl_give isl_multi_aff *isl_multi_aff_set_dim_name(
        __isl_take isl_multi_aff *maff,
        enum isl_dim_type type, unsigned pos, const char *s);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_set_dim_name(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned pos, const char *s);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_set_dim_name(
        __isl_take isl_union_pw_aff *upa,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_set_dim_name(
        __isl_take isl_union_pw_multi_aff *upma,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_dim_name(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, unsigned pos,
        const char *s);
const char *isl_aff_get_dim_name(__isl_keep isl_aff *aff,
        enum isl_dim_type type, unsigned pos);
const char *isl_pw_aff_get_dim_name(
        __isl_keep isl_pw_aff *pa,
        enum isl_dim_type type, unsigned pos);
const char *isl_pw_multi_aff_get_dim_name(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type, unsigned pos);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_set_dim_name(
        __isl_take isl_qpolynomial *qp,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_set_dim_name(
        __isl_take isl_pw_qpolynomial *pwqp,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_set_dim_name(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_set_dim_name(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        enum isl_dim_type type, unsigned pos,
        const char *s);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_set_dim_name(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        enum isl_dim_type type, unsigned pos,
        const char *s);</code></pre>

<p>Note that <code>isl_space_get_name</code> returns a pointer to some internal data structure, so the result can only be used while the corresponding <code>isl_space</code> is alive. Also note that every function that operates on two sets or relations requires that both arguments have the same parameters. This also means that if one of the arguments has named parameters, then the other needs to have named parameters too and the names need to match. Pairs of <code>isl_set</code>, <code>isl_map</code>, <code>isl_union_set</code> and/or <code>isl_union_map</code> arguments may have different parameters (as long as they are named), in which case the result will have as parameters the union of the parameters of the arguments.</p>

<p>Given the identifier or name of a dimension (typically a parameter), its position can be obtained from the following functions.</p>

<pre><code>#include &lt;isl/space.h&gt;
int isl_space_find_dim_by_id(__isl_keep isl_space *space,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_space_find_dim_by_name(__isl_keep isl_space *space,
        enum isl_dim_type type, const char *name);

#include &lt;isl/local_space.h&gt;
int isl_local_space_find_dim_by_name(
        __isl_keep isl_local_space *ls,
        enum isl_dim_type type, const char *name);

#include &lt;isl/val.h&gt;
int isl_multi_val_find_dim_by_id(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_multi_val_find_dim_by_name(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type, const char *name);

#include &lt;isl/set.h&gt;
int isl_set_find_dim_by_id(__isl_keep isl_set *set,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_set_find_dim_by_name(__isl_keep isl_set *set,
        enum isl_dim_type type, const char *name);

#include &lt;isl/map.h&gt;
int isl_map_find_dim_by_id(__isl_keep isl_map *map,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_basic_map_find_dim_by_name(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type, const char *name);
int isl_map_find_dim_by_name(__isl_keep isl_map *map,
        enum isl_dim_type type, const char *name);
int isl_union_map_find_dim_by_name(
        __isl_keep isl_union_map *umap,
        enum isl_dim_type type, const char *name);

#include &lt;isl/aff.h&gt;
int isl_multi_aff_find_dim_by_id(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_multi_pw_aff_find_dim_by_id(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_multi_union_pw_aff_find_dim_by_id(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, __isl_keep isl_id *id);
int isl_aff_find_dim_by_name(__isl_keep isl_aff *aff,
        enum isl_dim_type type, const char *name);
int isl_multi_aff_find_dim_by_name(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type, const char *name);
int isl_pw_aff_find_dim_by_name(__isl_keep isl_pw_aff *pa,
        enum isl_dim_type type, const char *name);
int isl_multi_pw_aff_find_dim_by_name(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type, const char *name);
int isl_pw_multi_aff_find_dim_by_name(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type, const char *name);
int isl_union_pw_aff_find_dim_by_name(
        __isl_keep isl_union_pw_aff *upa,
        enum isl_dim_type type, const char *name);
int isl_union_pw_multi_aff_find_dim_by_name(
        __isl_keep isl_union_pw_multi_aff *upma,
        enum isl_dim_type type, const char *name);
int isl_multi_union_pw_aff_find_dim_by_name(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, const char *name);

#include &lt;isl/polynomial.h&gt;
int isl_pw_qpolynomial_find_dim_by_name(
        __isl_keep isl_pw_qpolynomial *pwqp,
        enum isl_dim_type type, const char *name);
int isl_pw_qpolynomial_fold_find_dim_by_name(
        __isl_keep isl_pw_qpolynomial_fold *pwf,
        enum isl_dim_type type, const char *name);
int isl_union_pw_qpolynomial_find_dim_by_name(
        __isl_keep isl_union_pw_qpolynomial *upwqp,
        enum isl_dim_type type, const char *name);
int isl_union_pw_qpolynomial_fold_find_dim_by_name(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf,
        enum isl_dim_type type, const char *name);</code></pre>

<p>The identifiers or names of entire spaces may be set or read off using the following functions.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_set_domain_tuple_id(
        __isl_take isl_space *space,
        __isl_take isl_id *id);
__isl_give isl_space *isl_space_set_range_tuple_id(
        __isl_take isl_space *space,
        __isl_take isl_id *id);
__isl_give isl_space *isl_space_set_tuple_id(
        __isl_take isl_space *space,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_space *isl_space_reset_tuple_id(
        __isl_take isl_space *space, enum isl_dim_type type);
isl_bool isl_space_has_domain_tuple_id(
        __isl_keep isl_space *space);
isl_bool isl_space_has_range_tuple_id(
        __isl_keep isl_space *space);
isl_bool isl_space_has_tuple_id(
        __isl_keep isl_space *space,
        enum isl_dim_type type);
__isl_give isl_id *isl_space_get_domain_tuple_id(
        __isl_keep isl_space *space);
__isl_give isl_id *isl_space_get_range_tuple_id(
        __isl_keep isl_space *space);
__isl_give isl_id *isl_space_get_tuple_id(
        __isl_keep isl_space *space, enum isl_dim_type type);
__isl_give isl_space *isl_space_set_tuple_name(
        __isl_take isl_space *space,
        enum isl_dim_type type, const char *s);
isl_bool isl_space_has_tuple_name(
        __isl_keep isl_space *space,
        enum isl_dim_type type);
__isl_keep const char *isl_space_get_tuple_name(
        __isl_keep isl_space *space,
        enum isl_dim_type type);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_set_tuple_id(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, __isl_take isl_id *id);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_set_tuple_id(
        __isl_take isl_basic_set *bset,
        __isl_take isl_id *id);
__isl_give isl_set *isl_set_set_tuple_id(
        __isl_take isl_set *set, __isl_take isl_id *id);
__isl_give isl_set *isl_set_reset_tuple_id(
        __isl_take isl_set *set);
isl_bool isl_set_has_tuple_id(__isl_keep isl_set *set);
__isl_give isl_id *isl_set_get_tuple_id(
        __isl_keep isl_set *set);
__isl_give isl_basic_set *isl_basic_set_set_tuple_name(
        __isl_take isl_basic_set *set, const char *s);
__isl_give isl_set *isl_set_set_tuple_name(
        __isl_take isl_set *set, const char *s);
const char *isl_basic_set_get_tuple_name(
        __isl_keep isl_basic_set *bset);
isl_bool isl_set_has_tuple_name(__isl_keep isl_set *set);
const char *isl_set_get_tuple_name(
        __isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_set_tuple_id(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_map *isl_map_set_domain_tuple_id(
        __isl_take isl_map *map, __isl_take isl_id *id);
__isl_give isl_map *isl_map_set_range_tuple_id(
        __isl_take isl_map *map, __isl_take isl_id *id);
__isl_give isl_map *isl_map_set_tuple_id(
        __isl_take isl_map *map, enum isl_dim_type type,
        __isl_take isl_id *id);
__isl_give isl_map *isl_map_reset_tuple_id(
        __isl_take isl_map *map, enum isl_dim_type type);
isl_bool isl_map_has_domain_tuple_id(
        __isl_keep isl_map *map);
isl_bool isl_map_has_range_tuple_id(
        __isl_keep isl_map *map);
isl_bool isl_map_has_tuple_id(__isl_keep isl_map *map,
        enum isl_dim_type type);
__isl_give isl_id *isl_map_get_domain_tuple_id(
        __isl_keep isl_map *map);
__isl_give isl_id *isl_map_get_range_tuple_id(
        __isl_keep isl_map *map);
__isl_give isl_id *isl_map_get_tuple_id(
        __isl_keep isl_map *map, enum isl_dim_type type);
__isl_give isl_map *isl_map_set_tuple_name(
        __isl_take isl_map *map,
        enum isl_dim_type type, const char *s);
const char *isl_basic_map_get_tuple_name(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type);
__isl_give isl_basic_map *isl_basic_map_set_tuple_name(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, const char *s);
isl_bool isl_map_has_tuple_name(__isl_keep isl_map *map,
        enum isl_dim_type type);
const char *isl_map_get_tuple_name(
        __isl_keep isl_map *map,
        enum isl_dim_type type);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_set_range_tuple_id(
        __isl_take isl_multi_val *mv,
        __isl_take isl_id *id);
__isl_give isl_multi_val *isl_multi_val_set_tuple_id(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_multi_val *
isl_multi_val_reset_range_tuple_id(
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_val *isl_multi_val_reset_tuple_id(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type);
isl_bool isl_multi_val_has_range_tuple_id(
        __isl_keep isl_multi_val *mv);
__isl_give isl_id *isl_multi_val_get_range_tuple_id(
        __isl_keep isl_multi_val *mv);
isl_bool isl_multi_val_has_tuple_id(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type);
__isl_give isl_id *isl_multi_val_get_tuple_id(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type);
__isl_give isl_multi_val *isl_multi_val_set_tuple_name(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, const char *s);
const char *isl_multi_val_get_tuple_name(
        __isl_keep isl_multi_val *mv,
        enum isl_dim_type type);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_set_tuple_id(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_multi_aff *isl_multi_aff_set_range_tuple_id(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_id *id);
__isl_give isl_multi_aff *isl_multi_aff_set_tuple_id(
        __isl_take isl_multi_aff *maff,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_pw_aff *isl_pw_aff_set_tuple_id(
        __isl_take isl_pw_aff *pwaff,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_set_range_tuple_id(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_id *id);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_set_tuple_id(
        __isl_take isl_pw_multi_aff *pma,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_set_range_tuple_id(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_id *id);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_range_tuple_id(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_id *id);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_tuple_id(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, __isl_take isl_id *id);
__isl_give isl_multi_aff *
isl_multi_aff_reset_range_tuple_id(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_reset_range_tuple_id(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_reset_range_tuple_id(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_multi_aff *isl_multi_aff_reset_tuple_id(
        __isl_take isl_multi_aff *ma,
        enum isl_dim_type type);
__isl_give isl_pw_aff *isl_pw_aff_reset_tuple_id(
        __isl_take isl_pw_aff *pa,
        enum isl_dim_type type);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_reset_tuple_id(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_reset_tuple_id(
        __isl_take isl_pw_multi_aff *pma,
        enum isl_dim_type type);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_reset_tuple_id(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type);
isl_bool isl_multi_aff_has_range_tuple_id(
        __isl_keep isl_multi_aff *ma);
__isl_give isl_id *isl_multi_aff_get_range_tuple_id(
        __isl_keep isl_multi_aff *ma);
isl_bool isl_multi_aff_has_tuple_id(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type);
__isl_give isl_id *isl_multi_aff_get_tuple_id(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type);
isl_bool isl_pw_aff_has_tuple_id(__isl_keep isl_pw_aff *pa,
        enum isl_dim_type type);
__isl_give isl_id *isl_pw_aff_get_tuple_id(
        __isl_keep isl_pw_aff *pa,
        enum isl_dim_type type);
isl_bool isl_pw_multi_aff_has_range_tuple_id(
        __isl_keep isl_pw_multi_aff *pma);
isl_bool isl_pw_multi_aff_has_tuple_id(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type);
__isl_give isl_id *isl_pw_multi_aff_get_range_tuple_id(
        __isl_keep isl_pw_multi_aff *pma);
__isl_give isl_id *isl_pw_multi_aff_get_tuple_id(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type);
isl_bool isl_multi_pw_aff_has_range_tuple_id(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_id *isl_multi_pw_aff_get_range_tuple_id(
        __isl_keep isl_multi_pw_aff *mpa);
isl_bool isl_multi_pw_aff_has_tuple_id(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type);
__isl_give isl_id *isl_multi_pw_aff_get_tuple_id(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type);
isl_bool isl_multi_union_pw_aff_has_range_tuple_id(
        __isl_keep isl_multi_union_pw_aff *mupa);
__isl_give isl_id *
isl_multi_union_pw_aff_get_range_tuple_id(
        __isl_keep isl_multi_union_pw_aff *mupa);
isl_bool isl_multi_union_pw_aff_has_tuple_id(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type);
__isl_give isl_id *isl_multi_union_pw_aff_get_tuple_id(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type);
__isl_give isl_multi_aff *isl_multi_aff_set_tuple_name(
        __isl_take isl_multi_aff *maff,
        enum isl_dim_type type, const char *s);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_set_tuple_name(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type, const char *s);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_tuple_name(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, const char *s);
const char *isl_multi_aff_get_tuple_name(
        __isl_keep isl_multi_aff *multi,
        enum isl_dim_type type);
isl_bool isl_pw_multi_aff_has_tuple_name(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type);
const char *isl_pw_multi_aff_get_tuple_name(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type);
const char *isl_multi_union_pw_aff_get_tuple_name(
        __isl_keep isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type);</code></pre>

<p>The <code>type</code> argument needs to be one of <code>isl_dim_in</code>, <code>isl_dim_out</code> or <code>isl_dim_set</code>. As with <code>isl_space_get_name</code>, the <code>isl_space_get_tuple_name</code> function returns a pointer to some internal data structure. Binary operations require the corresponding spaces of their arguments to have the same name.</p>

<p>To keep the names of all parameters and tuples, but reset the user pointers of all the corresponding identifiers, use the following function.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_reset_user(
        __isl_take isl_space *space);

#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_reset_user(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_reset_user(
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_reset_user(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_reset_user(
        __isl_take isl_union_map *umap);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_reset_user(
        __isl_take isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_reset_user(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_reset_user(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_reset_user(
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_reset_user(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_reset_user(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_pw_aff *isl_union_pw_aff_reset_user(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_reset_user(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_reset_user(
        __isl_take isl_union_pw_multi_aff *upma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_reset_user(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_reset_user(
        __isl_take isl_union_pw_qpolynomial *upwqp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_reset_user(
        __isl_take isl_pw_qpolynomial_fold *pwf);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_reset_user(
        __isl_take isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>Spaces can be nested. In particular, the domain of a set or the domain or range of a relation can be a nested relation. This process is also called <i>wrapping</i>. The functions for detecting, constructing and deconstructing such nested spaces can be found in the wrapping properties of <a href="#Unary-Properties">&quot;Unary Properties&quot;</a>, the wrapping operations of <a href="#Unary-Operations">&quot;Unary Operations&quot;</a> and the Cartesian product operations of <a href="#Basic-Operations">&quot;Basic Operations&quot;</a>.</p>

<p>Spaces can be created from other spaces using the functions described in <a href="#Unary-Operations">&quot;Unary Operations&quot;</a> and <a href="#Binary-Operations">&quot;Binary Operations&quot;</a>.</p>

<h2 id="Local-Spaces">Local Spaces</h2>

<p>A local space is essentially a space with zero or more existentially quantified variables. The local space of various objects can be obtained using the following functions.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
__isl_give isl_local_space *isl_constraint_get_local_space(
        __isl_keep isl_constraint *constraint);

#include &lt;isl/set.h&gt;
__isl_give isl_local_space *isl_basic_set_get_local_space(
        __isl_keep isl_basic_set *bset);

#include &lt;isl/map.h&gt;
__isl_give isl_local_space *isl_basic_map_get_local_space(
        __isl_keep isl_basic_map *bmap);

#include &lt;isl/aff.h&gt;
__isl_give isl_local_space *isl_aff_get_domain_local_space(
        __isl_keep isl_aff *aff);
__isl_give isl_local_space *isl_aff_get_local_space(
        __isl_keep isl_aff *aff);</code></pre>

<p>A new local space can be created from a space using</p>

<pre><code>#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_from_space(
        __isl_take isl_space *space);</code></pre>

<p>They can be inspected, modified, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/local_space.h&gt;
isl_bool isl_local_space_is_params(
        __isl_keep isl_local_space *ls);
isl_bool isl_local_space_is_set(
        __isl_keep isl_local_space *ls);
__isl_give isl_space *isl_local_space_get_space(
        __isl_keep isl_local_space *ls);
__isl_give isl_aff *isl_local_space_get_div(
        __isl_keep isl_local_space *ls, int pos);
__isl_give isl_local_space *isl_local_space_copy(
        __isl_keep isl_local_space *ls);
__isl_null isl_local_space *isl_local_space_free(
        __isl_take isl_local_space *ls);</code></pre>

<p>Note that <code>isl_local_space_get_div</code> can only be used on local spaces of sets.</p>

<p>Two local spaces can be compared using</p>

<pre><code>isl_bool isl_local_space_is_equal(
        __isl_keep isl_local_space *ls1,
        __isl_keep isl_local_space *ls2);</code></pre>

<p>Local spaces can be created from other local spaces using the functions described in <a href="#Unary-Operations">&quot;Unary Operations&quot;</a> and <a href="#Binary-Operations">&quot;Binary Operations&quot;</a>.</p>

<h2 id="Creating-New-Sets-and-Relations">Creating New Sets and Relations</h2>

<p><code>isl</code> has functions for creating some standard sets and relations.</p>

<ul>

<li><p>Empty sets and relations</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_empty(
        __isl_take isl_space *space);
__isl_give isl_basic_map *isl_basic_map_empty(
        __isl_take isl_space *space);
__isl_give isl_set *isl_set_empty(
        __isl_take isl_space *space);
__isl_give isl_map *isl_map_empty(
        __isl_take isl_space *space);
__isl_give isl_union_set *isl_union_set_empty_ctx(
        isl_ctx *ctx);
__isl_give isl_union_set *isl_union_set_empty_space(
        __isl_take isl_space *space);
__isl_give isl_union_set *isl_union_set_empty(
        __isl_take isl_space *space);
__isl_give isl_union_map *isl_union_map_empty_ctx(
        isl_ctx *ctx);
__isl_give isl_union_map *isl_union_map_empty_space(
        __isl_take isl_space *space);
__isl_give isl_union_map *isl_union_map_empty(
        __isl_take isl_space *space);</code></pre>

<p>For <code>isl_union_set</code>s and <code>isl_union_map</code>s, the space is only used to specify the parameters. <code>isl_union_set_empty</code> is an alternative name for <code>isl_union_set_empty_space</code>. Similarly for the other pair of functions.</p>

</li>
<li><p>Universe sets and relations</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_universe(
        __isl_take isl_space *space);
__isl_give isl_set *isl_set_universe(
        __isl_take isl_space *space);
__isl_give isl_set *isl_space_universe_set(
        __isl_take isl_space *space);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_universe(
        __isl_take isl_space *space);
__isl_give isl_map *isl_map_universe(
        __isl_take isl_space *space);
__isl_give isl_map *isl_space_universe_map(
        __isl_take isl_space *space);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_universe(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_universe(
        __isl_take isl_union_map *umap);</code></pre>

<p><code>isl_set_universe</code> and <code>isl_space_universe_set</code> perform the same operation. Similarly for the pair <code>isl_map_universe</code> and <code>isl_space_universe_map</code>.</p>

<p>The sets and relations constructed by the functions above contain all integer values, while those constructed by the functions below only contain non-negative values.</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_nat_universe(
        __isl_take isl_space *space);
__isl_give isl_basic_map *isl_basic_map_nat_universe(
        __isl_take isl_space *space);
__isl_give isl_set *isl_set_nat_universe(
        __isl_take isl_space *space);
__isl_give isl_map *isl_map_nat_universe(
        __isl_take isl_space *space);</code></pre>

</li>
<li><p>Identity relations</p>

<pre><code>__isl_give isl_basic_map *isl_basic_map_identity(
        __isl_take isl_space *space);
__isl_give isl_map *isl_map_identity(
        __isl_take isl_space *space);</code></pre>

<p>The number of input and output dimensions in <code>space</code> needs to be the same.</p>

</li>
<li><p>Lexicographic order</p>

<pre><code>__isl_give isl_map *isl_map_lex_lt(
        __isl_take isl_space *set_space);
__isl_give isl_map *isl_map_lex_le(
        __isl_take isl_space *set_space);
__isl_give isl_map *isl_map_lex_gt(
        __isl_take isl_space *set_space);
__isl_give isl_map *isl_map_lex_ge(
        __isl_take isl_space *set_space);
__isl_give isl_map *isl_map_lex_lt_first(
        __isl_take isl_space *space, unsigned n);
__isl_give isl_map *isl_map_lex_le_first(
        __isl_take isl_space *space, unsigned n);
__isl_give isl_map *isl_map_lex_gt_first(
        __isl_take isl_space *space, unsigned n);
__isl_give isl_map *isl_map_lex_ge_first(
        __isl_take isl_space *space, unsigned n);</code></pre>

<p>The first four functions take a space for a <b>set</b> and return relations that express that the elements in the domain are lexicographically less (<code>isl_map_lex_lt</code>), less or equal (<code>isl_map_lex_le</code>), greater (<code>isl_map_lex_gt</code>) or greater or equal (<code>isl_map_lex_ge</code>) than the elements in the range. The last four functions take a space for a map and return relations that express that the first <code>n</code> dimensions in the domain are lexicographically less (<code>isl_map_lex_lt_first</code>), less or equal (<code>isl_map_lex_le_first</code>), greater (<code>isl_map_lex_gt_first</code>) or greater or equal (<code>isl_map_lex_ge_first</code>) than the first <code>n</code> dimensions in the range.</p>

</li>
</ul>

<p>A basic set or relation can be converted to a set or relation using the following functions.</p>

<pre><code>__isl_give isl_set *isl_basic_set_to_set(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_from_basic_set(
        __isl_take isl_basic_set *bset);
__isl_give isl_map *isl_map_from_basic_map(
        __isl_take isl_basic_map *bmap);</code></pre>

<p><code>isl_basic_set_to_set</code> and <code>isl_set_from_basic_set</code> perform the same operation.</p>

<p>Sets and relations can be converted to union sets and relations using the following functions.</p>

<pre><code>__isl_give isl_union_set *isl_union_set_from_basic_set(
        __isl_take isl_basic_set *bset);
__isl_give isl_union_map *isl_union_map_from_basic_map(
        __isl_take isl_basic_map *bmap);
__isl_give isl_union_set *isl_set_to_union_set(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_from_set(
        __isl_take isl_set *set);
__isl_give isl_union_map *isl_map_to_union_map(
        __isl_take isl_map *map);
__isl_give isl_union_map *isl_union_map_from_map(
        __isl_take isl_map *map);</code></pre>

<p><code>isl_map_to_union_map</code> and <code>isl_union_map_from_map</code> perform the same operation. Similarly for <code>isl_set_to_union_set</code> and <code>isl_union_set_from_set</code>.</p>

<p>The inverse conversions below can only be used if the input union set or relation is known to contain elements in exactly one space.</p>

<pre><code>#include &lt;isl/union_set.h&gt;
isl_bool isl_union_set_isa_set(
        __isl_keep isl_union_set *uset);
__isl_give isl_set *isl_union_set_as_set(
        __isl_take isl_union_set *uset);
__isl_give isl_set *isl_set_from_union_set(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_isa_map(
        __isl_keep isl_union_map *umap);
__isl_give isl_map *isl_union_map_as_map(
        __isl_take isl_union_map *umap);
__isl_give isl_map *isl_map_from_union_map(
        __isl_take isl_union_map *umap);</code></pre>

<p><code>isl_union_map_as_map</code> and <code>isl_map_from_union_map</code> perform the same operation. Similarly for <code>isl_union_set_as_set</code> and <code>isl_set_from_union_set</code>.</p>

<p>Sets and relations can be copied and freed again using the following functions.</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_copy(
        __isl_keep isl_basic_set *bset);
__isl_give isl_set *isl_set_copy(__isl_keep isl_set *set);
__isl_give isl_union_set *isl_union_set_copy(
        __isl_keep isl_union_set *uset);
__isl_give isl_basic_map *isl_basic_map_copy(
        __isl_keep isl_basic_map *bmap);
__isl_give isl_map *isl_map_copy(__isl_keep isl_map *map);
__isl_give isl_union_map *isl_union_map_copy(
        __isl_keep isl_union_map *umap);
__isl_null isl_basic_set *isl_basic_set_free(
        __isl_take isl_basic_set *bset);
__isl_null isl_set *isl_set_free(__isl_take isl_set *set);
__isl_null isl_union_set *isl_union_set_free(
        __isl_take isl_union_set *uset);
__isl_null isl_basic_map *isl_basic_map_free(
        __isl_take isl_basic_map *bmap);
__isl_null isl_map *isl_map_free(__isl_take isl_map *map);
__isl_null isl_union_map *isl_union_map_free(
        __isl_take isl_union_map *umap);</code></pre>

<p>Other sets and relations can be constructed by starting from a universe set or relation, adding equality and/or inequality constraints and then projecting out the existentially quantified variables, if any. Constraints can be constructed, manipulated and added to (or removed from) (basic) sets and relations using the following functions.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
__isl_give isl_constraint *isl_constraint_alloc_equality(
        __isl_take isl_local_space *ls);
__isl_give isl_constraint *isl_constraint_alloc_inequality(
        __isl_take isl_local_space *ls);
__isl_give isl_constraint *isl_constraint_set_constant_si(
        __isl_take isl_constraint *constraint, int v);
__isl_give isl_constraint *isl_constraint_set_constant_val(
        __isl_take isl_constraint *constraint,
        __isl_take isl_val *v);
__isl_give isl_constraint *isl_constraint_set_coefficient_si(
        __isl_take isl_constraint *constraint,
        enum isl_dim_type type, int pos, int v);
__isl_give isl_constraint *
isl_constraint_set_coefficient_val(
        __isl_take isl_constraint *constraint,
        enum isl_dim_type type, int pos,
        __isl_take isl_val *v);
__isl_give isl_basic_map *isl_basic_map_add_constraint(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_constraint *constraint);
__isl_give isl_basic_set *isl_basic_set_add_constraint(
        __isl_take isl_basic_set *bset,
        __isl_take isl_constraint *constraint);
__isl_give isl_map *isl_map_add_constraint(
        __isl_take isl_map *map,
        __isl_take isl_constraint *constraint);
__isl_give isl_set *isl_set_add_constraint(
        __isl_take isl_set *set,
        __isl_take isl_constraint *constraint);</code></pre>

<p>For example, to create a set containing the even integers between 10 and 42, you could use the following code.</p>

<pre><code>isl_space *space;
isl_local_space *ls;
isl_constraint *c;
isl_basic_set *bset;

space = isl_space_set_alloc(ctx, 0, 2);
bset = isl_basic_set_universe(isl_space_copy(space));
ls = isl_local_space_from_space(space);

c = isl_constraint_alloc_equality(isl_local_space_copy(ls));
c = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);
c = isl_constraint_set_coefficient_si(c, isl_dim_set, 1, 2);
bset = isl_basic_set_add_constraint(bset, c);

c = isl_constraint_alloc_inequality(isl_local_space_copy(ls));
c = isl_constraint_set_constant_si(c, -10);
c = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, 1);
bset = isl_basic_set_add_constraint(bset, c);

c = isl_constraint_alloc_inequality(ls);
c = isl_constraint_set_constant_si(c, 42);
c = isl_constraint_set_coefficient_si(c, isl_dim_set, 0, -1);
bset = isl_basic_set_add_constraint(bset, c);

bset = isl_basic_set_project_out(bset, isl_dim_set, 1, 1);</code></pre>

<p>However, this is considered to be a fairly low-level approach. It is more appropriate to construct a (basic) set by means of affine expressions (defined below in <a href="#Functions">&quot;Functions&quot;</a>). For example, the same set could be constructed as follows.</p>

<pre><code>isl_val *v, *two;
isl_space *space;
isl_multi_aff *ma;
isl_aff *var, *cst;
isl_basic_set *bset;

space = isl_space_unit(ctx);
space = isl_space_add_unnamed_tuple_ui(space, 1);
ma = isl_multi_aff_identity_on_domain_space(
        isl_space_copy(space));
var = isl_multi_aff_get_at(ma, 0);
v = isl_val_int_from_si(ctx, 10);
cst = isl_aff_val_on_domain_space(isl_space_copy(space), v);
bset = isl_aff_ge_basic_set(isl_aff_copy(var), cst);

v = isl_val_int_from_si(ctx, 42);
cst = isl_aff_val_on_domain_space(space, v);
bset = isl_basic_set_intersect(bset,
        isl_aff_le_basic_set(var, cst));

two = isl_val_int_from_si(ctx, 2);
ma = isl_multi_aff_scale_val(ma, isl_val_copy(two));
bset = isl_basic_set_preimage_multi_aff(bset,
        isl_multi_aff_copy(ma));
ma = isl_multi_aff_scale_down_val(ma, isl_val_copy(two));
ma = isl_multi_aff_scale_down_val(ma, two);
bset = isl_basic_set_preimage_multi_aff(bset, ma);</code></pre>

<p>Alternatively, the set can be parsed from a string representation.</p>

<pre><code>isl_basic_set *bset;
bset = isl_basic_set_read_from_str(ctx,
        &quot;{[i] : exists (a : i = 2a and i &gt;= 10 and i &lt;= 42)}&quot;);</code></pre>

<p>A basic set or relation can also be constructed from two matrices describing the equalities and the inequalities.</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_from_constraint_matrices(
        __isl_take isl_space *space,
        __isl_take isl_mat *eq, __isl_take isl_mat *ineq,
        enum isl_dim_type c1,
        enum isl_dim_type c2, enum isl_dim_type c3,
        enum isl_dim_type c4);
__isl_give isl_basic_map *isl_basic_map_from_constraint_matrices(
        __isl_take isl_space *space,
        __isl_take isl_mat *eq, __isl_take isl_mat *ineq,
        enum isl_dim_type c1,
        enum isl_dim_type c2, enum isl_dim_type c3,
        enum isl_dim_type c4, enum isl_dim_type c5);</code></pre>

<p>The <code>isl_dim_type</code> arguments indicate the order in which different kinds of variables appear in the input matrices and should be a permutation of <code>isl_dim_cst</code> (the constant term), <code>isl_dim_param</code>, <code>isl_dim_set</code> and <code>isl_dim_div</code> for sets and of <code>isl_dim_cst</code>, <code>isl_dim_param</code>, <code>isl_dim_in</code>, <code>isl_dim_out</code> and <code>isl_dim_div</code> for relations.</p>

<p>A (basic or union) set or relation can also be constructed from a (union) (piecewise) (multiple) affine expression or a list of affine expressions (See <a href="#Functions">&quot;Functions&quot;</a>), provided these affine expressions do not involve any NaN.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_from_multi_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_set *isl_multi_aff_as_set(
        __isl_take isl_multi_aff *ma);
__isl_give isl_set *isl_set_from_multi_aff(
        __isl_take isl_multi_aff *ma);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_map *isl_map_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_basic_map *isl_basic_map_from_aff_list(
        __isl_take isl_space *domain_space,
        __isl_take isl_aff_list *list);
__isl_give isl_basic_map *isl_basic_map_from_multi_aff(
        __isl_take isl_multi_aff *maff)
__isl_give isl_map *isl_multi_aff_as_map(
        __isl_take isl_multi_aff *ma);
__isl_give isl_map *isl_map_from_multi_aff(
        __isl_take isl_multi_aff *maff)

#include &lt;isl/aff.h&gt;
__isl_give isl_set *isl_set_from_pw_aff(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_map *isl_pw_aff_as_map(
        __isl_take isl_pw_aff *pa);
__isl_give isl_map *isl_map_from_pw_aff(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_set *isl_pw_multi_aff_as_set(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_set *isl_set_from_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_map *isl_pw_multi_aff_as_map(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_map *isl_map_from_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_set *isl_multi_pw_aff_as_set(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_set *isl_set_from_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_multi_pw_aff_as_map(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_map_from_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_union_map *isl_union_map_from_union_pw_aff(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_map *
isl_union_pw_multi_aff_as_union_map(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_map *
isl_union_map_from_union_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_map *
isl_union_map_from_multi_union_pw_aff(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>The <code>domain_space</code> argument describes the domain of the resulting basic relation. It is required because the <code>list</code> may consist of zero affine expressions. The <code>mupa</code> passed to <code>isl_union_map_from_multi_union_pw_aff</code> is not allowed to be zero-dimensional. The domain of the result is the shared domain of the union piecewise affine elements. <code>isl_multi_aff_as_set</code> and <code>isl_set_from_multi_aff</code> perform the same operation. Similarly for the pair <code>isl_multi_aff_as_map</code> and <code>isl_map_from_multi_aff</code>, for the pair <code>isl_pw_aff_as_map</code> and <code>isl_map_from_pw_aff</code>, for the pair <code>isl_pw_multi_aff_as_set</code> and <code>isl_set_from_pw_multi_aff</code>, for the pair <code>isl_pw_multi_aff_as_map</code> and <code>isl_map_from_pw_multi_aff</code>, the pair <code>isl_multi_pw_aff_as_set</code> and <code>isl_set_from_multi_pw_aff</code>, the pair <code>isl_multi_pw_aff_as_map</code> and <code>isl_map_from_multi_pw_aff</code>, and <code>isl_union_pw_multi_aff_as_union_map</code> and <code>isl_union_map_from_union_pw_multi_aff</code>.</p>

<h2 id="Inspecting-Sets-and-Relations">Inspecting Sets and Relations</h2>

<p>Usually, the user should not have to care about the actual constraints of the sets and maps, but should instead apply the abstract operations explained in the following sections. Occasionally, however, it may be required to inspect the individual coefficients of the constraints. This section explains how to do so. In these cases, it may also be useful to have <code>isl</code> compute an explicit representation of the existentially quantified variables.</p>

<pre><code>__isl_give isl_set *isl_set_compute_divs(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_compute_divs(
        __isl_take isl_map *map);
__isl_give isl_union_set *isl_union_set_compute_divs(
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_compute_divs(
        __isl_take isl_union_map *umap);</code></pre>

<p>This explicit representation defines the existentially quantified variables as integer divisions of the other variables, possibly including earlier existentially quantified variables. An explicitly represented existentially quantified variable therefore has a unique value when the values of the other variables are known.</p>

<p>Alternatively, the existentially quantified variables can be removed using the following functions, which compute an overapproximation.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_remove_divs(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_remove_divs(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_remove_divs(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_remove_divs(
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_remove_divs(
        __isl_take isl_union_set *bset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_remove_divs(
        __isl_take isl_union_map *bmap);</code></pre>

<p>It is also possible to only remove those divs that are defined in terms of a given range of dimensions or only those for which no explicit representation is known.</p>

<pre><code>__isl_give isl_basic_set *
isl_basic_set_remove_divs_involving_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_basic_map *
isl_basic_map_remove_divs_involving_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_set *isl_set_remove_divs_involving_dims(
        __isl_take isl_set *set, enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_map *isl_map_remove_divs_involving_dims(
        __isl_take isl_map *map, enum isl_dim_type type,
        unsigned first, unsigned n);

__isl_give isl_basic_set *
isl_basic_set_remove_unknown_divs(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_remove_unknown_divs(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_remove_unknown_divs(
        __isl_take isl_map *map);</code></pre>

<p>To iterate over all the sets or maps in a union set or map, use</p>

<pre><code>#include &lt;isl/union_set.h&gt;
isl_stat isl_union_set_foreach_set(
        __isl_keep isl_union_set *uset,
        isl_stat (*fn)(__isl_take isl_set *set, void *user),
        void *user);
isl_bool isl_union_set_every_set(
        __isl_keep isl_union_set *uset,
        isl_bool (*test)(__isl_keep isl_set *set,
                void *user),
        void *user);

#include &lt;isl/union_map.h&gt;
isl_stat isl_union_map_foreach_map(
        __isl_keep isl_union_map *umap,
        isl_stat (*fn)(__isl_take isl_map *map, void *user),
        void *user);
isl_bool isl_union_map_every_map(
        __isl_keep isl_union_map *umap,
        isl_bool (*test)(__isl_keep isl_map *map,
                void *user),
        void *user);</code></pre>

<p>These functions call the callback function once for each (pair of) space(s) for which there are elements in the input. The argument to the callback contains all elements in the input with that (pair of) space(s). The <code>isl_union_set_every_set</code> and <code>isl_union_map_every_map</code> variants check whether each call to the callback returns true and stops checking as soon as one of these calls returns false.</p>

<p>The number of sets or maps in a union set or map can be obtained from</p>

<pre><code>isl_size isl_union_set_n_set(__isl_keep isl_union_set *uset);
isl_size isl_union_map_n_map(__isl_keep isl_union_map *umap);</code></pre>

<p>To extract the set or map in a given space from a union, use</p>

<pre><code>__isl_give isl_set *isl_union_set_extract_set(
        __isl_keep isl_union_set *uset,
        __isl_take isl_space *space);
__isl_give isl_map *isl_union_map_extract_map(
        __isl_keep isl_union_map *umap,
        __isl_take isl_space *space);</code></pre>

<p>To iterate over all the basic sets or maps in a set or map, use</p>

<pre><code>isl_stat isl_set_foreach_basic_set(__isl_keep isl_set *set,
        isl_stat (*fn)(__isl_take isl_basic_set *bset,
                void *user),
        void *user);
isl_stat isl_map_foreach_basic_map(__isl_keep isl_map *map,
        isl_stat (*fn)(__isl_take isl_basic_map *bmap,
                void *user),
        void *user);</code></pre>

<p>The callback function <code>fn</code> should return <code>isl_stat_ok</code> if successful and <code>isl_stat_error</code> if an error occurs. In the latter case, or if any other error occurs, the above functions will return <code>isl_stat_error</code>.</p>

<p>It should be noted that <code>isl</code> does not guarantee that the basic sets or maps passed to <code>fn</code> are disjoint. If this is required, then the user should call one of the following functions first.</p>

<pre><code>__isl_give isl_set *isl_set_make_disjoint(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_make_disjoint(
        __isl_take isl_map *map);</code></pre>

<p>The number of basic sets in a set can be obtained or the number of basic maps in a map can be obtained from</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_size isl_set_n_basic_set(__isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
isl_size isl_map_n_basic_map(__isl_keep isl_map *map);</code></pre>

<p>It is also possible to obtain a list of (basic) sets from a set or union set, a list of basic maps from a map and a list of maps from a union map.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set_list *isl_set_get_basic_set_list(
        __isl_keep isl_set *set);

#include &lt;isl/union_set.h&gt;
__isl_give isl_basic_set_list *
isl_union_set_get_basic_set_list(
        __isl_keep isl_union_set *uset);
__isl_give isl_set_list *isl_union_set_get_set_list(
        __isl_keep isl_union_set *uset);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map_list *isl_map_get_basic_map_list(
        __isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_map_list *isl_union_map_get_map_list(
        __isl_keep isl_union_map *umap);</code></pre>

<p>The returned list can be manipulated using the functions in <a href="#Lists">&quot;Lists&quot;</a>.</p>

<p>To iterate over the constraints of a basic set or map, use</p>

<pre><code>#include &lt;isl/constraint.h&gt;

isl_size isl_basic_set_n_constraint(
        __isl_keep isl_basic_set *bset);
isl_stat isl_basic_set_foreach_constraint(
        __isl_keep isl_basic_set *bset,
        isl_stat (*fn)(__isl_take isl_constraint *c,
                void *user),
        void *user);
isl_size isl_basic_map_n_constraint(
        __isl_keep isl_basic_map *bmap);
isl_stat isl_basic_map_foreach_constraint(
        __isl_keep isl_basic_map *bmap,
        isl_stat (*fn)(__isl_take isl_constraint *c,
                void *user),
        void *user);
__isl_null isl_constraint *isl_constraint_free(
        __isl_take isl_constraint *c);</code></pre>

<p>Again, the callback function <code>fn</code> should return <code>isl_stat_ok</code> if successful and <code>isl_stat_error</code> if an error occurs. In the latter case, or if any other error occurs, the above functions will return <code>isl_stat_error</code>. The constraint <code>c</code> represents either an equality or an inequality. Use the following function to find out whether a constraint represents an equality. If not, it represents an inequality.</p>

<pre><code>isl_bool isl_constraint_is_equality(
        __isl_keep isl_constraint *constraint);</code></pre>

<p>It is also possible to obtain a list of constraints from a basic map or set</p>

<pre><code>#include &lt;isl/constraint.h&gt;
__isl_give isl_constraint_list *
isl_basic_map_get_constraint_list(
        __isl_keep isl_basic_map *bmap);
__isl_give isl_constraint_list *
isl_basic_set_get_constraint_list(
        __isl_keep isl_basic_set *bset);</code></pre>

<p>These functions require that all existentially quantified variables have an explicit representation. The returned list can be manipulated using the functions in <a href="#Lists">&quot;Lists&quot;</a>.</p>

<p>The coefficients of the constraints can be inspected using the following functions.</p>

<pre><code>isl_bool isl_constraint_is_lower_bound(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_constraint_is_upper_bound(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_val *isl_constraint_get_constant_val(
        __isl_keep isl_constraint *constraint);
__isl_give isl_val *isl_constraint_get_coefficient_val(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, int pos);</code></pre>

<p>The explicit representations of the existentially quantified variables can be inspected using the following function. Note that the user is only allowed to use this function if the inspected set or map is the result of a call to <code>isl_set_compute_divs</code> or <code>isl_map_compute_divs</code>. The existentially quantified variable is equal to the floor of the returned affine expression. The affine expression itself can be inspected using the functions in <a href="#Functions">&quot;Functions&quot;</a>.</p>

<pre><code>__isl_give isl_aff *isl_constraint_get_div(
        __isl_keep isl_constraint *constraint, int pos);</code></pre>

<p>To obtain the constraints of a basic set or map in matrix form, use the following functions.</p>

<pre><code>__isl_give isl_mat *isl_basic_set_equalities_matrix(
        __isl_keep isl_basic_set *bset,
        enum isl_dim_type c1, enum isl_dim_type c2,
        enum isl_dim_type c3, enum isl_dim_type c4);
__isl_give isl_mat *isl_basic_set_inequalities_matrix(
        __isl_keep isl_basic_set *bset,
        enum isl_dim_type c1, enum isl_dim_type c2,
        enum isl_dim_type c3, enum isl_dim_type c4);
__isl_give isl_mat *isl_basic_map_equalities_matrix(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type c1,
        enum isl_dim_type c2, enum isl_dim_type c3,
        enum isl_dim_type c4, enum isl_dim_type c5);
__isl_give isl_mat *isl_basic_map_inequalities_matrix(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type c1,
        enum isl_dim_type c2, enum isl_dim_type c3,
        enum isl_dim_type c4, enum isl_dim_type c5);</code></pre>

<p>The <code>isl_dim_type</code> arguments dictate the order in which different kinds of variables appear in the resulting matrix. For set inputs, they should be a permutation of <code>isl_dim_cst</code> (the constant term), <code>isl_dim_param</code>, <code>isl_dim_set</code> and <code>isl_dim_div</code>. For map inputs, they should be a permutation of <code>isl_dim_cst</code>, <code>isl_dim_param</code>, <code>isl_dim_in</code>, <code>isl_dim_out</code> and <code>isl_dim_div</code>.</p>

<h2 id="Points">Points</h2>

<p>Points are elements of a set. They can be used to construct simple sets (boxes) or they can be used to represent the individual elements of a set. The zero point (the origin) can be created using</p>

<pre><code>__isl_give isl_point *isl_point_zero(__isl_take isl_space *space);</code></pre>

<p>The coordinates of a point can be inspected, set and changed using</p>

<pre><code>#include &lt;isl/point.h&gt;
__isl_give isl_multi_val *isl_point_get_multi_val(
        __isl_keep isl_point *pnt);
__isl_give isl_val *isl_point_get_coordinate_val(
        __isl_keep isl_point *pnt,
        enum isl_dim_type type, int pos);
__isl_give isl_point *isl_point_set_coordinate_val(
        __isl_take isl_point *pnt,
        enum isl_dim_type type, int pos,
        __isl_take isl_val *v);

__isl_give isl_point *isl_point_add_ui(
        __isl_take isl_point *pnt,
        enum isl_dim_type type, int pos, unsigned val);
__isl_give isl_point *isl_point_sub_ui(
        __isl_take isl_point *pnt,
        enum isl_dim_type type, int pos, unsigned val);</code></pre>

<p>Points can be copied or freed using</p>

<pre><code>__isl_give isl_point *isl_point_copy(
        __isl_keep isl_point *pnt);
__isl_null isl_point *isl_point_free(
        __isl_take isl_point *pnt);</code></pre>

<p>A singleton set can be created from a point using the following functions.</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_from_point(
        __isl_take isl_point *pnt);
__isl_give isl_set *isl_point_to_set(
        __isl_take isl_point *pnt);
__isl_give isl_set *isl_set_from_point(
        __isl_take isl_point *pnt);
__isl_give isl_union_set *isl_union_set_from_point(
        __isl_take isl_point *pnt);</code></pre>

<p><code>isl_point_to_set</code> and <code>isl_set_from_point</code> perform the same operation.</p>

<p>A box can be created from two opposite extremal points using</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_box_from_points(
        __isl_take isl_point *pnt1,
        __isl_take isl_point *pnt2);
__isl_give isl_set *isl_set_box_from_points(
        __isl_take isl_point *pnt1,
        __isl_take isl_point *pnt2);</code></pre>

<p>All elements of a <b>bounded</b> (union) set can be enumerated using the following functions.</p>

<pre><code>isl_stat isl_set_foreach_point(__isl_keep isl_set *set,
        isl_stat (*fn)(__isl_take isl_point *pnt,
                void *user),
        void *user);
isl_stat isl_union_set_foreach_point(
        __isl_keep isl_union_set *uset,
        isl_stat (*fn)(__isl_take isl_point *pnt,
                void *user),
        void *user);</code></pre>

<p>The function <code>fn</code> is called for each integer point in <code>set</code> with as second argument the last argument of the <code>isl_set_foreach_point</code> call. The function <code>fn</code> should return <code>isl_stat_ok</code> on success and <code>isl_stat_error</code> on failure. In the latter case, <code>isl_set_foreach_point</code> will stop enumerating and return <code>isl_stat_error</code> as well. If the enumeration is performed successfully and to completion, then <code>isl_set_foreach_point</code> returns <code>isl_stat_ok</code>.</p>

<p>To obtain a single point of a (basic or union) set, use</p>

<pre><code>__isl_give isl_point *isl_basic_set_sample_point(
        __isl_take isl_basic_set *bset);
__isl_give isl_point *isl_set_sample_point(
        __isl_take isl_set *set);
__isl_give isl_point *isl_union_set_sample_point(
        __isl_take isl_union_set *uset);</code></pre>

<p>If <code>set</code> does not contain any (integer) points, then the resulting point will be ``void&#39;&#39;, a property that can be tested using</p>

<pre><code>isl_bool isl_point_is_void(__isl_keep isl_point *pnt);</code></pre>

<h2 id="Functions">Functions</h2>

<p>Besides sets and relation, <code>isl</code> also supports various types of functions. Each of these types is derived from the value type (see <a href="#Values">&quot;Values&quot;</a>) or from one of two primitive function types through the application of zero or more type constructors. As a special case, a multiple expression can also be derived from an identifier (see <a href="#Identifiers">&quot;Identifiers&quot;</a>) although the result is not really a function. We first describe the primitive type and then we describe the types derived from these primitive types.</p>

<h3 id="Primitive-Functions">Primitive Functions</h3>

<p><code>isl</code> support two primitive function types, quasi-affine expressions and quasipolynomials. A quasi-affine expression is defined either over a parameter space or over a set and is composed of integer constants, parameters and set variables, addition, subtraction and integer division by an integer constant. For example, the quasi-affine expression</p>

<pre><code>[n] -&gt; { [x] -&gt; [2*floor((4 n + x)/9)] }</code></pre>

<p>maps <code>x</code> to <code>2*floor((4 n + x)/9</code>. A quasipolynomial is a polynomial expression in quasi-affine expression. That is, it additionally allows for multiplication. Note, though, that it is not allowed to construct an integer division of an expression involving multiplications. Here is an example of a quasipolynomial that is not quasi-affine expression</p>

<pre><code>[n] -&gt; { [x] -&gt; (n*floor((4 n + x)/9)) }</code></pre>

<p>Note that the external representations of quasi-affine expressions and quasipolynomials are different. Quasi-affine expressions use a notation with square brackets just like binary relations, while quasipolynomials do not. This might change at some point.</p>

<p>If a primitive function is defined over a parameter space, then the space of the function itself is that of a set. If it is defined over a set, then the space of the function is that of a relation. In both cases, the set space (or the output space) is single-dimensional, anonymous and unstructured. To create functions with multiple dimensions or with other kinds of set or output spaces, use multiple expressions (see <a href="#Multiple-Expressions">&quot;Multiple Expressions&quot;</a>).</p>

<ul>

<li><p>Quasi-affine Expressions</p>

<p>Besides the expressions described above, a quasi-affine expression can also be set to NaN. Such expressions typically represent a failure to represent a result as a quasi-affine expression.</p>

<p>The zero quasi affine expression or the quasi affine expression that is equal to a given value, parameter or a specified dimension on a given domain can be created using</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_zero_on_domain_space(
        __isl_take isl_space *space);
__isl_give isl_aff *isl_space_zero_aff_on_domain(
        __isl_take isl_space *space);
__isl_give isl_aff *isl_aff_zero_on_domain(
        __isl_take isl_local_space *ls);
__isl_give isl_aff *isl_aff_val_on_domain_space(
        __isl_take isl_space *space,
        __isl_take isl_val *val);
__isl_give isl_aff *isl_aff_val_on_domain(
        __isl_take isl_local_space *ls,
        __isl_take isl_val *val);
__isl_give isl_aff *isl_aff_param_on_domain_space_id(
        __isl_take isl_space *space,
        __isl_take isl_id *id);
__isl_give isl_aff *isl_space_param_aff_on_domain_id(
        __isl_take isl_space *space,
        __isl_take isl_id *id);
__isl_give isl_aff *isl_aff_var_on_domain(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_aff *isl_aff_nan_on_domain_space(
        __isl_take isl_space *space);
__isl_give isl_aff *isl_aff_nan_on_domain(
        __isl_take isl_local_space *ls);</code></pre>

<p>The space passed to <code>isl_aff_param_on_domain_space_id</code> is required to have a parameter with the given identifier. <code>isl_aff_param_on_domain_space_id</code> and <code>isl_space_param_aff_on_domain_id</code> perform the same operation.</p>

<p><code>isl_aff_zero_on_domain_space</code> and <code>isl_space_zero_aff_on_domain</code> perform the same operation.</p>

<p>Quasi affine expressions can be copied and freed using</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_copy(
        __isl_keep isl_aff *aff);
__isl_null isl_aff *isl_aff_free(
        __isl_take isl_aff *aff);</code></pre>

<p>A (rational) bound on a dimension can be extracted from an <code>isl_constraint</code> using the following function. The constraint is required to have a non-zero coefficient for the specified dimension.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
__isl_give isl_aff *isl_constraint_get_bound(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, int pos);</code></pre>

<p>The entire affine expression of the constraint can also be extracted using the following function.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
__isl_give isl_aff *isl_constraint_get_aff(
        __isl_keep isl_constraint *constraint);</code></pre>

<p>Conversely, an equality constraint equating the affine expression to zero or an inequality constraint enforcing the affine expression to be non-negative, can be constructed using</p>

<pre><code>__isl_give isl_constraint *isl_equality_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_constraint *isl_inequality_from_aff(
        __isl_take isl_aff *aff);</code></pre>

<p>The coefficients and the integer divisions of an affine expression can be inspected using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_val *isl_aff_get_constant_val(
        __isl_keep isl_aff *aff);
__isl_give isl_val *isl_aff_get_coefficient_val(
        __isl_keep isl_aff *aff,
        enum isl_dim_type type, int pos);
int isl_aff_coefficient_sgn(__isl_keep isl_aff *aff,
        enum isl_dim_type type, int pos);
__isl_give isl_val *isl_aff_get_denominator_val(
        __isl_keep isl_aff *aff);
__isl_give isl_aff *isl_aff_get_div(
        __isl_keep isl_aff *aff, int pos);</code></pre>

<p>They can be modified using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_set_constant_si(
        __isl_take isl_aff *aff, int v);
__isl_give isl_aff *isl_aff_set_constant_val(
        __isl_take isl_aff *aff, __isl_take isl_val *v);
__isl_give isl_aff *isl_aff_set_coefficient_si(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, int pos, int v);
__isl_give isl_aff *isl_aff_set_coefficient_val(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, int pos,
        __isl_take isl_val *v);

__isl_give isl_aff *isl_aff_add_constant_si(
        __isl_take isl_aff *aff, int v);
__isl_give isl_aff *isl_aff_add_constant_val(
        __isl_take isl_aff *aff, __isl_take isl_val *v);
__isl_give isl_aff *isl_aff_add_constant_num_si(
        __isl_take isl_aff *aff, int v);
__isl_give isl_aff *isl_aff_add_coefficient_si(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, int pos, int v);
__isl_give isl_aff *isl_aff_add_coefficient_val(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, int pos,
        __isl_take isl_val *v);</code></pre>

<p>Note that <code>isl_aff_set_constant_si</code> and <code>isl_aff_set_coefficient_si</code> set the <i>numerator</i> of the constant or coefficient, while <code>isl_aff_set_constant_val</code> and <code>isl_aff_set_coefficient_val</code> set the constant or coefficient as a whole. The <code>add_constant</code> and <code>add_coefficient</code> functions add an integer or rational value to the possibly rational constant or coefficient. The <code>add_constant_num</code> functions add an integer value to the numerator.</p>

</li>
<li><p>Quasipolynomials</p>

<p>Some simple quasipolynomials can be created using the following functions.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_zero_on_domain(
        __isl_take isl_space *domain);
__isl_give isl_qpolynomial *isl_qpolynomial_one_on_domain(
        __isl_take isl_space *domain);
__isl_give isl_qpolynomial *isl_qpolynomial_infty_on_domain(
        __isl_take isl_space *domain);
__isl_give isl_qpolynomial *isl_qpolynomial_neginfty_on_domain(
        __isl_take isl_space *domain);
__isl_give isl_qpolynomial *isl_qpolynomial_nan_on_domain(
        __isl_take isl_space *domain);
__isl_give isl_qpolynomial *isl_qpolynomial_val_on_domain(
        __isl_take isl_space *domain,
        __isl_take isl_val *val);
__isl_give isl_qpolynomial *isl_qpolynomial_var_on_domain(
        __isl_take isl_space *domain,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_qpolynomial *isl_qpolynomial_from_aff(
        __isl_take isl_aff *aff);</code></pre>

<p>Recall that the space in which a quasipolynomial lives is a map space with a one-dimensional range. The <code>domain</code> argument in some of the functions above corresponds to the domain of this map space.</p>

<p>A quasi-polynomial that can also be represented as a quasi-affine expression can be converted using the function below.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
isl_bool isl_qpolynomial_isa_aff(
        __isl_keep isl_qpolynomial *qp);
__isl_give isl_aff *isl_qpolynomial_as_aff(
        __isl_take isl_qpolynomial *qp);</code></pre>

<p>Quasipolynomials can be copied and freed again using the following functions.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_copy(
        __isl_keep isl_qpolynomial *qp);
__isl_null isl_qpolynomial *isl_qpolynomial_free(
        __isl_take isl_qpolynomial *qp);</code></pre>

<p>The constant term of a quasipolynomial can be extracted using</p>

<pre><code>__isl_give isl_val *isl_qpolynomial_get_constant_val(
        __isl_keep isl_qpolynomial *qp);</code></pre>

<p>To iterate over all terms in a quasipolynomial, use</p>

<pre><code>isl_stat isl_qpolynomial_foreach_term(
        __isl_keep isl_qpolynomial *qp,
        isl_stat (*fn)(__isl_take isl_term *term,
                  void *user), void *user);</code></pre>

<p>The terms themselves can be inspected and freed using these functions</p>

<pre><code>isl_size isl_term_dim(__isl_keep isl_term *term,
        enum isl_dim_type type);
__isl_give isl_val *isl_term_get_coefficient_val(
        __isl_keep isl_term *term);
isl_size isl_term_get_exp(__isl_keep isl_term *term,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_aff *isl_term_get_div(
        __isl_keep isl_term *term, unsigned pos);
__isl_null isl_term *isl_term_free(
        __isl_take isl_term *term);</code></pre>

<p>Each term is a product of parameters, set variables and integer divisions. The function <code>isl_term_get_exp</code> returns the exponent of a given dimensions in the given term.</p>

</li>
</ul>

<h3 id="Reductions">Reductions</h3>

<p>A reduction represents a maximum or a minimum of its base expressions. The only reduction type defined by <code>isl</code> is <code>isl_qpolynomial_fold</code>.</p>

<p>There are currently no functions to directly create such objects, but they do appear in the piecewise quasipolynomial reductions returned by the <code>isl_pw_qpolynomial_bound</code> function. See <a href="#Bounds-on-Piecewise-Quasipolynomials-and-Piecewise-Quasipolynomial-Reductions">&quot;Bounds on Piecewise Quasipolynomials and Piecewise Quasipolynomial Reductions&quot;</a>.</p>

<p>Reductions can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial_fold *
isl_qpolynomial_fold_copy(
        __isl_keep isl_qpolynomial_fold *fold);
__isl_null isl_qpolynomial_fold *
isl_qpolynomial_fold_free(
        __isl_take isl_qpolynomial_fold *fold);</code></pre>

<p>The type of a (union piecewise) reduction can be obtained using the following functions.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
enum isl_fold isl_qpolynomial_fold_get_type(
        __isl_keep isl_qpolynomial_fold *fold);
enum isl_fold isl_pw_qpolynomial_fold_get_type(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
enum isl_fold isl_union_pw_qpolynomial_fold_get_type(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>The type may be either <code>isl_fold_min</code> or <code>isl_fold_max</code> (or <code>isl_fold_error</code> in case of error).</p>

<p>To iterate over all quasipolynomials in a reduction, use</p>

<pre><code>isl_stat isl_qpolynomial_fold_foreach_qpolynomial(
        __isl_keep isl_qpolynomial_fold *fold,
        isl_stat (*fn)(__isl_take isl_qpolynomial *qp,
                  void *user), void *user);</code></pre>

<h3 id="Multiple-Expressions">Multiple Expressions</h3>

<p>A multiple expression represents a sequence of zero or more base expressions, all defined on the same domain space. The domain space of the multiple expression is the same as that of the base expressions, but the range space can be any space. In case the base expressions have a set space, the corresponding multiple expression also has a set space. Objects of the value or identifier type do not have an associated space. The space of a multiple value or multiple identifier is therefore always a set space. Similarly, the space of a multiple union piecewise affine expression is always a set space. If the base expressions are not total, then a corresponding zero-dimensional multiple expression may have an explicit domain that keeps track of the domain outside of any base expressions.</p>

<p>The multiple expression types defined by <code>isl</code> are <code>isl_multi_val</code>, <code>isl_multi_id</code>, <code>isl_multi_aff</code>, <code>isl_multi_pw_aff</code>, <code>isl_multi_union_pw_aff</code>.</p>

<p>A multiple expression with the value zero for each output (or set) dimension can be created using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_zero(
        __isl_take isl_space *space);
__isl_give isl_multi_val *isl_space_zero_multi_val(
        __isl_take isl_space *space);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_zero(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_space_zero_multi_aff(
        __isl_take isl_space *space);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_zero(
        __isl_take isl_space *space);
__isl_give isl_multi_pw_aff *isl_space_zero_multi_pw_aff(
        __isl_take isl_space *space);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_zero(
        __isl_take isl_space *space);
__isl_give isl_multi_union_pw_aff *
isl_space_zero_multi_union_pw_aff(
        __isl_take isl_space *space);</code></pre>

<p>Since there is no canonical way of representing a zero value of type <code>isl_union_pw_aff</code>, the space passed to <code>isl_multi_union_pw_aff_zero</code> needs to be zero-dimensional. <code>isl_multi_val_zero</code> and <code>isl_space_zero_multi_val</code> perform the same operation. Similarly for the pair <code>isl_multi_aff_zero</code> and <code>isl_space_zero_multi_aff</code>, for the pair <code>isl_multi_pw_aff_zero</code> and <code>isl_space_zero_multi_pw_aff</code> and for the pair <code>isl_multi_union_pw_aff_zero</code> and <code>isl_space_zero_multi_union_pw_aff</code>.</p>

<p>An identity function can be created using the following functions. For the first group of functions, the space needs to be that of a set. For the second group, the space needs to be that of a relation with the same number of input and output dimensions. For the third group, the input function needs to live in a space with the same number of input and output dimensions and the identity function is created in that space.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *
isl_multi_aff_identity_on_domain_space(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *
isl_space_identity_multi_aff_on_domain(
        __isl_take isl_space *space);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_identity_on_domain_space(
        __isl_take isl_space *space);
__isl_give isl_multi_pw_aff *
isl_space_identity_multi_pw_aff_on_domain(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_multi_aff_identity(
        __isl_take isl_space *space);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_identity(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *
isl_multi_aff_identity_multi_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_identity_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa);</code></pre>

<p><code>isl_multi_aff_identity_on_domain_space</code> and <code>isl_space_identity_multi_aff_on_domain</code> perform the same operation. Similarly for the pair <code>isl_multi_pw_aff_identity_on_domain_space</code> and <code>isl_space_identity_multi_pw_aff_on_domain</code>.</p>

<p>A function that performs a projection on a universe relation or set can be created using the following functions. See also the corresponding projection operations in <a href="#Unary-Operations">&quot;Unary Operations&quot;</a>.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_domain_map(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_space_domain_map_multi_aff(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_multi_aff_range_map(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_space_range_map_multi_aff(
        __isl_take isl_space *space);
__isl_give isl_multi_aff *isl_multi_aff_project_out_map(
        __isl_take isl_space *space,
        enum isl_dim_type type,
        unsigned first, unsigned n);</code></pre>

<p><code>isl_multi_aff_domain_map</code> and <code>isl_space_domain_map_multi_aff</code> perform the same operation. Similarly for the pair <code>isl_multi_aff_range_map</code> and <code>isl_space_range_map_multi_aff</code>.</p>

<p>A multiple expression can be created from a single base expression using the following functions. The space of the created multiple expression is the same as that of the base expression, except for <code>isl_multi_union_pw_aff_from_union_pw_aff</code> where the input lives in a parameter space and the output lives in a single-dimensional set space.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_pw_aff(
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_union_pw_aff(
        __isl_take isl_union_pw_aff *upa);</code></pre>

<p>A multiple expression can be created from a list of base expression in a specified space. The domain of this space needs to be the same as the domains of the base expressions in the list. If the base expressions have a set space (or no associated space), then this space also needs to be a set space.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_from_id_list(
        __isl_take isl_space *space,
        __isl_take isl_id_list *list);
__isl_give isl_multi_id *isl_space_multi_id(
        __isl_take isl_space *space,
        __isl_take isl_id_list *list);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_from_val_list(
        __isl_take isl_space *space,
        __isl_take isl_val_list *list);
__isl_give isl_multi_val *isl_space_multi_val(
        __isl_take isl_space *space,
        __isl_take isl_val_list *list);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_from_aff_list(
        __isl_take isl_space *space,
        __isl_take isl_aff_list *list);
__isl_give isl_multi_aff *isl_space_multi_aff(
        __isl_take isl_space *space,
        __isl_take isl_aff_list *list);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_from_pw_aff_list(
        __isl_take isl_space *space,
        __isl_take isl_pw_aff_list *list);
__isl_give isl_multi_pw_aff *
isl_space_multi_pw_aff(
        __isl_take isl_space *space,
        __isl_take isl_pw_aff_list *list);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_union_pw_aff_list(
        __isl_take isl_space *space,
        __isl_take isl_union_pw_aff_list *list);
__isl_give isl_multi_union_pw_aff *
isl_space_multi_union_pw_aff(
        __isl_take isl_space *space,
        __isl_take isl_union_pw_aff_list *list);</code></pre>

<p><code>isl_multi_id_from_id_list</code> and <code>isl_space_multi_id</code> perform the same operation. Similarly for the pair <code>isl_multi_val_from_val_list</code> and <code>isl_space_multi_val</code>, for the pair <code>isl_multi_aff_from_aff_list</code> and <code>isl_space_multi_aff</code>, for the pair <code>isl_multi_pw_aff_from_pw_aff_list</code> and <code>isl_space_multi_pw_aff</code> and for the pair <code>isl_multi_union_pw_aff_from_union_pw_aff_list</code> and <code>isl_space_multi_union_pw_aff</code>.</p>

<p>As a convenience, a multiple piecewise expression can also be created from a multiple expression, or even directly from a single base expression. Each piecewise expression in the result has a single universe cell.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_multi_pw_aff *
isl_multi_aff_to_multi_pw_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_from_multi_aff(
        __isl_take isl_multi_aff *ma);</code></pre>

<p><code>isl_multi_aff_to_multi_pw_aff</code> and <code>isl_multi_pw_aff_from_multi_aff</code> perform the same operation.</p>

<p>Similarly, a multiple union expression can be created from a multiple expression.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_multi_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_union_pw_aff *
isl_multi_aff_to_multi_union_pw_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa);</code></pre>

<p><code>isl_multi_aff_to_multi_union_pw_aff</code> and <code>isl_multi_union_pw_aff_from_multi_aff</code> perform the same operation.</p>

<p>A multiple quasi-affine expression can be created from a multiple value with a given domain space using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *
isl_multi_aff_multi_val_on_domain_space(
        __isl_take isl_space *space,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_aff *
isl_space_multi_aff_on_domain_multi_val(
        __isl_take isl_space *space,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_aff *
isl_multi_aff_multi_val_on_space(
        __isl_take isl_space *space,
        __isl_take isl_multi_val *mv);</code></pre>

<p><code>isl_space_multi_aff_on_domain_multi_val</code> and <code>isl_multi_aff_multi_val_on_space</code> are alternative names for <code>isl_multi_aff_multi_val_on_domain_space</code>.</p>

<p>Similarly, a multiple union piecewise affine expression can be created from a multiple value with a given domain or a (piecewise) multiple affine expression with a given domain using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_multi_val_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_multi_aff_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_pw_multi_aff_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_pw_multi_aff *pma);</code></pre>

<p>Multiple expressions can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_copy(
        __isl_keep isl_multi_id *mi);
__isl_null isl_multi_id *isl_multi_id_free(
        __isl_take isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_copy(
        __isl_keep isl_multi_val *mv);
__isl_null isl_multi_val *isl_multi_val_free(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_copy(
        __isl_keep isl_multi_aff *maff);
__isl_null isl_multi_aff *isl_multi_aff_free(
        __isl_take isl_multi_aff *maff);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_copy(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_null isl_multi_pw_aff *isl_multi_pw_aff_free(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_copy(
        __isl_keep isl_multi_union_pw_aff *mupa);
__isl_null isl_multi_union_pw_aff *
isl_multi_union_pw_aff_free(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>The number of base expressions in a multiple expression can be obtained using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
int isl_multi_id_size(__isl_keep isl_multi_id *mi);

#include &lt;isl/val.h&gt;
isl_size isl_multi_val_size(__isl_keep isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
isl_size isl_multi_aff_size(
        __isl_keep isl_multi_aff *multi);
isl_size isl_multi_pw_aff_size(
        __isl_keep isl_multi_pw_aff *mpa);
isl_size isl_multi_union_pw_aff_size(
        __isl_keep isl_multi_union_pw_aff *mupa);</code></pre>

<p>The base expression at a given position of a multiple expression can be extracted using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_id *isl_multi_id_get_at(
        __isl_keep isl_multi_id *mi, int pos);
__isl_give isl_id *isl_multi_id_get_id(
        __isl_keep isl_multi_id *mi, int pos);

#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_multi_val_get_at(
        __isl_keep isl_multi_val *mv, int pos);
__isl_give isl_val *isl_multi_val_get_val(
        __isl_keep isl_multi_val *mv, int pos);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_multi_aff_get_at(
        __isl_keep isl_multi_aff *ma, int pos);
__isl_give isl_aff *isl_multi_aff_get_aff(
        __isl_keep isl_multi_aff *multi, int pos);
__isl_give isl_pw_aff *isl_multi_pw_aff_get_at(
        __isl_keep isl_multi_pw_aff *mpa, int pos);
__isl_give isl_pw_aff *isl_multi_pw_aff_get_pw_aff(
        __isl_keep isl_multi_pw_aff *mpa, int pos);
__isl_give isl_union_pw_aff *
isl_multi_union_pw_aff_get_at(
        __isl_keep isl_multi_union_pw_aff *mupa, int pos);
__isl_give isl_union_pw_aff *
isl_multi_union_pw_aff_get_union_pw_aff(
        __isl_keep isl_multi_union_pw_aff *mupa, int pos);</code></pre>

<p><code>isl_multi_id_get_id</code> is an alternative name for <code>isl_multi_id_get_at</code>. Similarly for the other pairs of functions.</p>

<p>The base expression can be replaced using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_set_at(
        __isl_take isl_multi_id *mi, int pos,
        __isl_take isl_id *id);
__isl_give isl_multi_id *isl_multi_id_set_id(
        __isl_take isl_multi_id *mi, int pos,
        __isl_take isl_id *id);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_set_at(
        __isl_take isl_multi_val *mv, int pos,
        __isl_take isl_val *val);
__isl_give isl_multi_val *isl_multi_val_set_val(
        __isl_take isl_multi_val *mv, int pos,
        __isl_take isl_val *val);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_set_at(
        __isl_take isl_multi_aff *ma, int pos,
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *isl_multi_aff_set_aff(
        __isl_take isl_multi_aff *multi, int pos,
        __isl_take isl_aff *aff);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_set_at(
        __isl_take isl_multi_pw_aff *mpa, int pos,
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_set_pw_aff(
        __isl_take isl_multi_pw_aff *mpa, int pos,
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_at(
        __isl_take isl_multi_union_pw_aff *mupa, int pos,
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_set_union_pw_aff(
        __isl_take isl_multi_union_pw_aff *mupa, int pos,
        __isl_take isl_union_pw_aff *upa);</code></pre>

<p><code>isl_multi_id_set_id</code> is an alternative name for <code>isl_multi_id_set_at</code>. Similarly for the other pairs of functions.</p>

<p>A list of all base expressions of a multiple expression can be extracted using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_id_list *isl_multi_id_get_list(
        __isl_keep isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_val_list *isl_multi_val_get_list(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff_list *isl_multi_aff_get_list(
        __isl_keep isl_multi_aff *multi);
__isl_give isl_pw_aff_list *isl_multi_pw_aff_get_list(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_union_pw_aff_list *
isl_multi_union_pw_aff_list(
        __isl_keep isl_multi_union_pw_aff *mupa);</code></pre>

<p>The constant terms of the base expressions can be obtained using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_val *
isl_multi_aff_get_constant_multi_val(
        __isl_keep isl_multi_aff *ma);</code></pre>

<p>As a convenience, a sequence of base expressions that have their domains in a given space can be extracted from a sequence of union expressions using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_pw_aff *
isl_multi_union_pw_aff_extract_multi_pw_aff(
        __isl_keep isl_multi_union_pw_aff *mupa,
        __isl_take isl_space *space);</code></pre>

<p>Note that there is a difference between <code>isl_multi_union_pw_aff</code> and <code>isl_union_pw_multi_aff</code> objects. The first is a sequence of unions of piecewise expressions, while the second is a union of piecewise sequences. In particular, multiple affine expressions in an <code>isl_union_pw_multi_aff</code> may live in different spaces, while there is only a single multiple expression in an <code>isl_multi_union_pw_aff</code>, which can therefore only live in a single space. This means that not every <code>isl_union_pw_multi_aff</code> can be converted to an <code>isl_multi_union_pw_aff</code>. Conversely, the elements of an <code>isl_multi_union_pw_aff</code> may be defined over different domains, while each multiple expression inside an <code>isl_union_pw_multi_aff</code> has a single domain. The conversion of an <code>isl_union_pw_multi_aff</code> of dimension greater than one may therefore not be exact. The following functions can be used to perform these conversions when they are possible.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_multi_union_pw_aff *
isl_union_pw_multi_aff_as_multi_union_pw_aff(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_union_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_multi_union_pw_aff(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p><code>isl_union_pw_multi_aff_as_multi_union_pw_aff</code> and <code>isl_multi_union_pw_aff_from_union_pw_multi_aff</code> perform the same operation.</p>

<h3 id="Piecewise-Expressions">Piecewise Expressions</h3>

<p>A piecewise expression is an expression that is described using zero or more base expression defined over the same number of cells in the domain space of the base expressions. All base expressions are defined over the same domain space and the cells are disjoint. The space of a piecewise expression is the same as that of the base expressions. If the union of the cells is a strict subset of the domain space, then the value of the piecewise expression outside this union is different for types derived from quasi-affine expressions and those derived from quasipolynomials. Piecewise expressions derived from quasi-affine expressions are considered to be undefined outside the union of their cells. Piecewise expressions derived from quasipolynomials are considered to be zero outside the union of their cells.</p>

<p>Piecewise quasipolynomials are mainly used by the <code>barvinok</code> library for representing the number of elements in a parametric set or map. For example, the piecewise quasipolynomial</p>

<pre><code>[n] -&gt; { [x] -&gt; ((1 + n) - x) : x &lt;= n and x &gt;= 0 }</code></pre>

<p>represents the number of points in the map</p>

<pre><code>[n] -&gt; { [x] -&gt; [y] : x,y &gt;= 0 and 0 &lt;= x + y &lt;= n }</code></pre>

<p>The piecewise expression types defined by <code>isl</code> are <code>isl_pw_aff</code>, <code>isl_pw_multi_aff</code>, <code>isl_pw_qpolynomial</code> and <code>isl_pw_qpolynomial_fold</code>.</p>

<p>A piecewise expression with no cells can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_empty(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_empty(
        __isl_take isl_space *space);</code></pre>

<p>A piecewise expression with a single universe cell can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_pw_multi_aff *
isl_multi_aff_to_pw_multi_aff(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_from_multi_aff(
        __isl_take isl_multi_aff *ma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_from_qpolynomial(
        __isl_take isl_qpolynomial *qp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_from_qpolynomial_fold(
        __isl_take isl_qpolynomial_fold *fold);</code></pre>

<p><code>isl_multi_aff_to_pw_multi_aff</code> and <code>isl_pw_multi_aff_from_multi_aff</code> perform the same operation.</p>

<p>The inverse conversions below can only be used if the input expression is known to be defined over a single universe domain.</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_bool isl_pw_aff_isa_aff(__isl_keep isl_pw_aff *pa);
__isl_give isl_aff *isl_pw_aff_as_aff(
        __isl_take isl_pw_aff *pa);
isl_bool isl_multi_pw_aff_isa_multi_aff(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_multi_aff *isl_multi_pw_aff_as_multi_aff(
        __isl_take isl_multi_pw_aff *mpa);
isl_bool isl_pw_multi_aff_isa_multi_aff(
        __isl_keep isl_pw_multi_aff *pma);
__isl_give isl_multi_aff *isl_pw_multi_aff_as_multi_aff(
        __isl_take isl_pw_multi_aff *pma);

#include &lt;isl/polynomial.h&gt;
isl_bool isl_pw_qpolynomial_isa_qpolynomial(
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_give isl_qpolynomial *
isl_pw_qpolynomial_as_qpolynomial(
        __isl_take isl_pw_qpolynomial *pwqp);
isl_bool isl_pw_qpolynomial_fold_isa_qpolynomial_fold(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
__isl_give isl_qpolynomial_fold *
isl_pw_qpolynomial_fold_as_qpolynomial_fold(
        __isl_take isl_pw_qpolynomial_fold *pwf);</code></pre>

<p>A piecewise expression with a single specified cell can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_alloc(
        __isl_take isl_set *set, __isl_take isl_aff *aff);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_alloc(
        __isl_take isl_set *set,
        __isl_take isl_multi_aff *maff);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_alloc(
        __isl_take isl_set *set,
        __isl_take isl_qpolynomial *qp);</code></pre>

<p>The following convenience functions first create a base expression and then create a piecewise expression over a universe domain.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_zero_on_domain(
        __isl_take isl_local_space *ls);
__isl_give isl_pw_aff *isl_pw_aff_var_on_domain(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_pw_aff *isl_pw_aff_nan_on_domain_space(
        __isl_take isl_space *space);
__isl_give isl_pw_aff *isl_pw_aff_nan_on_domain(
        __isl_take isl_local_space *ls);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_zero(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_identity_on_domain_space(
        __isl_take isl_space *space)
__isl_give isl_pw_multi_aff *
isl_space_identity_pw_multi_aff_on_domain(
        __isl_take isl_space *space)
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_identity(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_domain_map(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *
isl_space_domain_map_pw_multi_aff(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_range_map(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *
isl_space_range_map_pw_multi_aff(
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_project_out_map(
        __isl_take isl_space *space,
        enum isl_dim_type type,
        unsigned first, unsigned n);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_zero(
        __isl_take isl_space *space);</code></pre>

<p><code>isl_pw_multi_aff_identity_on_domain_space</code> and <code>isl_space_identity_pw_multi_aff_on_domain</code> perform the same operation. Similarly for the pair <code>isl_pw_multi_aff_domain_map</code> and <code>isl_space_domain_map_pw_multi_aff</code> and for the pair <code>isl_pw_multi_aff_range_map</code> and <code>isl_space_range_map_pw_multi_aff</code>.</p>

<p>The following convenience functions first create a base expression and then create a piecewise expression over a given domain.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_val_on_domain(
        __isl_take isl_set *domain,
        __isl_take isl_val *v);
__isl_give isl_pw_aff *isl_set_pw_aff_on_domain_val(
        __isl_take isl_set *domain,
        __isl_take isl_val *v);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_multi_val_on_domain(
        __isl_take isl_set *domain,
        __isl_take isl_multi_val *mv);
__isl_give isl_pw_multi_aff *
isl_set_pw_multi_aff_on_domain_multi_val(
        __isl_take isl_set *domain,
        __isl_take isl_multi_val *mv);
__isl_give isl_pw_aff *isl_pw_aff_param_on_domain_id(
        __isl_take isl_set *domain,
        __isl_take isl_id *id);
__isl_give isl_pw_aff *isl_set_param_pw_aff_on_domain_id(
        __isl_take isl_set *domain,
        __isl_take isl_id *id);</code></pre>

<p><code>isl_set_pw_aff_on_domain_val</code> is an alternative name for <code>isl_pw_aff_val_on_domain</code>. Similarly for the pair <code>isl_set_pw_multi_aff_on_domain_multi_val</code> and <code>isl_pw_multi_aff_multi_val_on_domain</code> and for the pair <code>isl_set_param_pw_aff_on_domain_id</code> and <code>isl_pw_aff_param_on_domain_id</code>.</p>

<p>As a convenience, a piecewise multiple expression can also be created from a piecewise expression. Each multiple expression in the result is derived from the corresponding base expression.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_pw_aff(
        __isl_take isl_pw_aff *pa);</code></pre>

<p>Similarly, a piecewise quasipolynomial can be created from a piecewise quasi-affine expression using the following function.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_from_pw_aff(
        __isl_take isl_pw_aff *pwaff);</code></pre>

<p>Piecewise expressions can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_copy(
        __isl_keep isl_pw_aff *pwaff);
__isl_null isl_pw_aff *isl_pw_aff_free(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_copy(
        __isl_keep isl_pw_multi_aff *pma);
__isl_null isl_pw_multi_aff *isl_pw_multi_aff_free(
        __isl_take isl_pw_multi_aff *pma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_copy(
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_null isl_pw_qpolynomial *isl_pw_qpolynomial_free(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_copy(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
__isl_null isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_free(
        __isl_take isl_pw_qpolynomial_fold *pwf);</code></pre>

<p>To iterate over the different cells of a piecewise expression, use the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_bool isl_pw_aff_is_empty(__isl_keep isl_pw_aff *pwaff);
isl_size isl_pw_aff_n_piece(__isl_keep isl_pw_aff *pwaff);
isl_stat isl_pw_aff_foreach_piece(
        __isl_keep isl_pw_aff *pwaff,
        isl_stat (*fn)(__isl_take isl_set *set,
                  __isl_take isl_aff *aff,
                  void *user), void *user);
isl_bool isl_pw_aff_every_piece(__isl_keep isl_pw_aff *pa,
        isl_bool (*test)(__isl_keep isl_set *set,
                __isl_keep isl_aff *aff, void *user),
                void *user);
isl_size isl_pw_multi_aff_n_piece(
        __isl_keep isl_pw_multi_aff *pma);
isl_stat isl_pw_multi_aff_foreach_piece(
        __isl_keep isl_pw_multi_aff *pma,
        isl_stat (*fn)(__isl_take isl_set *set,
                    __isl_take isl_multi_aff *maff,
                    void *user), void *user);
isl_bool isl_pw_multi_aff_every_piece(
        __isl_keep isl_pw_multi_aff *pma,
        isl_bool (*test)(__isl_keep isl_set *set,
                __isl_keep isl_multi_aff *ma, void *user),
                void *user);

#include &lt;isl/polynomial.h&gt;
isl_size isl_pw_qpolynomial_n_piece(
        __isl_keep isl_pw_qpolynomial *pwqp);
isl_stat isl_pw_qpolynomial_foreach_piece(
        __isl_keep isl_pw_qpolynomial *pwqp,
        isl_stat (*fn)(__isl_take isl_set *set,
                  __isl_take isl_qpolynomial *qp,
                  void *user), void *user);
isl_bool isl_pw_qpolynomial_every_piece(
        __isl_keep isl_pw_qpolynomial *pwqp,
        isl_bool (*test)(__isl_keep isl_set *set,
                __isl_keep isl_qpolynomial *qp,
                void *user), void *user);
isl_stat isl_pw_qpolynomial_foreach_lifted_piece(
        __isl_keep isl_pw_qpolynomial *pwqp,
        isl_stat (*fn)(__isl_take isl_set *set,
                  __isl_take isl_qpolynomial *qp,
                  void *user), void *user);
isl_size isl_pw_qpolynomial_fold_n_piece(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
isl_stat isl_pw_qpolynomial_fold_foreach_piece(
        __isl_keep isl_pw_qpolynomial_fold *pwf,
        isl_stat (*fn)(__isl_take isl_set *set,
                  __isl_take isl_qpolynomial_fold *fold,
                  void *user), void *user);
isl_bool isl_pw_qpolynomial_fold_every_piece(
        __isl_keep isl_pw_qpolynomial_fold *pwf,
        isl_bool (*test)(__isl_keep isl_set *set,
                __isl_keep isl_qpolynomial_fold *fold,
                void *user), void *user);
isl_stat isl_pw_qpolynomial_fold_foreach_lifted_piece(
        __isl_keep isl_pw_qpolynomial_fold *pwf,
        isl_stat (*fn)(__isl_take isl_set *set,
                  __isl_take isl_qpolynomial_fold *fold,
                  void *user), void *user);</code></pre>

<p>As usual, the function <code>fn</code> should return <code>isl_stat_ok</code> on success and <code>isl_stat_error</code> on failure. The difference between <code>isl_pw_qpolynomial_foreach_piece</code> and <code>isl_pw_qpolynomial_foreach_lifted_piece</code> is that <code>isl_pw_qpolynomial_foreach_lifted_piece</code> will first compute unique representations for all existentially quantified variables and then turn these existentially quantified variables into extra set variables, adapting the associated quasipolynomial accordingly. This means that the <code>set</code> passed to <code>fn</code> will not have any existentially quantified variables, but that the dimensions of the sets may be different for different invocations of <code>fn</code>. Similarly for <code>isl_pw_qpolynomial_fold_foreach_piece</code> and <code>isl_pw_qpolynomial_fold_foreach_lifted_piece</code>. The function <code>isl_pw_aff_every_piece</code> and its variants check whether each call to the callback returns true and stop checking as soon as one of these calls returns false (or error).</p>

<p>A piecewise expression consisting of the expressions at a given position of a piecewise multiple expression can be extracted using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_multi_aff_get_at(
        __isl_keep isl_pw_multi_aff *pma, int pos);
__isl_give isl_pw_aff *isl_pw_multi_aff_get_pw_aff(
        __isl_keep isl_pw_multi_aff *pma, int pos);</code></pre>

<p><code>isl_pw_multi_aff_get_pw_aff</code> is an alternative name for <code>isl_pw_multi_aff_get_at</code>.</p>

<p>These expressions can be replaced using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_set_pw_aff(
        __isl_take isl_pw_multi_aff *pma, unsigned pos,
        __isl_take isl_pw_aff *pa);</code></pre>

<p>Note that there is a difference between <code>isl_multi_pw_aff</code> and <code>isl_pw_multi_aff</code> objects. The first is a sequence of piecewise affine expressions, while the second is a piecewise sequence of affine expressions. In particular, each of the piecewise affine expressions in an <code>isl_multi_pw_aff</code> may have a different domain, while all multiple expressions associated to a cell in an <code>isl_pw_multi_aff</code> have the same domain. It is possible to convert between the two, but when converting an <code>isl_multi_pw_aff</code> to an <code>isl_pw_multi_aff</code>, the domain of the result is the intersection of the domains of the input. The reverse conversion is exact.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_from_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_pw_aff *
isl_pw_multi_aff_to_multi_pw_aff(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_from_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma);</code></pre>

<p><code>isl_pw_multi_aff_to_multi_pw_aff</code> and <code>isl_multi_pw_aff_from_pw_multi_aff</code> perform the same operation.</p>

<h3 id="Union-Expressions">Union Expressions</h3>

<p>A union expression collects base expressions defined over different domains. The space of a union expression is that of the shared parameter space.</p>

<p>The union expression types defined by <code>isl</code> are <code>isl_union_pw_aff</code>, <code>isl_union_pw_multi_aff</code>, <code>isl_union_pw_qpolynomial</code> and <code>isl_union_pw_qpolynomial_fold</code>. In case of <code>isl_union_pw_aff</code>, <code>isl_union_pw_qpolynomial</code> and <code>isl_union_pw_qpolynomial_fold</code>, there can be at most one base expression for a given domain space. In case of <code>isl_union_pw_multi_aff</code>, there can be multiple such expressions for a given domain space, but the domains of these expressions need to be disjoint.</p>

<p>An empty union expression can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *
isl_union_pw_aff_empty_ctx(
        isl_ctx *ctx);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_empty_space(
        __isl_take isl_space *space);
__isl_give isl_union_pw_aff *isl_union_pw_aff_empty(
        __isl_take isl_space *space);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_empty_ctx(
        isl_ctx *ctx);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_empty_space(
        __isl_take isl_space *space);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_empty(
        __isl_take isl_space *space);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_zero_ctx(
        isl_ctx *ctx);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_zero_space(
        __isl_take isl_space *space);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_zero(
        __isl_take isl_space *space);</code></pre>

<p><code>isl_union_pw_aff_empty</code> is an alternative name for <code>isl_union_pw_aff_empty_space</code>. Similarly for the other pairs of functions.</p>

<p>A union expression containing a single base expression can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *
isl_pw_aff_to_union_pw_aff(
        __isl_take isl_pw_aff *pa);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_from_pw_aff(
        __isl_take isl_pw_aff *pa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_union_pw_multi_aff *
isl_pw_multi_aff_to_union_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_pw_qpolynomial_to_union_pw_qpolynomial(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_from_pw_qpolynomial(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_to_union_pw_qpolynomial_fold(
        __isl_take isl_pw_qpolynomial_fold *pwf);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold(
        __isl_take isl_pw_qpolynomial_fold *pwf);</code></pre>

<p><code>isl_pw_aff_to_union_pw_aff</code> and <code>isl_union_pw_aff_from_pw_aff</code> perform the same operation. Similarly for <code>isl_pw_multi_aff_to_union_pw_multi_aff</code> and <code>isl_union_pw_multi_aff_from_pw_multi_aff</code>, for <code>isl_pw_qpolynomial_to_union_pw_qpolynomial</code> and <code>isl_union_pw_qpolynomial_from_pw_qpolynomial</code>, and for <code>isl_pw_qpolynomial_fold_to_union_pw_qpolynomial_fold</code> and <code>isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold</code>.</p>

<p>The inverse conversions below can only be used if the input expression is known to live in exactly one space.</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_bool isl_union_pw_multi_aff_isa_pw_multi_aff(
        __isl_keep isl_union_pw_multi_aff *upma);
__isl_give isl_pw_multi_aff *
isl_union_pw_multi_aff_as_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma);</code></pre>

<p>A union piecewise expression containing a single base expression on a universe domain can also be created directly from a base expression using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *isl_union_pw_aff_from_aff(
        __isl_take isl_aff *aff);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_multi_aff(
        __isl_take isl_multi_aff *ma);</code></pre>

<p>The following functions create a base expression on each of the sets in the union set and collect the results.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_union_pw_aff(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_pw_aff *
isl_union_pw_multi_aff_get_union_pw_aff(
        __isl_keep isl_union_pw_multi_aff *upma, int pos);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_val_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_val *v);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_multi_val_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_multi_val *mv);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_param_on_domain_id(
        __isl_take isl_union_set *domain,
        __isl_take isl_id *id);</code></pre>

<p>The <code>id</code> argument of <code>isl_union_pw_aff_param_on_domain_id</code> is the identifier of a parameter that may or may not already be present in <code>domain</code>.</p>

<p>An <code>isl_union_pw_aff</code> that is equal to a (parametric) affine or piecewise affine expression on a given domain can be created using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *
isl_union_pw_aff_aff_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_aff *aff);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_pw_aff_on_domain(
        __isl_take isl_union_set *domain,
        __isl_take isl_pw_aff *pa);</code></pre>

<p>A base expression can be added to a union expression using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *
isl_union_pw_aff_add_pw_aff(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_pw_aff *pa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_add_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_pw_multi_aff *pma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_add_pw_qpolynomial(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_pw_qpolynomial *pwqp);</code></pre>

<p>Union expressions can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_aff *isl_union_pw_aff_copy(
        __isl_keep isl_union_pw_aff *upa);
__isl_null isl_union_pw_aff *isl_union_pw_aff_free(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_copy(
        __isl_keep isl_union_pw_multi_aff *upma);
__isl_null isl_union_pw_multi_aff *
isl_union_pw_multi_aff_free(
        __isl_take isl_union_pw_multi_aff *upma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_copy(
        __isl_keep isl_union_pw_qpolynomial *upwqp);
__isl_null isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_free(
        __isl_take isl_union_pw_qpolynomial *upwqp);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_copy(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);
__isl_null isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_free(
        __isl_take isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>To iterate over the base expressions in a union expression, use the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_size isl_union_pw_aff_n_pw_aff(
        __isl_keep isl_union_pw_aff *upa);
isl_stat isl_union_pw_aff_foreach_pw_aff(
        __isl_keep isl_union_pw_aff *upa,
        isl_stat (*fn)(__isl_take isl_pw_aff *pa,
                void *user), void *user);
isl_bool isl_union_pw_aff_every_pw_aff(
        __isl_keep isl_union_pw_aff *upa,
        isl_bool (*test)(__isl_keep isl_pw_aff *pa,
                void *user), void *user);
isl_size isl_union_pw_multi_aff_n_pw_multi_aff(
        __isl_keep isl_union_pw_multi_aff *upma);
isl_stat isl_union_pw_multi_aff_foreach_pw_multi_aff(
        __isl_keep isl_union_pw_multi_aff *upma,
        isl_stat (*fn)(__isl_take isl_pw_multi_aff *pma,
                    void *user), void *user);
isl_bool isl_union_pw_multi_aff_every_pw_multi_aff(
        __isl_keep isl_union_pw_multi_aff *upma,
        isl_bool (*test)(
                __isl_keep isl_pw_multi_aff *pma,
                void *user), void *user);

#include &lt;isl/polynomial.h&gt;
isl_size isl_union_pw_qpolynomial_n_pw_qpolynomial(
        __isl_keep isl_union_pw_qpolynomial *upwqp);
isl_stat isl_union_pw_qpolynomial_foreach_pw_qpolynomial(
        __isl_keep isl_union_pw_qpolynomial *upwqp,
        isl_stat (*fn)(__isl_take isl_pw_qpolynomial *pwqp,
                    void *user), void *user);
isl_bool isl_union_pw_qpolynomial_every_pw_qpolynomial(
        __isl_keep isl_union_pw_qpolynomial *upwqp,
        isl_bool (*test)(
                __isl_keep isl_pw_qpolynomial *pwqp,
                void *user), void *user);
isl_size isl_union_pw_qpolynomial_fold_n_pw_qpolynomial_fold(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);
isl_stat isl_union_pw_qpolynomial_fold_foreach_pw_qpolynomial_fold(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf,
        isl_stat (*fn)(__isl_take isl_pw_qpolynomial_fold *pwf,
                    void *user), void *user);
isl_bool
isl_union_pw_qpolynomial_fold_every_pw_qpolynomial_fold(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf,
        isl_bool (*test)(
                __isl_keep isl_pw_qpolynomial_fold *pwf,
                void *user), void *user);</code></pre>

<p>To extract the base expression in a given space from a union, use the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_union_pw_aff_extract_pw_aff(
        __isl_keep isl_union_pw_aff *upa,
        __isl_take isl_space *space);
__isl_give isl_pw_multi_aff *
isl_union_pw_multi_aff_extract_pw_multi_aff(
        __isl_keep isl_union_pw_multi_aff *upma,
        __isl_take isl_space *space);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_union_pw_qpolynomial_extract_pw_qpolynomial(
        __isl_keep isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_space *space);</code></pre>

<p>It is also possible to obtain a list of the base expressions using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff_list *
isl_union_pw_aff_get_pw_aff_list(
        __isl_keep isl_union_pw_aff *upa);
__isl_give isl_pw_multi_aff_list *
isl_union_pw_multi_aff_get_pw_multi_aff_list(
        __isl_keep isl_union_pw_multi_aff *upma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial_list *
isl_union_pw_qpolynomial_get_pw_qpolynomial_list(
        __isl_keep isl_union_pw_qpolynomial *upwqp);
__isl_give isl_pw_qpolynomial_fold_list *
isl_union_pw_qpolynomial_fold_get_pw_qpolynomial_fold_list(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>The returned list can be manipulated using the functions in <a href="#Lists">&quot;Lists&quot;</a>.</p>

<h2 id="Input-and-Output">Input and Output</h2>

<p>For set and relation, <code>isl</code> supports its own input/output format, which is similar to the <code>Omega</code> format, but also supports the <code>PolyLib</code> format in some cases. For other object types, typically only an <code>isl</code> format is supported.</p>

<h3 id="isl-format"><code>isl</code> format</h3>

<p>The <code>isl</code> format is similar to that of <code>Omega</code>, but has a different syntax for describing the parameters and allows for the definition of an existentially quantified variable as the integer division of an affine expression. For example, the set of integers <code>i</code> between <code>0</code> and <code>n</code> such that <code>i % 10 &lt;= 6</code> can be described as</p>

<pre><code>[n] -&gt; { [i] : exists (a = [i/10] : 0 &lt;= i and i &lt;= n and
                        i - 10 a &lt;= 6) }</code></pre>

<p>A set or relation can have several disjuncts, separated by the keyword <code>or</code>. Each disjunct is either a conjunction of constraints or a projection (<code>exists</code>) of a conjunction of constraints. The constraints are separated by the keyword <code>and</code>.</p>

<h3 id="PolyLib-format"><code>PolyLib</code> format</h3>

<p>If the represented set is a union, then the first line contains a single number representing the number of disjuncts. Otherwise, a line containing the number <code>1</code> is optional.</p>

<p>Each disjunct is represented by a matrix of constraints. The first line contains two numbers representing the number of rows and columns, where the number of rows is equal to the number of constraints and the number of columns is equal to two plus the number of variables. The following lines contain the actual rows of the constraint matrix. In each row, the first column indicates whether the constraint is an equality (<code>0</code>) or inequality (<code>1</code>). The final column corresponds to the constant term.</p>

<p>If the set is parametric, then the coefficients of the parameters appear in the last columns before the constant column. The coefficients of any existentially quantified variables appear between those of the set variables and those of the parameters.</p>

<h3 id="Extended-PolyLib-format">Extended <code>PolyLib</code> format</h3>

<p>The extended <code>PolyLib</code> format is nearly identical to the <code>PolyLib</code> format. The only difference is that the line containing the number of rows and columns of a constraint matrix also contains four additional numbers: the number of output dimensions, the number of input dimensions, the number of local dimensions (i.e., the number of existentially quantified variables) and the number of parameters. For sets, the number of ``output&#39;&#39; dimensions is equal to the number of set dimensions, while the number of ``input&#39;&#39; dimensions is zero.</p>

<h3 id="Input">Input</h3>

<p>Objects can be read from input using the following functions.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_id *isl_id_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_multi_id *isl_multi_id_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/val.h&gt;
__isl_give isl_val *isl_val_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_multi_val *isl_multi_val_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_basic_set *isl_basic_set_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_set *isl_set_read_from_file(isl_ctx *ctx,
        FILE *input);
__isl_give isl_set *isl_set_read_from_str(isl_ctx *ctx,
        const char *str);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_basic_map *isl_basic_map_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_map *isl_map_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_map *isl_map_read_from_str(isl_ctx *ctx,
        const char *str);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_union_set *isl_union_set_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_union_map *isl_union_map_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_multi_aff *isl_multi_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_pw_aff *isl_pw_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_read_from_str(
        isl_ctx *ctx, const char *str);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_read_from_str(
        isl_ctx *ctx, const char *str);

__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_read_from_str(
        isl_ctx *ctx, const char *str);</code></pre>

<p>For sets and relations, the input format is autodetected and may be either the <code>PolyLib</code> format or the <code>isl</code> format.</p>

<h3 id="Output">Output</h3>

<p>Before anything can be printed, an <code>isl_printer</code> needs to be created.</p>

<pre><code>__isl_give isl_printer *isl_printer_to_file(isl_ctx *ctx,
        FILE *file);
__isl_give isl_printer *isl_printer_to_str(isl_ctx *ctx);
__isl_null isl_printer *isl_printer_free(
        __isl_take isl_printer *printer);</code></pre>

<p><code>isl_printer_to_file</code> prints to the given file, while <code>isl_printer_to_str</code> prints to a string that can be extracted using the following function.</p>

<pre><code>#include &lt;isl/printer.h&gt;
__isl_give char *isl_printer_get_str(
        __isl_keep isl_printer *printer);</code></pre>

<p>The printer can be inspected using the following functions.</p>

<pre><code>FILE *isl_printer_get_file(
        __isl_keep isl_printer *printer);
int isl_printer_get_output_format(
        __isl_keep isl_printer *p);
int isl_printer_get_yaml_style(__isl_keep isl_printer *p);</code></pre>

<p>The behavior of the printer can be modified in various ways</p>

<pre><code>__isl_give isl_printer *isl_printer_set_output_format(
        __isl_take isl_printer *p, int output_format);
__isl_give isl_printer *isl_printer_set_indent(
        __isl_take isl_printer *p, int indent);
__isl_give isl_printer *isl_printer_set_indent_prefix(
        __isl_take isl_printer *p, const char *prefix);
__isl_give isl_printer *isl_printer_indent(
        __isl_take isl_printer *p, int indent);
__isl_give isl_printer *isl_printer_set_prefix(
        __isl_take isl_printer *p, const char *prefix);
__isl_give isl_printer *isl_printer_set_suffix(
        __isl_take isl_printer *p, const char *suffix);
__isl_give isl_printer *isl_printer_set_yaml_style(
        __isl_take isl_printer *p, int yaml_style);</code></pre>

<p>The <code>output_format</code> may be either <code>ISL_FORMAT_ISL</code>, <code>ISL_FORMAT_OMEGA</code>, <code>ISL_FORMAT_POLYLIB</code>, <code>ISL_FORMAT_EXT_POLYLIB</code> or <code>ISL_FORMAT_LATEX</code> and defaults to <code>ISL_FORMAT_ISL</code>. Each line in the output is prefixed by <code>indent_prefix</code>, indented by <code>indent</code> (set by <code>isl_printer_set_indent</code>) spaces (default: 0), prefixed by <code>prefix</code> and suffixed by <code>suffix</code>. In the <code>PolyLib</code> format output, the coefficients of the existentially quantified variables appear between those of the set variables and those of the parameters. The function <code>isl_printer_indent</code> increases the indentation by the specified amount (which may be negative). The YAML style may be either <code>ISL_YAML_STYLE_BLOCK</code> or <code>ISL_YAML_STYLE_FLOW</code> and when we are printing something in YAML format.</p>

<p>To actually print something, use</p>

<pre><code>#include &lt;isl/printer.h&gt;
__isl_give isl_printer *isl_printer_print_double(
        __isl_take isl_printer *p, double d);

#include &lt;isl/val.h&gt;
__isl_give isl_printer *isl_printer_print_val(
        __isl_take isl_printer *p, __isl_keep isl_val *v);
__isl_give isl_printer *isl_printer_print_multi_val(
        __isl_take isl_printer *p,
        __isl_keep isl_multi_val *mv);

#include &lt;isl/set.h&gt;
__isl_give isl_printer *isl_printer_print_basic_set(
        __isl_take isl_printer *printer,
        __isl_keep isl_basic_set *bset);
__isl_give isl_printer *isl_printer_print_set(
        __isl_take isl_printer *printer,
        __isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_printer *isl_printer_print_basic_map(
        __isl_take isl_printer *printer,
        __isl_keep isl_basic_map *bmap);
__isl_give isl_printer *isl_printer_print_map(
        __isl_take isl_printer *printer,
        __isl_keep isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_printer *isl_printer_print_union_set(
        __isl_take isl_printer *p,
        __isl_keep isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_printer *isl_printer_print_union_map(
        __isl_take isl_printer *p,
        __isl_keep isl_union_map *umap);

#include &lt;isl/id.h&gt;
__isl_give isl_printer *isl_printer_print_multi_id(
        __isl_take isl_printer *p,
        __isl_keep isl_multi_id *mi);

#include &lt;isl/aff.h&gt;
__isl_give isl_printer *isl_printer_print_aff(
        __isl_take isl_printer *p, __isl_keep isl_aff *aff);
__isl_give isl_printer *isl_printer_print_multi_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_multi_aff *maff);
__isl_give isl_printer *isl_printer_print_pw_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_pw_aff *pwaff);
__isl_give isl_printer *isl_printer_print_pw_multi_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_pw_multi_aff *pma);
__isl_give isl_printer *isl_printer_print_multi_pw_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give isl_printer *isl_printer_print_union_pw_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_union_pw_aff *upa);
__isl_give isl_printer *isl_printer_print_union_pw_multi_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_union_pw_multi_aff *upma);
__isl_give isl_printer *
isl_printer_print_multi_union_pw_aff(
        __isl_take isl_printer *p,
        __isl_keep isl_multi_union_pw_aff *mupa);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_printer *isl_printer_print_qpolynomial(
        __isl_take isl_printer *p,
        __isl_keep isl_qpolynomial *qp);
__isl_give isl_printer *isl_printer_print_pw_qpolynomial(
        __isl_take isl_printer *p,
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_give isl_printer *isl_printer_print_union_pw_qpolynomial(
        __isl_take isl_printer *p,
        __isl_keep isl_union_pw_qpolynomial *upwqp);

__isl_give isl_printer *
isl_printer_print_pw_qpolynomial_fold(
        __isl_take isl_printer *p,
        __isl_keep isl_pw_qpolynomial_fold *pwf);
__isl_give isl_printer *
isl_printer_print_union_pw_qpolynomial_fold(
        __isl_take isl_printer *p,
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>For <code>isl_printer_print_qpolynomial</code>, <code>isl_printer_print_pw_qpolynomial</code> and <code>isl_printer_print_pw_qpolynomial_fold</code>, the output format of the printer needs to be set to either <code>ISL_FORMAT_ISL</code> or <code>ISL_FORMAT_C</code>. For <code>isl_printer_print_union_pw_qpolynomial</code> and <code>isl_printer_print_union_pw_qpolynomial_fold</code>, only <code>ISL_FORMAT_ISL</code> is supported. In case of printing in <code>ISL_FORMAT_C</code>, the user may want to set the names of all dimensions first.</p>

<p><code>isl</code> also provides limited support for printing YAML documents, just enough for the internal use for printing such documents.</p>

<pre><code>#include &lt;isl/printer.h&gt;
__isl_give isl_printer *isl_printer_yaml_start_mapping(
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_printer_yaml_end_mapping(
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_printer_yaml_start_sequence(
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_printer_yaml_end_sequence(
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_printer_yaml_next(
        __isl_take isl_printer *p);</code></pre>

<p>A document is started by a call to either <code>isl_printer_yaml_start_mapping</code> or <code>isl_printer_yaml_start_sequence</code>. Anything printed to the printer after such a call belong to the first key of the mapping or the first element in the sequence. The function <code>isl_printer_yaml_next</code> moves to the value if we are currently printing a mapping key, the next key if we are printing a value or the next element if we are printing an element in a sequence. Nested mappings and sequences are initiated by the same <code>isl_printer_yaml_start_mapping</code> or <code>isl_printer_yaml_start_sequence</code>. Each call to these functions needs to have a corresponding call to <code>isl_printer_yaml_end_mapping</code> or <code>isl_printer_yaml_end_sequence</code>.</p>

<p>When called on a file printer, the following function flushes the file. When called on a string printer, the buffer is cleared.</p>

<pre><code>__isl_give isl_printer *isl_printer_flush(
        __isl_take isl_printer *p);</code></pre>

<p>The following functions allow the user to attach notes to a printer in order to keep track of additional state.</p>

<pre><code>#include &lt;isl/printer.h&gt;
isl_bool isl_printer_has_note(__isl_keep isl_printer *p,
        __isl_keep isl_id *id);
__isl_give isl_id *isl_printer_get_note(
        __isl_keep isl_printer *p, __isl_take isl_id *id);
__isl_give isl_printer *isl_printer_set_note(
        __isl_take isl_printer *p,
        __isl_take isl_id *id, __isl_take isl_id *note);</code></pre>

<p><code>isl_printer_set_note</code> associates the given note to the given identifier in the printer. <code>isl_printer_get_note</code> retrieves a note associated to an identifier, while <code>isl_printer_has_note</code> checks if there is such a note. <code>isl_printer_get_note</code> fails if the requested note does not exist.</p>

<p>Alternatively, a string representation can be obtained directly using the following functions, which always print in isl format.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give char *isl_id_to_str(
        __isl_keep isl_id *id);
__isl_give char *isl_multi_id_to_str(
        __isl_keep isl_multi_id *mi);

#include &lt;isl/space.h&gt;
__isl_give char *isl_space_to_str(
        __isl_keep isl_space *space);

#include &lt;isl/val.h&gt;
__isl_give char *isl_val_to_str(__isl_keep isl_val *v);
__isl_give char *isl_multi_val_to_str(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/set.h&gt;
__isl_give char *isl_basic_set_to_str(
        __isl_keep isl_basic_set *bset);
__isl_give char *isl_set_to_str(
        __isl_keep isl_set *set);

#include &lt;isl/union_set.h&gt;
__isl_give char *isl_union_set_to_str(
        __isl_keep isl_union_set *uset);

#include &lt;isl/map.h&gt;
__isl_give char *isl_basic_map_to_str(
        __isl_keep isl_basic_map *bmap);
__isl_give char *isl_map_to_str(
        __isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give char *isl_union_map_to_str(
        __isl_keep isl_union_map *umap);

#include &lt;isl/aff.h&gt;
__isl_give char *isl_aff_to_str(__isl_keep isl_aff *aff);
__isl_give char *isl_pw_aff_to_str(
        __isl_keep isl_pw_aff *pa);
__isl_give char *isl_multi_aff_to_str(
        __isl_keep isl_multi_aff *ma);
__isl_give char *isl_pw_multi_aff_to_str(
        __isl_keep isl_pw_multi_aff *pma);
__isl_give char *isl_multi_pw_aff_to_str(
        __isl_keep isl_multi_pw_aff *mpa);
__isl_give char *isl_union_pw_aff_to_str(
        __isl_keep isl_union_pw_aff *upa);
__isl_give char *isl_union_pw_multi_aff_to_str(
        __isl_keep isl_union_pw_multi_aff *upma);
__isl_give char *isl_multi_union_pw_aff_to_str(
        __isl_keep isl_multi_union_pw_aff *mupa);

#include &lt;isl/point.h&gt;
__isl_give char *isl_point_to_str(
        __isl_keep isl_point *pnt);

#include &lt;isl/polynomial.h&gt;
__isl_give char *isl_pw_qpolynomial_to_str(
        __isl_keep isl_pw_qpolynomial *pwqp);
__isl_give char *isl_union_pw_qpolynomial_to_str(
        __isl_keep isl_union_pw_qpolynomial *upwqp);</code></pre>

<h2 id="Properties">Properties</h2>

<h3 id="Unary-Properties">Unary Properties</h3>

<ul>

<li><p>Emptiness</p>

<p>The following functions test whether the given set or relation contains any integer points. The ``plain&#39;&#39; variants do not perform any computations, but simply check if the given set or relation is already known to be empty.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_basic_set_plain_is_empty(
        __isl_keep isl_basic_set *bset);
isl_bool isl_basic_set_is_empty(
        __isl_keep isl_basic_set *bset);
isl_bool isl_set_plain_is_empty(
        __isl_keep isl_set *set);
isl_bool isl_set_is_empty(__isl_keep isl_set *set);

#include &lt;isl/union_set.h&gt;
isl_bool isl_union_set_is_empty(
        __isl_keep isl_union_set *uset);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_plain_is_empty(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_basic_map_is_empty(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_map_plain_is_empty(
        __isl_keep isl_map *map);
isl_bool isl_map_is_empty(__isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_plain_is_empty(
        __isl_keep isl_union_map *umap);
isl_bool isl_union_map_is_empty(
        __isl_keep isl_union_map *umap);

#include &lt;isl/aff.h&gt;
isl_bool isl_union_pw_multi_aff_plain_is_empty(
        __isl_keep isl_union_pw_multi_aff *upma);</code></pre>

</li>
<li><p>Universality</p>

<pre><code>isl_bool isl_basic_set_plain_is_universe(
        __isl_keep isl_basic_set *bset);
isl_bool isl_basic_set_is_universe(
        __isl_keep isl_basic_set *bset);
isl_bool isl_basic_map_plain_is_universe(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_basic_map_is_universe(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_set_plain_is_universe(
        __isl_keep isl_set *set);
isl_bool isl_map_plain_is_universe(
        __isl_keep isl_map *map);</code></pre>

</li>
<li><p>Single-valuedness</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_set_is_singleton(__isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_is_single_valued(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_map_plain_is_single_valued(
        __isl_keep isl_map *map);
isl_bool isl_map_is_single_valued(__isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_is_single_valued(
        __isl_keep isl_union_map *umap);</code></pre>

</li>
<li><p>Injectivity</p>

<pre><code>isl_bool isl_map_plain_is_injective(
        __isl_keep isl_map *map);
isl_bool isl_map_is_injective(
        __isl_keep isl_map *map);
isl_bool isl_union_map_plain_is_injective(
        __isl_keep isl_union_map *umap);
isl_bool isl_union_map_is_injective(
        __isl_keep isl_union_map *umap);</code></pre>

</li>
<li><p>Bijectivity</p>

<pre><code>isl_bool isl_map_is_bijective(
        __isl_keep isl_map *map);
isl_bool isl_union_map_is_bijective(
        __isl_keep isl_union_map *umap);</code></pre>

</li>
<li><p>Identity</p>

<p>The following functions test whether the given relation only maps elements to themselves.</p>

<pre><code>#include &lt;isl/map.h&gt;
isl_bool isl_map_is_identity(
        __isl_keep isl_map *map);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_is_identity(
        __isl_keep isl_union_map *umap);</code></pre>

</li>
<li><p>Position</p>

<pre><code>__isl_give isl_val *
isl_basic_map_plain_get_val_if_fixed(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_val *isl_set_plain_get_val_if_fixed(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);
__isl_give isl_multi_val *
isl_set_get_plain_multi_val_if_fixed(
        __isl_keep isl_set *set);
__isl_give isl_val *isl_map_plain_get_val_if_fixed(
        __isl_keep isl_map *map,
        enum isl_dim_type type, unsigned pos);</code></pre>

<p>If the set or relation obviously lies on a hyperplane where the given dimension has a fixed value, then return that value. Otherwise return NaN. <code>isl_set_get_plain_multi_val_if_fixed</code> collects the results over all set dimensions.</p>

</li>
<li><p>Stride</p>

<p>Stride detection is based on heuristics. The strides returned by the functions below are always valid, but there may be larger valid strides that are not detected.</p>

<pre><code>isl_stat isl_set_dim_residue_class_val(
        __isl_keep isl_set *set,
        int pos, __isl_give isl_val **modulo,
        __isl_give isl_val **residue);</code></pre>

<p>Check if the values of the given set dimension are equal to a fixed value modulo some integer value. If so, assign the modulo to <code>*modulo</code> and the fixed value to <code>*residue</code>. If the given dimension attains only a single value, then assign <code>0</code> to <code>*modulo</code> and the fixed value to <code>*residue</code>. If the dimension does not attain only a single value and if no modulo can be found then assign <code>1</code> to <code>*modulo</code> and <code>1</code> to <code>*residue</code>.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_stride_info *isl_set_get_stride_info(
        __isl_keep isl_set *set, int pos);
__isl_give isl_val *isl_set_get_stride(
        __isl_keep isl_set *set, int pos);
__isl_give isl_fixed_box *isl_set_get_lattice_tile(
        __isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_stride_info *
isl_map_get_range_stride_info(
        __isl_keep isl_map *map, int pos);
__isl_give isl_fixed_box *
isl_map_get_range_lattice_tile(
        __isl_keep isl_map *map);</code></pre>

<p>Check if the values of the given set dimension are equal to some affine expression of the other dimensions (the offset) modulo some integer stride or check if the values of the given output dimensions are equal to some affine expression of the input dimensions (the offset) modulo some integer stride. If no more specific information can be found, then the stride is taken to be one and the offset is taken to be the zero expression. The function <code>isl_set_get_stride</code> performs the same computation as <code>isl_set_get_stride_info</code> but only returns the stride. The function <code>isl_map_get_range_lattice_tile</code> collects the stride information over all output dimensions. In particular, it returns a tile of a rectangular lattice (possibly of size 1 in all directions) containing the output in terms of the parameters and the input dimensions. The size and the offset of this tile correspond to the strides and the offsets of the stride information and can be extracted from the returned <code>isl_fixed_box</code> using the functions described under &quot;Box hull&quot; in <a href="#Unary-Operations">&quot;Unary Operations&quot;</a>. Note that the <code>isl_fixed_box</code> object returned by <code>isl_map_get_range_lattice_tile</code> is always valid. The function <code>isl_set_get_lattice_tile</code> collects the same stride information over all set dimensions. For the other functions, the stride and offset can be extracted from the returned object using the following functions.</p>

<pre><code>#include &lt;isl/stride_info.h&gt;
__isl_give isl_val *isl_stride_info_get_stride(
        __isl_keep isl_stride_info *si);
__isl_give isl_aff *isl_stride_info_get_offset(
        __isl_keep isl_stride_info *si);</code></pre>

<p>The stride info object can be copied and released using the following functions.</p>

<pre><code>#include &lt;isl/stride_info.h&gt;
__isl_give isl_stride_info *isl_stride_info_copy(
        __isl_keep isl_stride_info *si);
__isl_null isl_stride_info *isl_stride_info_free(
        __isl_take isl_stride_info *si);</code></pre>

</li>
<li><p>Dependence</p>

<p>To check whether a function involves any local variables, i.e., integer divisions, the following functions can be used.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_set_involves_locals(
        __isl_keep isl_set *set);

#include &lt;isl/aff.h&gt;
isl_bool isl_aff_involves_locals(
        __isl_keep isl_aff *aff);
isl_bool isl_multi_aff_involves_locals(
        __isl_keep isl_multi_aff *ma);
isl_bool isl_pw_multi_aff_involves_locals(
        __isl_keep isl_pw_multi_aff *pma);
isl_bool isl_union_pw_multi_aff_involves_locals(
        __isl_keep isl_union_pw_multi_aff *upma);</code></pre>

<p>To check whether the description of a set, relation or function depends on a parameter or one or more given dimensions, the following functions can be used.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
isl_bool isl_constraint_involves_dims(
        __isl_keep isl_constraint *constraint,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/set.h&gt;
isl_bool isl_basic_set_involves_dims(
        __isl_keep isl_basic_set *bset,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_set_involves_dims(__isl_keep isl_set *set,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_involves_dims(
        __isl_keep isl_basic_map *bmap,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_map_involves_dims(__isl_keep isl_map *map,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_involves_dims(
        __isl_keep isl_union_map *umap,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/aff.h&gt;
isl_bool isl_aff_involves_dims(__isl_keep isl_aff *aff,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_pw_aff_involves_param_id(
        __isl_keep isl_pw_aff *pa,
        __isl_keep isl_id *id);
isl_bool isl_pw_aff_involves_dims(
        __isl_keep isl_pw_aff *pwaff,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_multi_aff_involves_dims(
        __isl_keep isl_multi_aff *ma,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_pw_multi_aff_involves_param_id(
        __isl_keep isl_pw_multi_aff *pma,
        __isl_keep isl_id *id);
isl_bool isl_pw_multi_aff_involves_dims(
        __isl_keep isl_pw_multi_aff *pma,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_multi_pw_aff_involves_dims(
        __isl_keep isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_multi_pw_aff_involves_param_id(
        __isl_keep isl_multi_pw_aff *mpa,
        __isl_keep isl_id *id);
isl_bool isl_multi_pw_aff_involves_param_id_list(
        __isl_keep isl_multi_pw_aff *mpa,
        __isl_keep isl_id_list *list);

#include &lt;isl/polynomial.h&gt;
isl_bool isl_qpolynomial_involves_dims(
        __isl_keep isl_qpolynomial *qp,
        enum isl_dim_type type, unsigned first, unsigned n);
isl_bool isl_pw_qpolynomial_involves_param_id(
        __isl_keep isl_pw_qpolynomial *pwqp,
        __isl_keep isl_id *id);
isl_bool isl_pw_qpolynomial_fold_involves_param_id(
        __isl_keep isl_pw_qpolynomial_fold *pwf,
        __isl_keep isl_id *id);</code></pre>

<p>Similarly, the following functions can be used to check whether a given dimension is involved in any lower or upper bound.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_set_dim_has_any_lower_bound(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_set_dim_has_any_upper_bound(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);</code></pre>

<p>Note that these functions return true even if there is a bound on the dimension on only some of the basic sets of <code>set</code>. To check if they have a bound for all of the basic sets in <code>set</code>, use the following functions instead.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_set_dim_has_lower_bound(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);
isl_bool isl_set_dim_has_upper_bound(
        __isl_keep isl_set *set,
        enum isl_dim_type type, unsigned pos);</code></pre>

</li>
<li><p>Space</p>

<p>To check whether a set is a parameter domain, use this function:</p>

<pre><code>isl_bool isl_set_is_params(__isl_keep isl_set *set);
isl_bool isl_union_set_is_params(
        __isl_keep isl_union_set *uset);</code></pre>

</li>
<li><p>Wrapping</p>

<p>The following functions check whether the space of the given (basic) set or relation domain and/or range is a wrapped relation.</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_is_wrapping(
        __isl_keep isl_space *space);
isl_bool isl_space_domain_is_wrapping(
        __isl_keep isl_space *space);
isl_bool isl_space_range_is_wrapping(
        __isl_keep isl_space *space);
isl_bool isl_space_is_product(
        __isl_keep isl_space *space);

#include &lt;isl/set.h&gt;
isl_bool isl_basic_set_is_wrapping(
        __isl_keep isl_basic_set *bset);
isl_bool isl_set_is_wrapping(__isl_keep isl_set *set);

#include &lt;isl/map.h&gt;
isl_bool isl_map_domain_is_wrapping(
        __isl_keep isl_map *map);
isl_bool isl_map_range_is_wrapping(
        __isl_keep isl_map *map);
isl_bool isl_map_is_product(__isl_keep isl_map *map);

#include &lt;isl/id.h&gt;
isl_bool isl_multi_id_range_is_wrapping(
        __isl_keep isl_multi_id *mi);

#include &lt;isl/val.h&gt;
isl_bool isl_multi_val_range_is_wrapping(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
isl_bool isl_multi_aff_range_is_wrapping(
        __isl_keep isl_multi_aff *ma);
isl_bool isl_multi_pw_aff_range_is_wrapping(
        __isl_keep isl_multi_pw_aff *mpa);
isl_bool isl_multi_union_pw_aff_range_is_wrapping(
        __isl_keep isl_multi_union_pw_aff *mupa);</code></pre>

<p>The input to <code>isl_space_is_wrapping</code> should be the space of a set, while that of <code>isl_space_domain_is_wrapping</code> and <code>isl_space_range_is_wrapping</code> should be the space of a relation. The input to <code>isl_space_is_product</code> can be either the space of a set or that of a binary relation. In case the input is the space of a binary relation, it checks whether both domain and range are wrapping.</p>

</li>
<li><p>Internal Product</p>

<pre><code>isl_bool isl_basic_map_can_zip(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_map_can_zip(__isl_keep isl_map *map);</code></pre>

<p>Check whether the product of domain and range of the given relation can be computed, i.e., whether both domain and range are nested relations.</p>

</li>
<li><p>Currying</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_can_curry(
        __isl_keep isl_space *space);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_can_curry(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_map_can_curry(__isl_keep isl_map *map);</code></pre>

<p>Check whether the domain of the (basic) relation is a wrapped relation.</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_can_uncurry(
        __isl_keep isl_space *space);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_can_uncurry(
        __isl_keep isl_basic_map *bmap);
isl_bool isl_map_can_uncurry(__isl_keep isl_map *map);</code></pre>

<p>Check whether the range of the (basic) relation is a wrapped relation.</p>

<pre><code>#include &lt;isl/space.h&gt;
isl_bool isl_space_can_range_curry(
        __isl_keep isl_space *space);

#include &lt;isl/map.h&gt;
isl_bool isl_map_can_range_curry(
        __isl_keep isl_map *map);</code></pre>

<p>Check whether the domain of the relation wrapped in the range of the input is itself a wrapped relation.</p>

</li>
<li><p>Special Values</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_bool isl_aff_is_cst(__isl_keep isl_aff *aff);
isl_bool isl_pw_aff_is_cst(__isl_keep isl_pw_aff *pwaff);
isl_bool isl_multi_pw_aff_is_cst(
        __isl_keep isl_multi_pw_aff *mpa);</code></pre>

<p>Check whether the given expression is a constant.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_bool isl_multi_val_involves_nan(
        __isl_keep isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
isl_bool isl_aff_is_nan(__isl_keep isl_aff *aff);
isl_bool isl_multi_aff_involves_nan(
        __isl_keep isl_multi_aff *ma);
isl_bool isl_pw_aff_involves_nan(
        __isl_keep isl_pw_aff *pa);
isl_bool isl_pw_multi_aff_involves_nan(
        __isl_keep isl_pw_multi_aff *pma);
isl_bool isl_multi_pw_aff_involves_nan(
        __isl_keep isl_multi_pw_aff *mpa);
isl_bool isl_union_pw_aff_involves_nan(
        __isl_keep isl_union_pw_aff *upa);
isl_bool isl_union_pw_multi_aff_involves_nan(
        __isl_keep isl_union_pw_multi_aff *upma);
isl_bool isl_multi_union_pw_aff_involves_nan(
        __isl_keep isl_multi_union_pw_aff *mupa);

#include &lt;isl/polynomial.h&gt;
isl_bool isl_qpolynomial_is_nan(
        __isl_keep isl_qpolynomial *qp);
isl_bool isl_qpolynomial_fold_is_nan(
        __isl_keep isl_qpolynomial_fold *fold);
isl_bool isl_pw_qpolynomial_involves_nan(
        __isl_keep isl_pw_qpolynomial *pwqp);
isl_bool isl_pw_qpolynomial_fold_involves_nan(
        __isl_keep isl_pw_qpolynomial_fold *pwf);
isl_bool isl_union_pw_qpolynomial_involves_nan(
        __isl_keep isl_union_pw_qpolynomial *upwqp);
isl_bool isl_union_pw_qpolynomial_fold_involves_nan(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>Check whether the given expression is equal to or involves NaN.</p>

<pre><code>#include &lt;isl/val.h&gt;
isl_bool isl_multi_val_is_zero(
        __isl_keep isl_multi_val *mv);</code></pre>

<p>Check whether the multiple value is zero.</p>

<pre><code>#include &lt;isl/aff.h&gt;
isl_bool isl_aff_plain_is_zero(
        __isl_keep isl_aff *aff);</code></pre>

<p>Check whether the affine expression is obviously zero.</p>

</li>
</ul>

<h3 id="Binary-Properties">Binary Properties</h3>

<ul>

<li><p>Equality</p>

<p>The following functions check whether two objects represent the same set, relation or function. The <code>plain</code> variants only return true if the objects are obviously the same. That is, they may return false even if the objects are the same, but they will never return true if the objects are not the same.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_basic_set_plain_is_equal(
        __isl_keep isl_basic_set *bset1,
        __isl_keep isl_basic_set *bset2);
isl_bool isl_basic_set_is_equal(
        __isl_keep isl_basic_set *bset1,
        __isl_keep isl_basic_set *bset2);
isl_bool isl_set_plain_is_equal(
        __isl_keep isl_set *set1,
        __isl_keep isl_set *set2);
isl_bool isl_set_is_equal(__isl_keep isl_set *set1,
        __isl_keep isl_set *set2);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_is_equal(
        __isl_keep isl_basic_map *bmap1,
        __isl_keep isl_basic_map *bmap2);
isl_bool isl_map_is_equal(__isl_keep isl_map *map1,
        __isl_keep isl_map *map2);
isl_bool isl_map_plain_is_equal(
        __isl_keep isl_map *map1,
        __isl_keep isl_map *map2);

#include &lt;isl/union_set.h&gt;
isl_bool isl_union_set_is_equal(
        __isl_keep isl_union_set *uset1,
        __isl_keep isl_union_set *uset2);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_is_equal(
        __isl_keep isl_union_map *umap1,
        __isl_keep isl_union_map *umap2);

#include &lt;isl/id.h&gt;
isl_bool isl_multi_id_plain_is_equal(
        __isl_keep isl_multi_id *mi1,
        __isl_keep isl_multi_id *mi2);

#include &lt;isl/val.h&gt;
isl_bool isl_multi_val_plain_is_equal(
        __isl_keep isl_multi_val *mv1,
        __isl_keep isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
isl_bool isl_aff_plain_is_equal(
        __isl_keep isl_aff *aff1,
        __isl_keep isl_aff *aff2);
isl_bool isl_multi_aff_plain_is_equal(
        __isl_keep isl_multi_aff *maff1,
        __isl_keep isl_multi_aff *maff2);
isl_bool isl_pw_aff_plain_is_equal(
        __isl_keep isl_pw_aff *pwaff1,
        __isl_keep isl_pw_aff *pwaff2);
isl_bool isl_pw_aff_is_equal(
        __isl_keep isl_pw_aff *pa1,
        __isl_keep isl_pw_aff *pa2);
isl_bool isl_pw_multi_aff_plain_is_equal(
        __isl_keep isl_pw_multi_aff *pma1,
        __isl_keep isl_pw_multi_aff *pma2);
isl_bool isl_pw_multi_aff_is_equal(
        __isl_keep isl_pw_multi_aff *pma1,
        __isl_keep isl_pw_multi_aff *pma2);
isl_bool isl_multi_pw_aff_plain_is_equal(
        __isl_keep isl_multi_pw_aff *mpa1,
        __isl_keep isl_multi_pw_aff *mpa2);
isl_bool isl_multi_pw_aff_is_equal(
        __isl_keep isl_multi_pw_aff *mpa1,
        __isl_keep isl_multi_pw_aff *mpa2);
isl_bool isl_union_pw_aff_plain_is_equal(
        __isl_keep isl_union_pw_aff *upa1,
        __isl_keep isl_union_pw_aff *upa2);
isl_bool isl_union_pw_multi_aff_plain_is_equal(
        __isl_keep isl_union_pw_multi_aff *upma1,
        __isl_keep isl_union_pw_multi_aff *upma2);
isl_bool isl_multi_union_pw_aff_plain_is_equal(
        __isl_keep isl_multi_union_pw_aff *mupa1,
        __isl_keep isl_multi_union_pw_aff *mupa2);

#include &lt;isl/polynomial.h&gt;
isl_bool isl_union_pw_qpolynomial_plain_is_equal(
        __isl_keep isl_union_pw_qpolynomial *upwqp1,
        __isl_keep isl_union_pw_qpolynomial *upwqp2);
isl_bool isl_union_pw_qpolynomial_fold_plain_is_equal(
        __isl_keep isl_union_pw_qpolynomial_fold *upwf1,
        __isl_keep isl_union_pw_qpolynomial_fold *upwf2);</code></pre>

</li>
<li><p>Disjointness</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_bool isl_basic_set_is_disjoint(
        __isl_keep isl_basic_set *bset1,
        __isl_keep isl_basic_set *bset2);
isl_bool isl_set_plain_is_disjoint(
        __isl_keep isl_set *set1,
        __isl_keep isl_set *set2);
isl_bool isl_set_is_disjoint(__isl_keep isl_set *set1,
        __isl_keep isl_set *set2);

#include &lt;isl/map.h&gt;
isl_bool isl_basic_map_is_disjoint(
        __isl_keep isl_basic_map *bmap1,
        __isl_keep isl_basic_map *bmap2);
isl_bool isl_map_is_disjoint(__isl_keep isl_map *map1,
        __isl_keep isl_map *map2);

#include &lt;isl/union_set.h&gt;
isl_bool isl_union_set_is_disjoint(
        __isl_keep isl_union_set *uset1,
        __isl_keep isl_union_set *uset2);

#include &lt;isl/union_map.h&gt;
isl_bool isl_union_map_is_disjoint(
        __isl_keep isl_union_map *umap1,
        __isl_keep isl_union_map *umap2);</code></pre>

</li>
<li><p>Subset</p>

<pre><code>isl_bool isl_basic_set_is_subset(
        __isl_keep isl_basic_set *bset1,
        __isl_keep isl_basic_set *bset2);
isl_bool isl_set_is_subset(__isl_keep isl_set *set1,
        __isl_keep isl_set *set2);
isl_bool isl_set_is_strict_subset(
        __isl_keep isl_set *set1,
        __isl_keep isl_set *set2);
isl_bool isl_union_set_is_subset(
        __isl_keep isl_union_set *uset1,
        __isl_keep isl_union_set *uset2);
isl_bool isl_union_set_is_strict_subset(
        __isl_keep isl_union_set *uset1,
        __isl_keep isl_union_set *uset2);
isl_bool isl_basic_map_is_subset(
        __isl_keep isl_basic_map *bmap1,
        __isl_keep isl_basic_map *bmap2);
isl_bool isl_basic_map_is_strict_subset(
        __isl_keep isl_basic_map *bmap1,
        __isl_keep isl_basic_map *bmap2);
isl_bool isl_map_is_subset(
        __isl_keep isl_map *map1,
        __isl_keep isl_map *map2);
isl_bool isl_map_is_strict_subset(
        __isl_keep isl_map *map1,
        __isl_keep isl_map *map2);
isl_bool isl_union_map_is_subset(
        __isl_keep isl_union_map *umap1,
        __isl_keep isl_union_map *umap2);
isl_bool isl_union_map_is_strict_subset(
        __isl_keep isl_union_map *umap1,
        __isl_keep isl_union_map *umap2);</code></pre>

<p>Check whether the first argument is a (strict) subset of the second argument.</p>

</li>
<li><p>Order</p>

<p>Every comparison function returns a negative value if the first argument is considered smaller than the second, a positive value if the first argument is considered greater and zero if the two constraints are considered the same by the comparison criterion.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
int isl_constraint_plain_cmp(
        __isl_keep isl_constraint *c1,
        __isl_keep isl_constraint *c2);</code></pre>

<p>This function is useful for sorting <code>isl_constraint</code>s. The order depends on the internal representation of the inputs. The order is fixed over different calls to the function (assuming the internal representation of the inputs has not changed), but may change over different versions of <code>isl</code>.</p>

<pre><code>#include &lt;isl/constraint.h&gt;
int isl_constraint_cmp_last_non_zero(
        __isl_keep isl_constraint *c1,
        __isl_keep isl_constraint *c2);</code></pre>

<p>This function can be used to sort constraints that live in the same local space. Constraints that involve ``earlier&#39;&#39; dimensions or that have a smaller coefficient for the shared latest dimension are considered smaller than other constraints. This function only defines a <b>partial</b> order.</p>

<pre><code>#include &lt;isl/set.h&gt;
int isl_set_plain_cmp(__isl_keep isl_set *set1,
        __isl_keep isl_set *set2);</code></pre>

<p>This function is useful for sorting <code>isl_set</code>s. The order depends on the internal representation of the inputs. The order is fixed over different calls to the function (assuming the internal representation of the inputs has not changed), but may change over different versions of <code>isl</code>.</p>

<pre><code>#include &lt;isl/aff.h&gt;
int isl_multi_aff_plain_cmp(
        __isl_keep isl_multi_aff *ma1,
        __isl_keep isl_multi_aff *ma2);
int isl_pw_aff_plain_cmp(__isl_keep isl_pw_aff *pa1,
        __isl_keep isl_pw_aff *pa2);</code></pre>

<p>The functions <code>isl_multi_aff_plain_cmp</code> and <code>isl_pw_aff_plain_cmp</code> can be used to sort <code>isl_multi_aff</code>s and <code>isl_pw_aff</code>s. The order is not strictly defined. The current order sorts expressions that only involve earlier dimensions before those that involve later dimensions.</p>

</li>
</ul>

<h2 id="Unary-Operations">Unary Operations</h2>

<ul>

<li><p>Complement</p>

<pre><code>__isl_give isl_set *isl_set_complement(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_complement(
        __isl_take isl_map *map);</code></pre>

</li>
<li><p>Inverse map</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_reverse(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_wrapped_reverse(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_domain_reverse(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_range_reverse(
        __isl_take isl_space *space);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_domain_reverse(
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *
isl_multi_aff_domain_reverse(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_domain_reverse(
        __isl_take isl_pw_aff *pa);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_domain_reverse(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_domain_reverse(
        __isl_take isl_multi_pw_aff *mpa);

#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_wrapped_reverse(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_reverse(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_reverse(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_domain_reverse(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_range_reverse(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_reverse(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_domain_reverse(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_range_reverse(
        __isl_take isl_union_map *umap);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *
isl_qpolynomial_domain_reverse(
        __isl_take isl_qpolynomial *qp);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_domain_reverse(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_domain_reverse(
        __isl_take isl_union_pw_qpolynomial *upwqp);</code></pre>

<p>The function <code>isl_space_range_reverse</code> reverses the relation that is embedded in the range of the input map space. The identifier of the range, if any, is only preserved if this embedded relation has identical input and output tuples. Similarly for <code>isl_space_domain_reverse</code>. Along the same lines, <code>isl_space_wrapped_reverse</code> reverses the relation that is embedded in a set space.</p>

</li>
<li><p>Tuple binding</p>

<p>The following function binds a tuple to a sequence of parameter identifiers, equating the tuple dimensions to the parameters with those identifiers and subsequently projecting out the tuple. If the original object did not reference any such parameters, then this means that the tuple dimensions are reinterpreted as parameters. The space of <code>tuple</code> needs to match that of the bound tuple.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_bind(
        __isl_take isl_set *set,
        __isl_take isl_multi_id *tuple);

#include &lt;isl/map.h&gt;
__isl_give isl_set *isl_map_bind_domain(
        __isl_take isl_map *map,
        __isl_take isl_multi_id *tuple);
__isl_give isl_set *isl_map_bind_range(
        __isl_take isl_map *map,
        __isl_take isl_multi_id *tuple);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_set *isl_union_map_bind_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_id *tuple);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_bind_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_multi_id *tuple);
__isl_give isl_multi_aff *isl_multi_aff_bind_domain(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_id *tuple);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_bind_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_id *tuple);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_bind_domain(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_id *tuple);
__isl_give isl_pw_aff *
isl_pw_aff_bind_domain_wrapped_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_multi_id *tuple);
__isl_give isl_multi_aff *
isl_multi_aff_bind_domain_wrapped_domain(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_id *tuple);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_bind_domain_wrapped_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_id *tuple);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_bind_domain_wrapped_domain(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_id *tuple);
__isl_give isl_basic_set *isl_aff_bind_id(
        __isl_take isl_aff *aff,
        __isl_take isl_id *id);
__isl_give isl_set *isl_pw_aff_bind_id(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_id *id);
__isl_give isl_basic_set *isl_multi_aff_bind(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_id *tuple);
__isl_give isl_set *isl_multi_pw_aff_bind(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_id *tuple);
__isl_give isl_union_set *isl_union_pw_aff_bind_id(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_id *id);
__isl_give isl_union_set *
isl_multi_union_pw_aff_bind(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_multi_id *tuple);</code></pre>

<p>Projecting out the domain of the wrapped relation in the domain of a function leaves the range of that wrapped relation in the domain of the resulting function. In the case of <code>isl_aff_bind_id</code>, <code>isl_pw_aff_bind_id</code>, <code>isl_multi_aff_bind</code>, <code>isl_multi_pw_aff_bind</code>, <code>isl_union_pw_aff_bind_id</code> and <code>isl_multi_union_pw_aff_bind</code>, the parameters are bound to the function values and the result lives in the domain of the input function.</p>

</li>
<li><p>Projection</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_range(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_params(
        __isl_take isl_space *space);
__isl_give isl_space *
isl_space_domain_wrapped_domain(
        __isl_take isl_space *space);
__isl_give isl_space *
isl_space_domain_wrapped_range(
        __isl_take isl_space *space);
__isl_give isl_space *
isl_space_range_wrapped_domain(
        __isl_take isl_space *space);
__isl_give isl_space *
isl_space_range_wrapped_range(
        __isl_take isl_space *space);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_domain(
        __isl_take isl_local_space *ls);
__isl_give isl_local_space *isl_local_space_range(
        __isl_take isl_local_space *ls);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_project_out(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_set *isl_set_project_out_param_id(
        __isl_take isl_set *set,
        __isl_take isl_id *id);
__isl_give isl_set *
isl_set_project_out_param_id_list(
        __isl_take isl_set *set,
        __isl_take isl_id_list *list);
__isl_give isl_set *isl_set_project_out(__isl_take isl_set *set,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_set *isl_set_project_out_all_params(
        __isl_take isl_set *set);
__isl_give isl_map *isl_set_project_onto_map(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned first,
        unsigned n);
__isl_give isl_basic_set *isl_basic_set_params(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_params(__isl_take isl_set *set);</code></pre>

<p>The function <code>isl_space_domain_wrapped_domain</code> returns the domain of the binary relation wrapped inside the domain of the input. The function <code>isl_set_project_onto_map</code> returns a relation that projects the input set onto the given set dimensions.</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_project_out(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_map *isl_map_project_out_param_id(
        __isl_take isl_map *map,
        __isl_take isl_id *id);
__isl_give isl_map *isl_map_project_out_param_id_list(
        __isl_take isl_map *map,
        __isl_take isl_id_list *list);
__isl_give isl_map *isl_map_project_out(__isl_take isl_map *map,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_map *isl_map_project_out_all_params(
        __isl_take isl_map *map);
__isl_give isl_basic_set *isl_basic_map_domain(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_set *isl_basic_map_range(
        __isl_take isl_basic_map *bmap);
__isl_give isl_set *isl_map_params(__isl_take isl_map *map);
__isl_give isl_set *isl_map_domain(
        __isl_take isl_map *bmap);
__isl_give isl_set *isl_map_range(
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_project_out(
        __isl_take isl_union_set *uset,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_union_set *
isl_union_set_project_out_all_params(
        __isl_take isl_union_set *uset);
__isl_give isl_set *isl_union_set_params(
        __isl_take isl_union_set *uset);</code></pre>

<p>The function <code>isl_union_set_project_out</code> can only project out parameters.</p>

<pre><code>#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_project_out_param_id(
        __isl_take isl_union_map *umap,
        __isl_take isl_id *id);
__isl_give isl_union_map *
isl_union_map_project_out_param_id_list(
        __isl_take isl_union_map *umap,
        __isl_take isl_id_list *list);
__isl_give isl_union_map *isl_union_map_project_out(
        __isl_take isl_union_map *umap,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_union_map *
isl_union_map_project_out_all_params(
        __isl_take isl_union_map *umap);
__isl_give isl_set *isl_union_map_params(
        __isl_take isl_union_map *umap);
__isl_give isl_union_set *isl_union_map_domain(
        __isl_take isl_union_map *umap);
__isl_give isl_union_set *isl_union_map_range(
        __isl_take isl_union_map *umap);</code></pre>

<p>The function <code>isl_union_map_project_out</code> can only project out parameters.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_project_domain_on_params(
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *
isl_multi_aff_project_domain_on_params(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *
isl_pw_aff_project_domain_on_params(
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_project_domain_on_params(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_project_domain_on_params(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_set *isl_pw_aff_domain(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_set *isl_pw_multi_aff_domain(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_set *isl_multi_pw_aff_domain(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_union_set *isl_union_pw_aff_domain(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_set *isl_union_pw_multi_aff_domain(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_set *
isl_multi_union_pw_aff_domain(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_set *isl_pw_aff_params(
        __isl_take isl_pw_aff *pwa);</code></pre>

<p>If no explicit domain was set on a zero-dimensional input to <code>isl_multi_union_pw_aff_domain</code>, then this function will return a parameter set.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *
isl_qpolynomial_project_domain_on_params(
        __isl_take isl_qpolynomial *qp);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_project_domain_on_params(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_project_domain_on_params(
        __isl_take isl_pw_qpolynomial_fold *pwf);
__isl_give isl_set *isl_pw_qpolynomial_domain(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_set *isl_union_pw_qpolynomial_fold_domain(
        __isl_take isl_union_pw_qpolynomial_fold *upwf);
__isl_give isl_union_set *isl_union_pw_qpolynomial_domain(
        __isl_take isl_union_pw_qpolynomial *upwqp);

#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_domain_map(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_range_map(
        __isl_take isl_space *space);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_set_wrapped_domain_map(
        __isl_take isl_set *set);
__isl_give isl_basic_map *isl_basic_map_domain_map(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_map *isl_basic_map_range_map(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_domain_map(__isl_take isl_map *map);
__isl_give isl_map *isl_map_range_map(__isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_domain_map(
        __isl_take isl_union_map *umap);
__isl_give isl_union_pw_multi_aff *
isl_union_map_domain_map_union_pw_multi_aff(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_range_map(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *
isl_union_set_wrapped_domain_map(
        __isl_take isl_union_set *uset);</code></pre>

<p>The functions above construct a (basic, regular or union) relation that maps (a wrapped version of) the input relation to its domain or range. <code>isl_set_wrapped_domain_map</code> maps the input set to the domain of its wrapped relation.</p>

</li>
<li><p>Elimination</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_eliminate(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_set *isl_set_eliminate(
        __isl_take isl_set *set, enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_basic_map *isl_basic_map_eliminate(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_map *isl_map_eliminate(
        __isl_take isl_map *map, enum isl_dim_type type,
        unsigned first, unsigned n);</code></pre>

<p>Eliminate the coefficients for the given dimensions from the constraints, without removing the dimensions.</p>

</li>
<li><p>Constructing a set from a parameter domain</p>

<p>A set space of a given dimension and with an optional name can be created from a parameter space using the following functions.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_add_unnamed_tuple_ui(
        __isl_take isl_space *space, unsigned dim);
__isl_give isl_space *
isl_space_add_named_tuple_id_ui(
        __isl_take isl_space *space,
        __isl_take isl_id *tuple_id, unsigned dim);</code></pre>

<p>A set with a given tuple can be created from a parameter domain using the following function.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_unbind_params(
        __isl_take isl_set *set,
        __isl_take isl_multi_id *tuple);</code></pre>

<p>Any parameters with identifiers in <code>tuple</code> are reinterpreted as the corresponding set dimensions.</p>

<p>A zero-dimensional (local) space or (basic) set can be constructed on a given parameter domain using the following functions.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_set_from_params(
        __isl_take isl_space *space);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *
isl_local_space_set_from_params(
        __isl_take isl_local_space *ls);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_from_params(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_from_params(
        __isl_take isl_set *set);</code></pre>

</li>
<li><p>Constructing a relation from one or two sets</p>

<p>A map space with a range of a given dimension and with an optional name can be created from a domain space using the functions <code>isl_space_add_unnamed_tuple_ui</code> and <code>isl_space_add_named_tuple_id_ui</code> described above.</p>

<p>A relation with a given domain tuple can be created from a set that will become the range of the relation using the following function.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_map *
isl_set_unbind_params_insert_domain(
        __isl_take isl_set *set,
        __isl_take isl_multi_id *domain);</code></pre>

<p>Any parameters with identifiers in <code>domain</code> are reinterpreted as the corresponding input dimensions.</p>

<p>Similarly, a function defined over a parameter domain can be converted into one defined over a set domain using the following functions.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *
isl_aff_unbind_params_insert_domain(
        __isl_take isl_aff *aff,
        __isl_take isl_multi_id *domain);
__isl_give isl_multi_aff *
isl_multi_aff_unbind_params_insert_domain(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_id *domain);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_unbind_params_insert_domain(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_id *domain);</code></pre>

<p>Again, any parameters with identifiers in <code>domain</code> are reinterpreted as the corresponding input dimensions.</p>

<p>Create a relation with the given set(s) as domain and/or range. If only the domain or the range is specified, then the range or domain of the created relation is a zero-dimensional flat anonymous space. If the case of <code>isl_space_map_from_set</code>, the input space specifies both the domain and the range of the result.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_from_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_from_range(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_map_from_set(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_map_from_domain_and_range(
        __isl_take isl_space *domain,
        __isl_take isl_space *range);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_from_domain(
        __isl_take isl_local_space *ls);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_set_insert_domain(
        __isl_take isl_set *set,
        __isl_take isl_space *domain);
__isl_give isl_map *isl_map_from_domain(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_from_range(
        __isl_take isl_set *set);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_from_domain(
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_from_range(
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *
isl_union_map_from_domain_and_range(
        __isl_take isl_union_set *domain,
        __isl_take isl_union_set *range);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_from_range(
        __isl_take isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_from_range(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *
isl_multi_aff_insert_domain(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_space *domain);
__isl_give isl_pw_aff *isl_pw_aff_insert_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_space *domain);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_insert_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_space *domain);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_insert_domain(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_space *domain);
__isl_give isl_aff *isl_aff_from_range(
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *isl_multi_aff_from_range(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_from_range(
        __isl_take isl_pw_aff *pwa);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_from_range(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_range(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_domain(
        __isl_take isl_set *set);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_domain(
        __isl_take isl_union_set *uset);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_from_range(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_from_range(
        __isl_take isl_pw_qpolynomial_fold *pwf);</code></pre>

</li>
<li><p>Slicing</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_fix_si(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_basic_set *isl_basic_set_fix_val(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *v);
__isl_give isl_set *isl_set_fix_si(__isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_set *isl_set_fix_val(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *v);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_fix_si(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_basic_map *isl_basic_map_fix_val(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *v);
__isl_give isl_map *isl_map_fix_si(__isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_map *isl_map_fix_val(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *v);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_fix_si(
        __isl_take isl_pw_multi_aff *pma,
        enum isl_dim_type type, unsigned pos, int value);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_fix_val(
        __isl_take isl_pw_qpolynomial *pwqp,
        enum isl_dim_type type, unsigned n,
        __isl_take isl_val *v);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_fix_val(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        enum isl_dim_type type, unsigned n,
        __isl_take isl_val *v);</code></pre>

<p>Intersect the set, relation or function domain with the hyperplane where the given dimension has the fixed given value.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *
isl_basic_set_lower_bound_val(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_basic_set *
isl_basic_set_upper_bound_val(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_set *isl_set_lower_bound_si(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_set *isl_set_lower_bound_val(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_set *isl_set_upper_bound_si(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_set *isl_set_upper_bound_val(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_set *isl_set_lower_bound_multi_val(
        __isl_take isl_set *set,
        __isl_take isl_multi_val *lower);
__isl_give isl_set *isl_set_upper_bound_multi_val(
        __isl_take isl_set *set,
        __isl_take isl_multi_val *upper);
__isl_give isl_set *isl_set_lower_bound_multi_pw_aff(
        __isl_take isl_set *set,
        __isl_take isl_multi_pw_aff *lower);
__isl_give isl_set *isl_set_upper_bound_multi_pw_aff(
        __isl_take isl_set *set,
        __isl_take isl_multi_pw_aff *upper);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_lower_bound_si(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_basic_map *isl_basic_map_upper_bound_si(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_map *isl_map_lower_bound_si(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_map *isl_map_upper_bound_si(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos, int value);
__isl_give isl_map *isl_map_lower_bound_val(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_map *isl_map_upper_bound_val(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos,
        __isl_take isl_val *value);
__isl_give isl_map *isl_map_lower_bound_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *lower);
__isl_give isl_map *isl_map_upper_bound_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *upper);</code></pre>

<p>Intersect the set or relation with the half-space where the given dimension has a value bounded by the given fixed integer value or symbolic constant expression. For functions taking a multi expression, this applies to all set dimensions. Those that bound a map, bound the range of that map. If the multi expression is zero-dimensional but has an explicit domain, then the (parameter) domain of the set or map is intersected with this explicit domain.</p>

<pre><code>__isl_give isl_set *isl_set_equate(__isl_take isl_set *set,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_basic_map *isl_basic_map_equate(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_map *isl_map_equate(__isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);</code></pre>

<p>Intersect the set or relation with the hyperplane where the given dimensions are equal to each other.</p>

<pre><code>__isl_give isl_map *isl_map_oppose(__isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);</code></pre>

<p>Intersect the relation with the hyperplane where the given dimensions have opposite values.</p>

<pre><code>__isl_give isl_map *isl_map_order_le(
        __isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_basic_map *isl_basic_map_order_ge(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_map *isl_map_order_ge(
        __isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_map *isl_map_order_lt(__isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_basic_map *isl_basic_map_order_gt(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);
__isl_give isl_map *isl_map_order_gt(__isl_take isl_map *map,
        enum isl_dim_type type1, int pos1,
        enum isl_dim_type type2, int pos2);</code></pre>

<p>Intersect the relation with the half-space where the given dimensions satisfy the given ordering.</p>

<pre><code>#include &lt;isl/union_set.h&gt;
__isl_give isl_union_map *isl_union_map_remove_map_if(
        __isl_take isl_union_map *umap,
        isl_bool (*fn)(__isl_keep isl_map *map,
                void *user), void *user);</code></pre>

<p>This function calls the callback function once for each pair of spaces for which there are elements in the input. If the callback returns <code>isl_bool_true</code>, then all those elements are removed from the result. The only remaining elements in the output are then those for which the callback returns <code>isl_bool_false</code>.</p>

</li>
<li><p>Locus</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_basic_set *isl_aff_zero_basic_set(
        __isl_take isl_aff *aff);
__isl_give isl_basic_set *isl_aff_neg_basic_set(
        __isl_take isl_aff *aff);
__isl_give isl_set *isl_pw_aff_pos_set(
        __isl_take isl_pw_aff *pa);
__isl_give isl_set *isl_pw_aff_nonneg_set(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_set *isl_pw_aff_zero_set(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_set *isl_pw_aff_non_zero_set(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_union_set *
isl_union_pw_aff_zero_union_set(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_set *
isl_multi_union_pw_aff_zero_union_set(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>The function <code>isl_aff_neg_basic_set</code> returns a basic set containing those elements in the domain space of <code>aff</code> where <code>aff</code> is negative. The function <code>isl_pw_aff_nonneg_set</code> returns a set containing those elements in the domain of <code>pwaff</code> where <code>pwaff</code> is non-negative. The function <code>isl_multi_union_pw_aff_zero_union_set</code> returns a union set containing those elements in the domains of its elements where they are all zero.</p>

</li>
<li><p>Identity</p>

<pre><code>__isl_give isl_map *isl_set_identity(
        __isl_take isl_set *set);
__isl_give isl_union_map *isl_union_set_identity(
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_set_identity_union_pw_multi_aff(
        __isl_take isl_union_set *uset);</code></pre>

<p>Construct an identity relation on the given (union) set.</p>

</li>
<li><p>Function Extraction</p>

<p>A piecewise quasi affine expression that is equal to 1 on a set and 0 outside the set can be created using the following function.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_set_indicator_function(
        __isl_take isl_set *set);</code></pre>

<p>A piecewise multiple quasi affine expression can be extracted from an <code>isl_set</code> or <code>isl_map</code>, provided the <code>isl_set</code> is a singleton and the <code>isl_map</code> is single-valued. In case of a conversion from an <code>isl_union_map</code> to an <code>isl_union_pw_multi_aff</code>, these properties need to hold in each domain space. A conversion to a <code>isl_multi_union_pw_aff</code> additionally requires that the input is non-empty and involves only a single range space.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *isl_set_as_pw_multi_aff(
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_set(
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *isl_map_as_pw_multi_aff(
        __isl_take isl_map *map);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_from_map(
        __isl_take isl_map *map);

__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_union_set(
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_map_as_union_pw_multi_aff(
        __isl_take isl_union_map *umap);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_from_union_map(
        __isl_take isl_union_map *umap);

__isl_give isl_multi_union_pw_aff *
isl_union_map_as_multi_union_pw_aff(
        __isl_take isl_union_map *umap);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_from_union_map(
        __isl_take isl_union_map *umap);</code></pre>

<p><code>isl_map_as_pw_multi_aff</code> and <code>isl_pw_multi_aff_from_map</code> perform the same operation. Similarly for <code>isl_set_as_pw_multi_aff</code> and <code>isl_pw_multi_aff_from_set</code>, for <code>isl_union_map_as_union_pw_multi_aff</code> and <code>isl_union_pw_multi_aff_from_union_map</code> and for <code>isl_union_map_as_multi_union_pw_aff</code> and <code>isl_multi_union_pw_aff_from_union_map</code>.</p>

</li>
<li><p>Deltas</p>

<pre><code>__isl_give isl_basic_set *isl_basic_map_deltas(
        __isl_take isl_basic_map *bmap);
__isl_give isl_set *isl_map_deltas(__isl_take isl_map *map);
__isl_give isl_union_set *isl_union_map_deltas(
        __isl_take isl_union_map *umap);</code></pre>

<p>These functions return a (basic) set containing the differences between image elements and corresponding domain elements in the input.</p>

<pre><code>__isl_give isl_basic_map *isl_basic_map_deltas_map(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_deltas_map(
        __isl_take isl_map *map);
__isl_give isl_union_map *isl_union_map_deltas_map(
        __isl_take isl_union_map *umap);</code></pre>

<p>The functions above construct a (basic, regular or union) relation that maps (a wrapped version of) the input relation to its delta set.</p>

</li>
<li><p>Translation</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_set_translation(
        __isl_take isl_set *deltas);</code></pre>

<p>This function performs essentially the opposite operation of <code>isl_map_deltas</code>. In particular, it returns pairs of elements in the same space that have a difference in <code>deltas</code>.</p>

</li>
<li><p>Coalescing</p>

<p>Simplify the representation of a set, relation or functions by trying to combine pairs of basic sets or relations into a single basic set or relation.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_coalesce(__isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_coalesce(__isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_coalesce(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_coalesce(
        __isl_take isl_union_map *umap);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_coalesce(
        __isl_take isl_pw_aff *pa);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_coalesce(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_coalesce(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_union_pw_aff *isl_union_pw_aff_coalesce(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_coalesce(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_coalesce(
        __isl_take isl_multi_union_pw_aff *mupa);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_coalesce(
        __isl_take isl_pw_qpolynomial_fold *pwf);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_coalesce(
        __isl_take isl_union_pw_qpolynomial *upwqp);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_coalesce(
        __isl_take isl_union_pw_qpolynomial_fold *upwf);</code></pre>

<p>One of the methods for combining pairs of basic sets or relations can result in coefficients that are much larger than those that appear in the constraints of the input. By default, the coefficients are not allowed to grow larger, but this can be changed by unsetting the following option.</p>

<pre><code>isl_stat isl_options_set_coalesce_bounded_wrapping(
        isl_ctx *ctx, int val);
int isl_options_get_coalesce_bounded_wrapping(
        isl_ctx *ctx);</code></pre>

<p>One of the other methods tries to combine pairs of basic sets with different local variables, treating them as existentially quantified variables even if they have known (but different) integer division expressions. The result may then also have existentially quantified variables. Turning on the following option prevents this from happening.</p>

<pre><code>isl_stat isl_options_set_coalesce_preserve_locals(
        isl_ctx *ctx, int val);
int isl_options_get_coalesce_preserve_locals(isl_ctx *ctx);</code></pre>

</li>
<li><p>Detecting equalities</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_detect_equalities(
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_map *isl_basic_map_detect_equalities(
        __isl_take isl_basic_map *bmap);
__isl_give isl_set *isl_set_detect_equalities(
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_detect_equalities(
        __isl_take isl_map *map);
__isl_give isl_union_set *isl_union_set_detect_equalities(
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_detect_equalities(
        __isl_take isl_union_map *umap);</code></pre>

<p>Simplify the representation of a set or relation by detecting implicit equalities.</p>

</li>
<li><p>Removing redundant constraints</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_remove_redundancies(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_remove_redundancies(
        __isl_take isl_set *set);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *
isl_union_set_remove_redundancies(
        __isl_take isl_union_set *uset);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_remove_redundancies(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_remove_redundancies(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_remove_redundancies(
        __isl_take isl_union_map *umap);</code></pre>

</li>
<li><p>Convex hull</p>

<pre><code>__isl_give isl_basic_set *isl_set_convex_hull(
        __isl_take isl_set *set);
__isl_give isl_basic_map *isl_map_convex_hull(
        __isl_take isl_map *map);</code></pre>

<p>If the input set or relation has any existentially quantified variables, then the result of these operations is currently undefined.</p>

</li>
<li><p>Simple hull</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *
isl_set_unshifted_simple_hull(
        __isl_take isl_set *set);
__isl_give isl_basic_set *isl_set_simple_hull(
        __isl_take isl_set *set);
__isl_give isl_basic_set *
isl_set_plain_unshifted_simple_hull(
        __isl_take isl_set *set);
__isl_give isl_basic_set *
isl_set_unshifted_simple_hull_from_set_list(
        __isl_take isl_set *set,
        __isl_take isl_set_list *list);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *
isl_map_unshifted_simple_hull(
        __isl_take isl_map *map);
__isl_give isl_basic_map *isl_map_simple_hull(
        __isl_take isl_map *map);
__isl_give isl_basic_map *
isl_map_plain_unshifted_simple_hull(
        __isl_take isl_map *map);
        __isl_give isl_basic_map *
isl_map_unshifted_simple_hull_from_map_list(
        __isl_take isl_map *map,
        __isl_take isl_map_list *list);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_simple_hull(
        __isl_take isl_union_map *umap);</code></pre>

<p>These functions compute a single basic set or relation that contains the whole input set or relation. In particular, the output is described by translates of the constraints describing the basic sets or relations in the input. In case of <code>isl_set_unshifted_simple_hull</code>, only the original constraints are used, without any translation. In case of <code>isl_set_plain_unshifted_simple_hull</code> and <code>isl_map_plain_unshifted_simple_hull</code>, the result is described by original constraints that are obviously satisfied by the entire input set or relation. In case of <code>isl_set_unshifted_simple_hull_from_set_list</code> and <code>isl_map_unshifted_simple_hull_from_map_list</code>, the constraints are taken from the elements of the second argument.</p>

</li>
<li><p>Affine hull</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_affine_hull(
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_set *isl_set_affine_hull(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_affine_hull(
        __isl_take isl_union_set *uset);
__isl_give isl_basic_map *isl_basic_map_affine_hull(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_map *isl_map_affine_hull(
        __isl_take isl_map *map);
__isl_give isl_union_map *isl_union_map_affine_hull(
        __isl_take isl_union_map *umap);</code></pre>

<p>In case of union sets and relations, the affine hull is computed per space.</p>

</li>
<li><p>Polyhedral hull</p>

<pre><code>__isl_give isl_basic_set *isl_set_polyhedral_hull(
        __isl_take isl_set *set);
__isl_give isl_basic_map *isl_map_polyhedral_hull(
        __isl_take isl_map *map);
__isl_give isl_union_set *isl_union_set_polyhedral_hull(
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_polyhedral_hull(
        __isl_take isl_union_map *umap);</code></pre>

<p>These functions compute a single basic set or relation not involving any existentially quantified variables that contains the whole input set or relation. In case of union sets and relations, the polyhedral hull is computed per space.</p>

</li>
<li><p>Box hull</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_fixed_box *
isl_set_get_simple_fixed_box_hull(
        __isl_keep isl_set *set)

#include &lt;isl/map.h&gt;
__isl_give isl_fixed_box *
isl_map_get_range_simple_fixed_box_hull(
        __isl_keep isl_map *map);</code></pre>

<p>These functions try to approximate the set or the range of the map by a box of fixed size. The box is described in terms of an offset living in the same space as the input and a size living in the set or range space. For any element in the input map, the range value is greater than or equal to the offset applied to the domain value and the difference with this offset is strictly smaller than the size. The same holds for the elements of the input set, where the offset is a parametric constant value. If no fixed-size approximation can be found, an <i>invalid</i> box is returned, i.e., one for which <code>isl_fixed_box_is_valid</code> below returns false.</p>

<p>The validity, the offset and the size of the box can be obtained using the following functions.</p>

<pre><code>#include &lt;isl/fixed_box.h&gt;
isl_bool isl_fixed_box_is_valid(
        __isl_keep isl_fixed_box *box);
__isl_give isl_multi_aff *isl_fixed_box_get_offset(
        __isl_keep isl_fixed_box *box);
__isl_give isl_multi_val *isl_fixed_box_get_size(
        __isl_keep isl_fixed_box *box);</code></pre>

<p>The box can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/fixed_box.h&gt;
__isl_give isl_fixed_box *isl_fixed_box_copy(
        __isl_keep isl_fixed_box *box);
__isl_null isl_fixed_box *isl_fixed_box_free(
        __isl_take isl_fixed_box *box);</code></pre>

<p>An object of type <code>isl_fixed_box</code> can be read from input using the following function.</p>

<pre><code>#include &lt;isl/fixed_box.h&gt;
__isl_give isl_fixed_box *
isl_fixed_box_read_from_str(isl_ctx *ctx,
        const char *str);</code></pre>

<p>A representation of the information contained in an object of type <code>isl_fixed_box</code> can be obtained using</p>

<pre><code>#include &lt;isl/fixed_box.h&gt;
__isl_give isl_printer *isl_printer_print_fixed_box(
        __isl_take isl_printer *p,
        __isl_keep isl_fixed_box *box);
__isl_give char *isl_fixed_box_to_str(
        __isl_keep isl_fixed_box *box);</code></pre>

<p><code>isl_fixed_box_to_str</code> prints the information in flow format.</p>

</li>
<li><p>Other approximations</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *
isl_basic_set_drop_constraints_involving_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_basic_set *
isl_basic_set_drop_constraints_not_involving_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_set *
isl_set_drop_constraints_involving_dims(
        __isl_take isl_set *set,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_set *
isl_set_drop_constraints_not_involving_dims(
        __isl_take isl_set *set,
        enum isl_dim_type type,
        unsigned first, unsigned n);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *
isl_basic_map_drop_constraints_involving_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_basic_map *
isl_basic_map_drop_constraints_not_involving_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_map *
isl_map_drop_constraints_involving_dims(
        __isl_take isl_map *map,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_map *
isl_map_drop_constraints_not_involving_dims(
        __isl_take isl_map *map,
        enum isl_dim_type type,
        unsigned first, unsigned n);</code></pre>

<p>These functions drop any constraints (not) involving the specified dimensions. Note that the result depends on the representation of the input.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_to_polynomial(
        __isl_take isl_pw_qpolynomial *pwqp, int sign);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_to_polynomial(
        __isl_take isl_union_pw_qpolynomial *upwqp, int sign);</code></pre>

<p>Approximate each quasipolynomial by a polynomial. If <code>sign</code> is positive, the polynomial will be an overapproximation. If <code>sign</code> is negative, it will be an underapproximation. If <code>sign</code> is zero, the approximation will lie somewhere in between.</p>

</li>
<li><p>Feasibility</p>

<pre><code>__isl_give isl_basic_set *isl_basic_set_sample(
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_set *isl_set_sample(
        __isl_take isl_set *set);
__isl_give isl_basic_map *isl_basic_map_sample(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_map *isl_map_sample(
        __isl_take isl_map *map);</code></pre>

<p>If the input (basic) set or relation is non-empty, then return a singleton subset of the input. Otherwise, return an empty set.</p>

</li>
<li><p>Optimization</p>

<pre><code>#include &lt;isl/ilp.h&gt;
__isl_give isl_val *isl_basic_set_max_val(
        __isl_keep isl_basic_set *bset,
        __isl_keep isl_aff *obj);
__isl_give isl_val *isl_set_min_val(
        __isl_keep isl_set *set,
        __isl_keep isl_aff *obj);
__isl_give isl_val *isl_set_max_val(
        __isl_keep isl_set *set,
        __isl_keep isl_aff *obj);
__isl_give isl_multi_val *
isl_union_set_min_multi_union_pw_aff(
        __isl_keep isl_union_set *uset,
        __isl_keep isl_multi_union_pw_aff *obj);</code></pre>

<p>Compute the minimum or maximum of the integer affine expression <code>obj</code> over the points in <code>set</code>. The result is <code>NULL</code> in case of an error, the optimal value in case there is one, negative infinity or infinity if the problem is unbounded and NaN if the problem is empty.</p>

<pre><code>#include &lt;isl/ilp.h&gt;
__isl_give isl_val *isl_pw_aff_min_val(
        __isl_take isl_pw_aff *pa);
__isl_give isl_val *isl_pw_aff_max_val(
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_val *
isl_pw_multi_aff_min_multi_val(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_val *
isl_pw_multi_aff_max_multi_val(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_val *
isl_multi_pw_aff_min_multi_val(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_val *
isl_multi_pw_aff_max_multi_val(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_val *isl_union_pw_aff_min_val(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_val *isl_union_pw_aff_max_val(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_multi_val *
isl_multi_union_pw_aff_min_multi_val(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_multi_val *
isl_multi_union_pw_aff_max_multi_val(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>Compute the minimum or maximum of the integer affine expression over its definition domain. The result is <code>NULL</code> in case of an error, the optimal value in case there is one, negative infinity or infinity if the problem is unbounded and NaN if the problem is empty.</p>

<pre><code>#include &lt;isl/ilp.h&gt;
__isl_give isl_val *isl_basic_set_dim_max_val(
        __isl_take isl_basic_set *bset, int pos);
__isl_give isl_val *isl_set_dim_min_val(
        __isl_take isl_set *set, int pos);
__isl_give isl_val *isl_set_dim_max_val(
        __isl_take isl_set *set, int pos);</code></pre>

<p>Return the minimal or maximal value attained by the given set dimension, independently of the parameter values and of any other dimensions. The result is <code>NULL</code> in case of an error, the optimal value in case there is one, (negative) infinity if the problem is unbounded and NaN if the input is empty.</p>

</li>
<li><p>Parametric optimization</p>

<pre><code>__isl_give isl_pw_aff *isl_set_dim_min(
        __isl_take isl_set *set, int pos);
__isl_give isl_pw_aff *isl_set_dim_max(
        __isl_take isl_set *set, int pos);
__isl_give isl_pw_aff *isl_map_dim_min(
        __isl_take isl_map *map, int pos);
__isl_give isl_pw_aff *isl_map_dim_max(
        __isl_take isl_map *map, int pos);
__isl_give isl_multi_pw_aff *
isl_set_min_multi_pw_aff(
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *
isl_set_max_multi_pw_aff(
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *
isl_map_min_multi_pw_aff(
        __isl_take isl_map *map);
__isl_give isl_multi_pw_aff *
isl_map_max_multi_pw_aff(
        __isl_take isl_map *map);</code></pre>

<p>Compute the minimum or maximum of the (given) set or output dimension(s) as a function of the parameters (and input dimensions), but independently of the other set or output dimensions. For lexicographic optimization, see <a href="#Lexicographic-Optimization">&quot;Lexicographic Optimization&quot;</a>.</p>

</li>
<li><p>Dual</p>

<p>The following functions compute either the set of (rational) coefficient values of valid constraints for the given set or the set of (rational) values satisfying the constraints with coefficients from the given set. Internally, these two sets of functions perform essentially the same operations, except that the set of coefficients is assumed to be a cone, while the set of values may be any polyhedron. The current implementation is based on the Farkas lemma and Fourier-Motzkin elimination, but this may change or be made optional in future. In particular, future implementations may use different dualization algorithms or skip the elimination step.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_coefficients(
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_set_list *
isl_basic_set_list_coefficients(
        __isl_take isl_basic_set_list *list);
__isl_give isl_basic_set *isl_set_coefficients(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_coefficients(
        __isl_take isl_union_set *bset);
__isl_give isl_basic_set *isl_basic_set_solutions(
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_set *isl_set_solutions(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_solutions(
        __isl_take isl_union_set *bset);</code></pre>

</li>
<li><p>Power</p>

<pre><code>__isl_give isl_map *isl_map_fixed_power_val(
        __isl_take isl_map *map,
        __isl_take isl_val *exp);
__isl_give isl_union_map *
isl_union_map_fixed_power_val(
        __isl_take isl_union_map *umap,
        __isl_take isl_val *exp);</code></pre>

<p>Compute the given power of <code>map</code>, where <code>exp</code> is assumed to be non-zero. If the exponent <code>exp</code> is negative, then the -<code>exp</code> th power of the inverse of <code>map</code> is computed.</p>

<pre><code>__isl_give isl_map *isl_map_power(__isl_take isl_map *map,
        isl_bool *exact);
__isl_give isl_union_map *isl_union_map_power(
        __isl_take isl_union_map *umap, isl_bool *exact);</code></pre>

<p>Compute a parametric representation for all positive powers <i>k</i> of <code>map</code>. The result maps <i>k</i> to a nested relation corresponding to the <i>k</i>th power of <code>map</code>. The result may be an overapproximation. If the result is known to be exact, then <code>*exact</code> is set to <code>1</code>.</p>

</li>
<li><p>Transitive closure</p>

<pre><code>__isl_give isl_map *isl_map_transitive_closure(
        __isl_take isl_map *map, isl_bool *exact);
__isl_give isl_union_map *isl_union_map_transitive_closure(
        __isl_take isl_union_map *umap, isl_bool *exact);</code></pre>

<p>Compute the transitive closure of <code>map</code>. The result may be an overapproximation. If the result is known to be exact, then <code>*exact</code> is set to <code>1</code>.</p>

</li>
<li><p>Reaching path lengths</p>

<pre><code>__isl_give isl_map *isl_map_reaching_path_lengths(
        __isl_take isl_map *map, isl_bool *exact);</code></pre>

<p>Compute a relation that maps each element in the range of <code>map</code> to the lengths of all paths composed of edges in <code>map</code> that end up in the given element. The result may be an overapproximation. If the result is known to be exact, then <code>*exact</code> is set to <code>1</code>. To compute the <i>maximal</i> path length, the resulting relation should be postprocessed by <code>isl_map_lexmax</code>. In particular, if the input relation is a dependence relation (mapping sources to sinks), then the maximal path length corresponds to the free schedule. Note, however, that <code>isl_map_lexmax</code> expects the maximum to be finite, so if the path lengths are unbounded (possibly due to the overapproximation), then you will get an error message.</p>

</li>
<li><p>Wrapping</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_wrap(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_unwrap(
        __isl_take isl_space *space);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_wrap(
        __isl_take isl_local_space *ls);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_map *isl_basic_set_unwrap(
        __isl_take isl_basic_set *bset);
__isl_give isl_map *isl_set_unwrap(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_set *isl_basic_map_wrap(
        __isl_take isl_basic_map *bmap);
__isl_give isl_set *isl_map_wrap(
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_map *isl_union_set_unwrap(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_set *isl_union_map_wrap(
        __isl_take isl_union_map *umap);</code></pre>

<p>The input to <code>isl_space_unwrap</code> should be the space of a set, while that of <code>isl_space_wrap</code> should be the space of a relation. Conversely, the output of <code>isl_space_unwrap</code> is the space of a relation, while that of <code>isl_space_wrap</code> is the space of a set.</p>

</li>
<li><p>Flattening</p>

<p>Remove any internal structure of domain (and range) of the given set or relation. If there is any such internal structure in the input, then the name of the space is also removed.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_flatten_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_flatten_range(
        __isl_take isl_space *space);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *
isl_local_space_flatten_domain(
        __isl_take isl_local_space *ls);
__isl_give isl_local_space *
isl_local_space_flatten_range(
        __isl_take isl_local_space *ls);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_flatten(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_flatten(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_flatten_domain(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_map *isl_basic_map_flatten_range(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_flatten_range(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_flatten_domain(
        __isl_take isl_map *map);
__isl_give isl_basic_map *isl_basic_map_flatten(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_flatten(
        __isl_take isl_map *map);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_flatten_range(
        __isl_take isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_flatten_range(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_flatten_domain(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_aff *isl_multi_aff_flatten_range(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_flatten_range(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_flatten_range(
        __isl_take isl_multi_union_pw_aff *mupa);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_set_flatten_map(
        __isl_take isl_set *set);</code></pre>

<p>The function above constructs a relation that maps the input set to a flattened version of the set.</p>

</li>
<li><p>Lifting</p>

<p>Lift the input set to a space with extra dimensions corresponding to the existentially quantified variables in the input. In particular, the result lives in a wrapped map where the domain is the original space and the range corresponds to the original existentially quantified variables.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_lift(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_lift(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_lift(
        __isl_take isl_union_set *uset);</code></pre>

<p>Given a local space that contains the existentially quantified variables of a set, a basic relation that, when applied to a basic set, has essentially the same effect as <code>isl_basic_set_lift</code>, can be constructed using the following function.</p>

<pre><code>#include &lt;isl/local_space.h&gt;
__isl_give isl_basic_map *isl_local_space_lifting(
        __isl_take isl_local_space *ls);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_lift(
        __isl_take isl_multi_aff *maff,
        __isl_give isl_local_space **ls);</code></pre>

<p>If the <code>ls</code> argument of <code>isl_multi_aff_lift</code> is not <code>NULL</code>, then it is assigned the local space that lies at the basis of the lifting applied.</p>

</li>
<li><p>Internal Product</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_zip(
        __isl_take isl_space *space);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_zip(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_zip(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_zip(
        __isl_take isl_union_map *umap);</code></pre>

<p>Given a relation with nested relations for domain and range, interchange the range of the domain with the domain of the range.</p>

</li>
<li><p>Currying</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_curry(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_uncurry(
        __isl_take isl_space *space);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_curry(
        __isl_take isl_basic_map *bmap);
__isl_give isl_basic_map *isl_basic_map_uncurry(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_curry(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_uncurry(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_curry(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_uncurry(
        __isl_take isl_union_map *umap);</code></pre>

<p>Given a relation with a nested relation for domain, the <code>curry</code> functions move the range of the nested relation out of the domain and use it as the domain of a nested relation in the range, with the original range as range of this nested relation. The <code>uncurry</code> functions perform the inverse operation.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_range_curry(
        __isl_take isl_space *space);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_range_curry(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_range_curry(
        __isl_take isl_union_map *umap);</code></pre>

<p>These functions apply the currying to the relation that is nested inside the range of the input.</p>

</li>
<li><p>Aligning parameters</p>

<p>Change the order of the parameters of the given set, relation or function such that the first parameters match those of <code>model</code>. This may involve the introduction of extra parameters. All parameters need to be named.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_align_params(
        __isl_take isl_space *space1,
        __isl_take isl_space *space2)

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_align_params(
        __isl_take isl_basic_set *bset,
        __isl_take isl_space *model);
__isl_give isl_set *isl_set_align_params(
        __isl_take isl_set *set,
        __isl_take isl_space *model);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_align_params(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_space *model);
__isl_give isl_map *isl_map_align_params(
        __isl_take isl_map *map,
        __isl_take isl_space *model);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_align_params(
        __isl_take isl_multi_id *mi,
        __isl_take isl_space *model);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_align_params(
        __isl_take isl_multi_val *mv,
        __isl_take isl_space *model);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_align_params(
        __isl_take isl_aff *aff,
        __isl_take isl_space *model);
__isl_give isl_multi_aff *isl_multi_aff_align_params(
        __isl_take isl_multi_aff *multi,
        __isl_take isl_space *model);
__isl_give isl_pw_aff *isl_pw_aff_align_params(
        __isl_take isl_pw_aff *pwaff,
        __isl_take isl_space *model);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_align_params(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_space *model);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_align_params(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_space *model);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_align_params(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_space *model);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_align_params(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_space *model);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_align_params(
        __isl_take isl_qpolynomial *qp,
        __isl_take isl_space *model);</code></pre>

</li>
<li><p>Drop unused parameters</p>

<p>Drop parameters that are not referenced by the isl object. All parameters need to be named.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *
isl_basic_set_drop_unused_params(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_drop_unused_params(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *
isl_basic_map_drop_unused_params(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_drop_unused_params(
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *
isl_union_set_drop_unused_params(
        __isl_take isl_union_set *uset);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_drop_unused_params(
        __isl_take isl_union_map *umap);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_drop_unused_params(
        __isl_take isl_pw_aff *pa);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_drop_unused_params(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_drop_unused_params(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_drop_unused_params(
        __isl_take isl_union_pw_multi_aff *upma);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_drop_unused_params(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_drop_unused_params(
        __isl_take isl_pw_qpolynomial_fold *pwf);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_drop_unused_params(
        __isl_take isl_union_pw_qpolynomial *upwqp);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_drop_unused_params(
        __isl_take isl_union_pw_qpolynomial_fold *upwf);</code></pre>

</li>
<li><p>Unary Arithmetic Operations</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_neg(
        __isl_take isl_set *set);
#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_neg(
        __isl_take isl_map *map);</code></pre>

<p><code>isl_set_neg</code> constructs a set containing the opposites of the elements in its argument. The domain of the result of <code>isl_map_neg</code> is the same as the domain of its argument. The corresponding range elements are the opposites of the corresponding range elements in the argument.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_neg(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_neg(
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *isl_multi_aff_neg(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_neg(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_neg(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_neg(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_union_pw_aff *isl_union_pw_aff_neg(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_neg(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_neg(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_aff *isl_aff_ceil(
        __isl_take isl_aff *aff);
__isl_give isl_pw_aff *isl_pw_aff_ceil(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_aff *isl_aff_floor(
        __isl_take isl_aff *aff);
__isl_give isl_multi_aff *isl_multi_aff_floor(
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_floor(
        __isl_take isl_pw_aff *pwaff);
__isl_give isl_union_pw_aff *isl_union_pw_aff_floor(
        __isl_take isl_union_pw_aff *upa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_floor(
        __isl_take isl_multi_union_pw_aff *mupa);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_list_min(
        __isl_take isl_pw_aff_list *list);
__isl_give isl_pw_aff *isl_pw_aff_list_max(
        __isl_take isl_pw_aff_list *list);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_neg(
        __isl_take isl_qpolynomial *qp);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_neg(
        __isl_take isl_pw_qpolynomial *pwqp);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_neg(
        __isl_take isl_union_pw_qpolynomial *upwqp);
__isl_give isl_qpolynomial *isl_qpolynomial_pow(
        __isl_take isl_qpolynomial *qp,
        unsigned exponent);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_pow(
        __isl_take isl_pw_qpolynomial *pwqp,
        unsigned exponent);</code></pre>

</li>
<li><p>Evaluation</p>

<p>The following functions evaluate a function in a point.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_val *isl_aff_eval(
        __isl_take isl_aff *aff,
        __isl_take isl_point *pnt);
__isl_give isl_val *isl_pw_aff_eval(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_point *pnt);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_val *isl_pw_qpolynomial_eval(
        __isl_take isl_pw_qpolynomial *pwqp,
        __isl_take isl_point *pnt);
__isl_give isl_val *isl_pw_qpolynomial_fold_eval(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_point *pnt);
__isl_give isl_val *isl_union_pw_qpolynomial_eval(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_point *pnt);
__isl_give isl_val *isl_union_pw_qpolynomial_fold_eval(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_point *pnt);</code></pre>

<p>These functions return NaN when evaluated at a void point. Note that <code>isl_pw_aff_eval</code> returns NaN when the function is evaluated outside its definition domain, while <code>isl_pw_qpolynomial_eval</code> returns zero when the function is evaluated outside its explicit domain.</p>

</li>
<li><p>Dimension manipulation</p>

<p>It is usually not advisable to directly change the (input or output) space of a set or a relation as this removes the name and the internal structure of the space. However, the functions below can be useful to add new parameters, assuming <code>isl_set_align_params</code> and <code>isl_map_align_params</code> are not sufficient.</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_add_dims(
        __isl_take isl_space *space,
        enum isl_dim_type type, unsigned n);
__isl_give isl_space *isl_space_insert_dims(
        __isl_take isl_space *space,
        enum isl_dim_type type, unsigned pos, unsigned n);
__isl_give isl_space *isl_space_drop_dims(
        __isl_take isl_space *space,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_space *isl_space_move_dims(
        __isl_take isl_space *space,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);

#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_add_dims(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned n);
__isl_give isl_local_space *isl_local_space_insert_dims(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_local_space *isl_local_space_drop_dims(
        __isl_take isl_local_space *ls,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_add_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned n);
__isl_give isl_set *isl_set_add_dims(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned n);
__isl_give isl_basic_set *isl_basic_set_insert_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type type, unsigned pos,
        unsigned n);
__isl_give isl_set *isl_set_insert_dims(
        __isl_take isl_set *set,
        enum isl_dim_type type, unsigned pos, unsigned n);
__isl_give isl_basic_set *isl_basic_set_move_dims(
        __isl_take isl_basic_set *bset,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);
__isl_give isl_set *isl_set_move_dims(
        __isl_take isl_set *set,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_add_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned n);
__isl_give isl_map *isl_map_add_dims(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned n);
__isl_give isl_basic_map *isl_basic_map_insert_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type type, unsigned pos,
        unsigned n);
__isl_give isl_map *isl_map_insert_dims(
        __isl_take isl_map *map,
        enum isl_dim_type type, unsigned pos, unsigned n);
__isl_give isl_basic_map *isl_basic_map_move_dims(
        __isl_take isl_basic_map *bmap,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);
__isl_give isl_map *isl_map_move_dims(
        __isl_take isl_map *map,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_insert_dims(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_multi_val *isl_multi_val_add_dims(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, unsigned n);
__isl_give isl_multi_val *isl_multi_val_drop_dims(
        __isl_take isl_multi_val *mv,
        enum isl_dim_type type, unsigned first, unsigned n);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_insert_dims(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_multi_aff *isl_multi_aff_insert_dims(
        __isl_take isl_multi_aff *ma,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_pw_aff *isl_pw_aff_insert_dims(
        __isl_take isl_pw_aff *pwaff,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_insert_dims(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_aff *isl_aff_add_dims(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, unsigned n);
__isl_give isl_multi_aff *isl_multi_aff_add_dims(
        __isl_take isl_multi_aff *ma,
        enum isl_dim_type type, unsigned n);
__isl_give isl_pw_aff *isl_pw_aff_add_dims(
        __isl_take isl_pw_aff *pwaff,
        enum isl_dim_type type, unsigned n);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_add_dims(
        __isl_take isl_multi_pw_aff *mpa,
        enum isl_dim_type type, unsigned n);
__isl_give isl_aff *isl_aff_drop_dims(
        __isl_take isl_aff *aff,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_multi_aff *isl_multi_aff_drop_dims(
        __isl_take isl_multi_aff *maff,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_pw_aff *isl_pw_aff_drop_dims(
        __isl_take isl_pw_aff *pwaff,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_drop_dims(
        __isl_take isl_pw_multi_aff *pma,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_union_pw_aff *isl_union_pw_aff_drop_dims(
        __isl_take isl_union_pw_aff *upa,
        enum isl_dim_type type, unsigned first, unsigned n);
__isl_give isl_union_pw_multi_aff *
        isl_union_pw_multi_aff_drop_dims(
        __isl_take isl_union_pw_multi_aff *upma,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_drop_dims(
        __isl_take isl_multi_union_pw_aff *mupa,
        enum isl_dim_type type, unsigned first,
        unsigned n);
__isl_give isl_aff *isl_aff_move_dims(
        __isl_take isl_aff *aff,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);
__isl_give isl_multi_aff *isl_multi_aff_move_dims(
        __isl_take isl_multi_aff *ma,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);
__isl_give isl_pw_aff *isl_pw_aff_move_dims(
        __isl_take isl_pw_aff *pa,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_move_dims(
        __isl_take isl_multi_pw_aff *pma,
        enum isl_dim_type dst_type, unsigned dst_pos,
        enum isl_dim_type src_type, unsigned src_pos,
        unsigned n);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_drop_dims(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        enum isl_dim_type type,
        unsigned first, unsigned n);
__isl_give isl_union_pw_qpolynomial_fold *
        isl_union_pw_qpolynomial_fold_drop_dims(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        enum isl_dim_type type,
        unsigned first, unsigned n);</code></pre>

<p>The operations on union expressions can only manipulate parameters.</p>

</li>
</ul>

<h2 id="Binary-Operations">Binary Operations</h2>

<p>The two arguments of a binary operation not only need to live in the same <code>isl_ctx</code>, they currently also need to have the same (number of) parameters.</p>

<h3 id="Basic-Operations">Basic Operations</h3>

<ul>

<li><p>Intersection</p>

<pre><code>#include &lt;isl/local_space.h&gt;
__isl_give isl_local_space *isl_local_space_intersect(
        __isl_take isl_local_space *ls1,
        __isl_take isl_local_space *ls2);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_intersect_params(
        __isl_take isl_basic_set *bset1,
        __isl_take isl_basic_set *bset2);
__isl_give isl_basic_set *isl_basic_set_intersect(
        __isl_take isl_basic_set *bset1,
        __isl_take isl_basic_set *bset2);
__isl_give isl_basic_set *isl_basic_set_list_intersect(
        __isl_take struct isl_basic_set_list *list);
__isl_give isl_set *isl_set_intersect_params(
        __isl_take isl_set *set,
        __isl_take isl_set *params);
__isl_give isl_set *isl_set_intersect(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);
__isl_give isl_set *isl_set_intersect_factor_domain(
        __isl_take isl_set *set,
        __isl_take isl_set *domain);
__isl_give isl_set *isl_set_intersect_factor_range(
        __isl_take isl_set *set,
        __isl_take isl_set *range);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_intersect_params(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_map *isl_basic_map_intersect_domain(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_map *isl_basic_map_intersect_range(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *bset);
__isl_give isl_basic_map *isl_basic_map_intersect(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_basic_map *isl_basic_map_list_intersect(
        __isl_take isl_basic_map_list *list);
__isl_give isl_map *isl_map_intersect_params(
        __isl_take isl_map *map,
        __isl_take isl_set *params);
__isl_give isl_map *isl_map_intersect_domain(
        __isl_take isl_map *map,
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_intersect_range(
        __isl_take isl_map *map,
        __isl_take isl_set *set);
__isl_give isl_map *isl_map_intersect(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *
isl_map_intersect_domain_factor_domain(
        __isl_take isl_map *map,
        __isl_take isl_map *factor);
__isl_give isl_map *
isl_map_intersect_domain_factor_range(
        __isl_take isl_map *map,
        __isl_take isl_map *factor);
__isl_give isl_map *
isl_map_intersect_range_factor_domain(
        __isl_take isl_map *map,
        __isl_take isl_map *factor);
__isl_give isl_map *
isl_map_intersect_range_factor_range(
        __isl_take isl_map *map,
        __isl_take isl_map *factor);
__isl_give isl_map *
isl_map_intersect_domain_wrapped_domain(
        __isl_take isl_map *map,
        __isl_take isl_set *domain);
__isl_give isl_map *
isl_map_intersect_range_wrapped_domain(
        __isl_take isl_map *map,
        __isl_take isl_set *domain);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_intersect_params(
        __isl_take isl_union_set *uset,
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_intersect(
        __isl_take isl_union_set *uset1,
        __isl_take isl_union_set *uset2);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_intersect_params(
        __isl_take isl_union_map *umap,
        __isl_take isl_set *set);
__isl_give isl_union_map *
isl_union_map_intersect_domain_union_set(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *
isl_union_map_intersect_domain_space(
        __isl_take isl_union_map *umap,
        __isl_take isl_space *space);
__isl_give isl_union_map *isl_union_map_intersect_domain(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *
isl_union_map_intersect_range_union_set(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *
isl_union_map_intersect_range_space(
        __isl_take isl_union_map *umap,
        __isl_take isl_space *space);
__isl_give isl_union_map *isl_union_map_intersect_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_intersect(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *
isl_union_map_intersect_domain_factor_domain(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_map *factor);
__isl_give isl_union_map *
isl_union_map_intersect_domain_factor_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_map *factor);
__isl_give isl_union_map *
isl_union_map_intersect_range_factor_domain(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_map *factor);
__isl_give isl_union_map *
isl_union_map_intersect_range_factor_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_map *factor);
__isl_give isl_union_map *
isl_union_map_intersect_domain_wrapped_domain_union_set(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *domain);
__isl_give isl_union_map *
isl_union_map_intersect_range_wrapped_domain_union_set(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *domain);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_intersect_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_intersect_domain(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_set *domain);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_intersect_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_intersect_domain_space(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_space *space);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_intersect_domain_union_set(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_aff *isl_union_pw_aff_intersect_domain(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_domain_space(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_space *space);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_domain_union_set(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_domain(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *uset);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_intersect_domain(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_aff *
isl_pw_aff_intersect_domain_wrapped_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_intersect_domain_wrapped_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_intersect_domain_wrapped_domain(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_domain_wrapped_domain(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_aff *
isl_pw_aff_intersect_domain_wrapped_range(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_intersect_domain_wrapped_range(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_domain_wrapped_range(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_intersect_domain_wrapped_range(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_aff *isl_pw_aff_intersect_params(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_intersect_params(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_intersect_params(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_intersect_params(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_set *set);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_intersect_params(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_set *set);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_intersect_params(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_set *params);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_intersect_range(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_set *set);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_intersect_domain(
        __isl_take isl_pw_qpolynomial *pwpq,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_domain_space(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_space *space);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_domain_union_set(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_domain(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_domain_space(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_space *space);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_domain_union_set(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_domain(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_intersect_domain_wrapped_domain(
        __isl_take isl_pw_qpolynomial *pwpq,
        __isl_take isl_set *set);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_intersect_domain_wrapped_domain(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_domain_wrapped_domain(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_domain(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_intersect_domain_wrapped_range(
        __isl_take isl_pw_qpolynomial *pwpq,
        __isl_take isl_set *set);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_intersect_domain_wrapped_range(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_domain_wrapped_range(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_domain_wrapped_range(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_intersect_params(
        __isl_take isl_pw_qpolynomial *pwpq,
        __isl_take isl_set *set);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_intersect_params(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_intersect_params(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_intersect_params(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_set *set);</code></pre>

<p>The second argument to the <code>_params</code> functions needs to be a parametric (basic) set. For the other functions, a parametric set for either argument is only allowed if the other argument is a parametric set as well. The list passed to <code>isl_basic_set_list_intersect</code> needs to have at least one element and all elements need to live in the same space. The function <code>isl_multi_union_pw_aff_intersect_range</code> restricts the input function to those shared domain elements that map to the specified range. <code>isl_union_map_intersect_domain</code> is an alternative name for <code>isl_union_map_intersect_domain_union_set</code>. Similarly for the other pairs of functions.</p>

</li>
<li><p>Union</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_basic_set_union(
        __isl_take isl_basic_set *bset1,
        __isl_take isl_basic_set *bset2);
__isl_give isl_set *isl_set_union(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);
__isl_give isl_set *isl_set_list_union(
        __isl_take isl_set_list *list);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_basic_map_union(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_map *isl_map_union(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_union(
        __isl_take isl_union_set *uset1,
        __isl_take isl_union_set *uset2);
__isl_give isl_union_set *isl_union_set_list_union(
        __isl_take isl_union_set_list *list);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_union(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);</code></pre>

<p>The list passed to <code>isl_set_list_union</code> needs to have at least one element and all elements need to live in the same space.</p>

</li>
<li><p>Set difference</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_subtract(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);

#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_subtract(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *isl_map_subtract_domain(
        __isl_take isl_map *map,
        __isl_take isl_set *dom);
__isl_give isl_map *isl_map_subtract_range(
        __isl_take isl_map *map,
        __isl_take isl_set *dom);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_subtract(
        __isl_take isl_union_set *uset1,
        __isl_take isl_union_set *uset2);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_subtract(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *isl_union_map_subtract_domain(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *dom);
__isl_give isl_union_map *isl_union_map_subtract_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *dom);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_subtract_domain(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_subtract_domain(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_subtract_domain_union_set(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_subtract_domain_space(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_space *space);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_subtract_domain(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_subtract_domain_union_set(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_set *set);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_subtract_domain_space(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_space *space);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_subtract_domain(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *uset);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_subtract_domain(
        __isl_take isl_pw_qpolynomial *pwpq,
        __isl_take isl_set *set);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_subtract_domain(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *set);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_subtract_domain_union_set(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_subtract_domain_space(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_space *space);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_subtract_domain(
        __isl_take isl_union_pw_qpolynomial *upwpq,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_subtract_domain_union_set(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_subtract_domain_space(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_space *space);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_subtract_domain(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *uset);</code></pre>

<p><code>isl_union_pw_aff_subtract_domain</code> is an alternative name for <code>isl_union_pw_aff_subtract_domain_union_set</code>. Similarly for the other pairs of functions.</p>

</li>
<li><p>Application</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_join(
        __isl_take isl_space *left,
        __isl_take isl_space *right);

#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_apply(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_map *bmap);
__isl_give isl_set *isl_set_apply(
        __isl_take isl_set *set,
        __isl_take isl_map *map);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_apply(
        __isl_take isl_union_set *uset,
        __isl_take isl_union_map *umap);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_apply_domain(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_basic_map *isl_basic_map_apply_range(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_map *isl_map_apply_domain(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *isl_map_apply_range(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_apply_domain(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *isl_union_map_apply_range(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);

#include &lt;isl/aff.h&gt;
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_apply_union_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_union_pw_aff *
isl_multi_union_pw_aff_apply_aff(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_aff *aff);
__isl_give isl_union_pw_aff *
isl_multi_union_pw_aff_apply_pw_aff(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_pw_aff *pa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_apply_multi_aff(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_apply_pw_multi_aff(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_pw_multi_aff *pma);</code></pre>

<p>The result of <code>isl_multi_union_pw_aff_apply_aff</code> is defined over the shared domain of the elements of the input. The dimension is required to be greater than zero. The <code>isl_multi_union_pw_aff</code> argument of <code>isl_multi_union_pw_aff_apply_multi_aff</code> is allowed to be zero-dimensional, but only if the range of the <code>isl_multi_aff</code> argument is also zero-dimensional. Similarly for <code>isl_multi_union_pw_aff_apply_pw_multi_aff</code>.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_pw_qpolynomial_fold *
isl_set_apply_pw_qpolynomial_fold(
        __isl_take isl_set *set,
        __isl_take isl_pw_qpolynomial_fold *pwf,
        isl_bool *tight);
__isl_give isl_pw_qpolynomial_fold *
isl_map_apply_pw_qpolynomial_fold(
        __isl_take isl_map *map,
        __isl_take isl_pw_qpolynomial_fold *pwf,
        isl_bool *tight);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_set_apply_union_pw_qpolynomial_fold(
        __isl_take isl_union_set *uset,
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        isl_bool *tight);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_map_apply_union_pw_qpolynomial_fold(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        isl_bool *tight);</code></pre>

<p>The functions taking a map compose the given map with the given piecewise quasipolynomial reduction. That is, compute a bound (of the same type as <code>pwf</code> or <code>upwf</code> itself) over all elements in the intersection of the range of the map and the domain of the piecewise quasipolynomial reduction as a function of an element in the domain of the map. The functions taking a set compute a bound over all elements in the intersection of the set and the domain of the piecewise quasipolynomial reduction.</p>

</li>
<li><p>Preimage</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *
isl_basic_set_preimage_multi_aff(
        __isl_take isl_basic_set *bset,
        __isl_take isl_multi_aff *ma);
__isl_give isl_set *isl_set_preimage_multi_aff(
        __isl_take isl_set *set,
        __isl_take isl_multi_aff *ma);
__isl_give isl_set *isl_set_preimage_pw_multi_aff(
        __isl_take isl_set *set,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_set *isl_set_preimage_multi_pw_aff(
        __isl_take isl_set *set,
        __isl_take isl_multi_pw_aff *mpa);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *
isl_union_set_preimage_multi_aff(
        __isl_take isl_union_set *uset,
        __isl_take isl_multi_aff *ma);
__isl_give isl_union_set *
isl_union_set_preimage_pw_multi_aff(
        __isl_take isl_union_set *uset,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_set *
isl_union_set_preimage_union_pw_multi_aff(
        __isl_take isl_union_set *uset,
        __isl_take isl_union_pw_multi_aff *upma);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *
isl_basic_map_preimage_domain_multi_aff(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_multi_aff *ma);
__isl_give isl_map *isl_map_preimage_domain_multi_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_aff *ma);
__isl_give isl_map *isl_map_preimage_range_multi_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_aff *ma);
__isl_give isl_map *
isl_map_preimage_domain_pw_multi_aff(
        __isl_take isl_map *map,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_map *
isl_map_preimage_range_pw_multi_aff(
        __isl_take isl_map *map,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_map *
isl_map_preimage_domain_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_basic_map *
isl_basic_map_preimage_range_multi_aff(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_multi_aff *ma);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_preimage_domain_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_aff *ma);
__isl_give isl_union_map *
isl_union_map_preimage_range_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_aff *ma);
__isl_give isl_union_map *
isl_union_map_preimage_domain_pw_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_map *
isl_union_map_preimage_range_pw_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_map *
isl_union_map_preimage_domain_union_pw_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_map *
isl_union_map_preimage_range_union_pw_multi_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_pw_multi_aff *upma);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_preimage_domain_wrapped_domain_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);</code></pre>

<p>These functions compute the preimage of the given set or map domain/range under the given function. In other words, the expression is plugged into the set description or into the domain/range of the map or function.</p>

</li>
<li><p>Pullback</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_pullback_aff(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_aff *isl_aff_pullback_multi_aff(
        __isl_take isl_aff *aff,
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_pullback_multi_aff(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_aff *isl_pw_aff_pullback_pw_multi_aff(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_pw_aff *isl_pw_aff_pullback_multi_pw_aff(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_aff *isl_multi_aff_pullback_multi_aff(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_pullback_multi_aff(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_pullback_multi_aff(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_aff *ma);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_pullback_pw_multi_aff(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_pullback_pw_multi_aff(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_pullback_multi_pw_aff(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_union_pw_aff *
isl_union_pw_aff_pullback_union_pw_multi_aff(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_pullback_union_pw_multi_aff(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_pullback_union_pw_multi_aff(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_union_pw_multi_aff *upma);</code></pre>

<p>These functions precompose the first expression by the second function. In other words, the second function is plugged into the first expression.</p>

</li>
<li><p>Locus</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_basic_set *isl_aff_eq_basic_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_eq_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_ne_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_basic_set *isl_aff_le_basic_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_le_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_basic_set *isl_aff_lt_basic_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_lt_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_basic_set *isl_aff_ge_basic_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_ge_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_basic_set *isl_aff_gt_basic_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_aff_gt_set(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_set *isl_pw_aff_eq_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_set *isl_pw_aff_ne_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_set *isl_pw_aff_le_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_set *isl_pw_aff_lt_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_set *isl_pw_aff_ge_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_set *isl_pw_aff_gt_set(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);

__isl_give isl_set *isl_multi_aff_lex_le_set(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_set *isl_multi_aff_lex_lt_set(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_set *isl_multi_aff_lex_ge_set(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_set *isl_multi_aff_lex_gt_set(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);

__isl_give isl_set *isl_pw_aff_list_eq_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);
__isl_give isl_set *isl_pw_aff_list_ne_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);
__isl_give isl_set *isl_pw_aff_list_le_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);
__isl_give isl_set *isl_pw_aff_list_lt_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);
__isl_give isl_set *isl_pw_aff_list_ge_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);
__isl_give isl_set *isl_pw_aff_list_gt_set(
        __isl_take isl_pw_aff_list *list1,
        __isl_take isl_pw_aff_list *list2);</code></pre>

<p>The function <code>isl_aff_ge_basic_set</code> returns a basic set containing those elements in the shared space of <code>aff1</code> and <code>aff2</code> where <code>aff1</code> is greater than or equal to <code>aff2</code>. The function <code>isl_pw_aff_ge_set</code> returns a set containing those elements in the shared domain of <code>pwaff1</code> and <code>pwaff2</code> where <code>pwaff1</code> is greater than or equal to <code>pwaff2</code>. The function <code>isl_multi_aff_lex_le_set</code> returns a set containing those elements in the shared domain space where <code>ma1</code> is lexicographically smaller than or equal to <code>ma2</code>. The functions operating on <code>isl_pw_aff_list</code> apply the corresponding <code>isl_pw_aff</code> function to each pair of elements in the two lists.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_map *isl_pw_aff_eq_map(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_map *isl_pw_aff_le_map(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_map *isl_pw_aff_lt_map(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_map *isl_pw_aff_ge_map(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_map *isl_pw_aff_gt_map(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);

__isl_give isl_map *isl_multi_pw_aff_eq_map(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_map *isl_multi_pw_aff_lex_le_map(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_map *isl_multi_pw_aff_lex_lt_map(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_map *isl_multi_pw_aff_lex_ge_map(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_map *isl_multi_pw_aff_lex_gt_map(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);</code></pre>

<p>These functions return a map between domain elements of the arguments where the function values satisfy the given relation.</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_eq_at_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_map_lex_lt_at_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_map_lex_le_at_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_map_lex_gt_at_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_map *isl_map_lex_ge_at_multi_pw_aff(
        __isl_take isl_map *map,
        __isl_take isl_multi_pw_aff *mpa);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_eq_at_multi_union_pw_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_union_map *
isl_union_map_lex_lt_at_multi_union_pw_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_union_map *
isl_union_map_lex_le_at_multi_union_pw_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_union_map *
isl_union_map_lex_gt_at_multi_union_pw_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_union_map *
isl_union_map_lex_ge_at_multi_union_pw_aff(
        __isl_take isl_union_map *umap,
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>These functions select the subset of elements in the union map that have an equal or lexicographically smaller or greater function value.</p>

</li>
<li><p>Cartesian Product</p>

<pre><code>#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_product(
        __isl_take isl_space *space1,
        __isl_take isl_space *space2);
__isl_give isl_space *isl_space_domain_product(
        __isl_take isl_space *space1,
        __isl_take isl_space *space2);
__isl_give isl_space *isl_space_range_product(
        __isl_take isl_space *space1,
        __isl_take isl_space *space2);</code></pre>

<p>The functions <code>isl_space_product</code>, <code>isl_space_domain_product</code> and <code>isl_space_range_product</code> take pairs or relation spaces and produce a single relations space, where either the domain, the range or both domain and range are wrapped spaces of relations between the domains and/or ranges of the input spaces. If the product is only constructed over the domain or the range then the ranges or the domains of the inputs should be the same. The function <code>isl_space_product</code> also accepts a pair of set spaces, in which case it returns a wrapped space of a relation between the two input spaces.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_product(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_domain_product(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_basic_map *isl_basic_map_range_product(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_basic_map *isl_basic_map_product(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_map *isl_map_domain_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *isl_map_range_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *isl_map_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_product(
        __isl_take isl_union_set *uset1,
        __isl_take isl_union_set *uset2);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_domain_product(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *isl_union_map_range_product(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *isl_union_map_product(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_range_product(
        __isl_take isl_multi_id *mi1,
        __isl_take isl_multi_id *mi2);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_range_product(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *isl_multi_val_product(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_range_product(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_multi_aff *isl_multi_aff_product(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_range_product(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_product(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_range_product(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_product(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_range_product(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_range_product(
        __isl_take isl_multi_union_pw_aff *mupa1,
        __isl_take isl_multi_union_pw_aff *mupa2);</code></pre>

<p>The above functions compute the cross product of the given sets, relations or functions. The domains and ranges of the results are wrapped maps between domains and ranges of the inputs. To obtain a ``flat&#39;&#39; product, use the following functions instead.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_flat_product(
        __isl_take isl_basic_set *bset1,
        __isl_take isl_basic_set *bset2);
__isl_give isl_set *isl_set_flat_product(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_flat_range_product(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_map *isl_map_flat_domain_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_map *isl_map_flat_range_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);
__isl_give isl_basic_map *isl_basic_map_flat_product(
        __isl_take isl_basic_map *bmap1,
        __isl_take isl_basic_map *bmap2);
__isl_give isl_map *isl_map_flat_product(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *
isl_union_map_flat_domain_product(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);
__isl_give isl_union_map *
isl_union_map_flat_range_product(
        __isl_take isl_union_map *umap1,
        __isl_take isl_union_map *umap2);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *
isl_multi_id_flat_range_product(
        __isl_take isl_multi_id *mi1,
        __isl_take isl_multi_id *mi2);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_flat_range_product(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_flat_range_product(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_flat_range_product(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_flat_range_product(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_flat_range_product(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_flat_range_product(
        __isl_take isl_multi_union_pw_aff *mupa1,
        __isl_take isl_multi_union_pw_aff *mupa2);

#include &lt;isl/space.h&gt;
__isl_give isl_space *isl_space_factor_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_factor_range(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_domain_factor_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_domain_factor_range(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_range_factor_domain(
        __isl_take isl_space *space);
__isl_give isl_space *isl_space_range_factor_range(
        __isl_take isl_space *space);</code></pre>

<p>The functions <code>isl_space_range_factor_domain</code> and <code>isl_space_range_factor_range</code> extract the two arguments from the result of a call to <code>isl_space_range_product</code>.</p>

<p>The arguments of a call to a product can be extracted from the result using the following functions.</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_factor_domain(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_factor_range(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_domain_factor_domain(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_domain_factor_range(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_range_factor_domain(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_range_factor_range(
        __isl_take isl_map *map);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_factor_domain(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_factor_range(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *
isl_union_map_domain_factor_domain(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *
isl_union_map_domain_factor_range(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *
isl_union_map_range_factor_domain(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *
isl_union_map_range_factor_range(
        __isl_take isl_union_map *umap);

#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_factor_range(
        __isl_take isl_multi_id *mi);
__isl_give isl_multi_id *
isl_multi_id_range_factor_domain(
        __isl_take isl_multi_id *mi);
__isl_give isl_multi_id *
isl_multi_id_range_factor_range(
        __isl_take isl_multi_id *mi);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_factor_range(
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_val *
isl_multi_val_range_factor_domain(
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_val *
isl_multi_val_range_factor_range(
        __isl_take isl_multi_val *mv);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_factor_range(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_aff *
isl_multi_aff_range_factor_domain(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_aff *
isl_multi_aff_range_factor_range(
        __isl_take isl_multi_aff *ma);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_factor_range(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_range_factor_domain(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_range_factor_range(
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_range_factor_domain(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_range_factor_range(
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_range_factor_domain(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_range_factor_range(
        __isl_take isl_union_pw_multi_aff *upma);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_factor_range(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_range_factor_domain(
        __isl_take isl_multi_union_pw_aff *mupa);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_range_factor_range(
        __isl_take isl_multi_union_pw_aff *mupa);</code></pre>

<p>The splice functions are a generalization of the flat product functions, where the second argument may be inserted at any position inside the first argument rather than being placed at the end. The functions <code>isl_multi_val_factor_range</code>, <code>isl_multi_aff_factor_range</code>, <code>isl_multi_pw_aff_factor_range</code> and <code>isl_multi_union_pw_aff_factor_range</code> take functions that live in a set space.</p>

<pre><code>#include &lt;isl/id.h&gt;
__isl_give isl_multi_id *isl_multi_id_range_splice(
        __isl_take isl_multi_id *mi1, unsigned pos,
        __isl_take isl_multi_id *mi2);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_range_splice(
        __isl_take isl_multi_val *mv1, unsigned pos,
        __isl_take isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_range_splice(
        __isl_take isl_multi_aff *ma1, unsigned pos,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_multi_aff *isl_multi_aff_splice(
        __isl_take isl_multi_aff *ma1,
        unsigned in_pos, unsigned out_pos,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_range_splice(
        __isl_take isl_multi_pw_aff *mpa1, unsigned pos,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_splice(
        __isl_take isl_multi_pw_aff *mpa1,
        unsigned in_pos, unsigned out_pos,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_range_splice(
        __isl_take isl_multi_union_pw_aff *mupa1,
        unsigned pos,
        __isl_take isl_multi_union_pw_aff *mupa2);</code></pre>

</li>
<li><p>Simplification</p>

<p>When applied to a set or relation, the gist operation returns a set or relation that has the same intersection with the context as the input set or relation. Any implicit equality in the intersection is made explicit in the result, while all inequalities that are redundant with respect to the intersection are removed. In case of union sets and relations, the gist operation is performed per space.</p>

<p>When applied to a function, the gist operation applies the set gist operation to each of the cells in the domain of the input piecewise expression. The context is also exploited to simplify the expression associated to each cell.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_basic_set *isl_basic_set_gist(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_set *context);
__isl_give isl_set *isl_set_gist(__isl_take isl_set *set,
        __isl_take isl_set *context);
__isl_give isl_set *isl_set_gist_params(
        __isl_take isl_set *set,
        __isl_take isl_set *context);

#include &lt;isl/map.h&gt;
__isl_give isl_basic_map *isl_basic_map_gist(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_map *context);
__isl_give isl_basic_map *isl_basic_map_gist_domain(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *context);
__isl_give isl_map *isl_map_gist(__isl_take isl_map *map,
        __isl_take isl_map *context);
__isl_give isl_map *isl_map_gist_params(
        __isl_take isl_map *map,
        __isl_take isl_set *context);
__isl_give isl_map *isl_map_gist_domain(
        __isl_take isl_map *map,
        __isl_take isl_set *context);
__isl_give isl_map *isl_map_gist_range(
        __isl_take isl_map *map,
        __isl_take isl_set *context);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set *isl_union_set_gist(
        __isl_take isl_union_set *uset,
        __isl_take isl_union_set *context);
__isl_give isl_union_set *isl_union_set_gist_params(
        __isl_take isl_union_set *uset,
        __isl_take isl_set *set);

#include &lt;isl/union_map.h&gt;
__isl_give isl_union_map *isl_union_map_gist(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_map *context);
__isl_give isl_union_map *isl_union_map_gist_params(
        __isl_take isl_union_map *umap,
        __isl_take isl_set *set);
__isl_give isl_union_map *isl_union_map_gist_domain(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);
__isl_give isl_union_map *isl_union_map_gist_range(
        __isl_take isl_union_map *umap,
        __isl_take isl_union_set *uset);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_gist_params(
        __isl_take isl_aff *aff,
        __isl_take isl_set *context);
__isl_give isl_aff *isl_aff_gist(__isl_take isl_aff *aff,
        __isl_take isl_set *context);
__isl_give isl_multi_aff *isl_multi_aff_gist_params(
        __isl_take isl_multi_aff *maff,
        __isl_take isl_set *context);
__isl_give isl_multi_aff *isl_multi_aff_gist(
        __isl_take isl_multi_aff *maff,
        __isl_take isl_set *context);
__isl_give isl_pw_aff *isl_pw_aff_gist_params(
        __isl_take isl_pw_aff *pwaff,
        __isl_take isl_set *context);
__isl_give isl_pw_aff *isl_pw_aff_gist(
        __isl_take isl_pw_aff *pwaff,
        __isl_take isl_set *context);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_gist_params(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_gist(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_gist_params(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_set *set);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_gist(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_set *set);
__isl_give isl_union_pw_aff *isl_union_pw_aff_gist(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_union_set *context);
__isl_give isl_union_pw_aff *isl_union_pw_aff_gist_params(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_set *context);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_gist_params(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_set *context);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_gist(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_union_set *context);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_gist_params(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_set *context);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_gist(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_union_set *context);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_gist_params(
        __isl_take isl_qpolynomial *qp,
        __isl_take isl_set *context);
__isl_give isl_qpolynomial *isl_qpolynomial_gist(
        __isl_take isl_qpolynomial *qp,
        __isl_take isl_set *context);
__isl_give isl_qpolynomial_fold *
isl_qpolynomial_fold_gist_params(
        __isl_take isl_qpolynomial_fold *fold,
        __isl_take isl_set *context);
__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_gist(
        __isl_take isl_qpolynomial_fold *fold,
        __isl_take isl_set *context);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_gist_params(
        __isl_take isl_pw_qpolynomial *pwqp,
        __isl_take isl_set *context);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_gist(
        __isl_take isl_pw_qpolynomial *pwqp,
        __isl_take isl_set *context);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_gist(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *context);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_gist_params(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_set *context);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_gist_params(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_set *context);
__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_gist(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_union_set *context);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_gist(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_union_set *context);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_gist_params(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_set *context);</code></pre>

</li>
<li><p>Binary Arithmetic Operations</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_set_sum(
        __isl_take isl_set *set1,
        __isl_take isl_set *set2);
#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_map_sum(
        __isl_take isl_map *map1,
        __isl_take isl_map *map2);</code></pre>

<p><code>isl_set_sum</code> computes the Minkowski sum of its two arguments, i.e., the set containing the sums of pairs of elements from <code>set1</code> and <code>set2</code>. The domain of the result of <code>isl_map_sum</code> is the intersection of the domains of its two arguments. The corresponding range elements are the sums of the corresponding range elements in the two arguments.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_add(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *isl_multi_val_sub(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *isl_multi_val_min(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *isl_multi_val_max(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_add(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_multi_aff *isl_multi_aff_add(
        __isl_take isl_multi_aff *maff1,
        __isl_take isl_multi_aff *maff2);
__isl_give isl_pw_aff *isl_pw_aff_add(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_add(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_add(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_union_pw_aff *isl_union_pw_aff_add(
        __isl_take isl_union_pw_aff *upa1,
        __isl_take isl_union_pw_aff *upa2);
__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_add(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_add(
        __isl_take isl_multi_union_pw_aff *mupa1,
        __isl_take isl_multi_union_pw_aff *mupa2);
__isl_give isl_pw_aff *isl_pw_aff_add_constant_val(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_val *v);
__isl_give isl_multi_aff *
isl_multi_aff_add_constant_val(
        __isl_take isl_multi_aff *pa,
        __isl_take isl_val *v);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_add_constant_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_val *v);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_add_constant_multi_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_add_constant_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_val *v);
__isl_give isl_multi_aff *
isl_multi_aff_add_constant_multi_val(
        __isl_take isl_multi_aff *pa,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_add_constant_multi_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_val *mv);
__isl_give isl_pw_aff *isl_pw_aff_min(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_pw_aff *isl_pw_aff_max(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_min(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_max(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_aff *isl_aff_sub(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_multi_aff *isl_multi_aff_sub(
        __isl_take isl_multi_aff *ma1,
        __isl_take isl_multi_aff *ma2);
__isl_give isl_pw_aff *isl_pw_aff_sub(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_sub(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_sub(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_union_pw_aff *isl_union_pw_aff_sub(
        __isl_take isl_union_pw_aff *upa1,
        __isl_take isl_union_pw_aff *upa2);
__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_sub(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_sub(
        __isl_take isl_multi_union_pw_aff *mupa1,
        __isl_take isl_multi_union_pw_aff *mupa2);</code></pre>

<p><code>isl_aff_sub</code> subtracts the second argument from the first.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_add(
        __isl_take isl_qpolynomial *qp1,
        __isl_take isl_qpolynomial *qp2);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_add(
        __isl_take isl_pw_qpolynomial *pwqp1,
        __isl_take isl_pw_qpolynomial *pwqp2);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_add_disjoint(
        __isl_take isl_pw_qpolynomial *pwqp1,
        __isl_take isl_pw_qpolynomial *pwqp2);
__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_add(
        __isl_take isl_pw_qpolynomial_fold *pwf1,
        __isl_take isl_pw_qpolynomial_fold *pwf2);
__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_add(
        __isl_take isl_union_pw_qpolynomial *upwqp1,
        __isl_take isl_union_pw_qpolynomial *upwqp2);
__isl_give isl_qpolynomial *isl_qpolynomial_sub(
        __isl_take isl_qpolynomial *qp1,
        __isl_take isl_qpolynomial *qp2);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_sub(
        __isl_take isl_pw_qpolynomial *pwqp1,
        __isl_take isl_pw_qpolynomial *pwqp2);
__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_sub(
        __isl_take isl_union_pw_qpolynomial *upwqp1,
        __isl_take isl_union_pw_qpolynomial *upwqp2);
__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_fold(
        __isl_take isl_pw_qpolynomial_fold *pwf1,
        __isl_take isl_pw_qpolynomial_fold *pwf2);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_fold(
        __isl_take isl_union_pw_qpolynomial_fold *upwf1,
        __isl_take isl_union_pw_qpolynomial_fold *upwf2);

#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_union_add(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_union_add(
        __isl_take isl_multi_pw_aff *mpa1,
        __isl_take isl_multi_pw_aff *mpa2);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_add(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_union_pw_aff *isl_union_pw_aff_union_add(
        __isl_take isl_union_pw_aff *upa1,
        __isl_take isl_union_pw_aff *upa2);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_union_add(
        __isl_take isl_union_pw_multi_aff *upma1,
        __isl_take isl_union_pw_multi_aff *upma2);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_union_add(
        __isl_take isl_multi_union_pw_aff *mupa1,
        __isl_take isl_multi_union_pw_aff *mupa2);
__isl_give isl_pw_aff *isl_pw_aff_union_min(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_pw_aff *isl_pw_aff_union_max(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);</code></pre>

<p>The function <code>isl_pw_aff_union_max</code> computes a piecewise quasi-affine expression with a domain that is the union of those of <code>pwaff1</code> and <code>pwaff2</code> and such that on each cell, the quasi-affine expression is the maximum of those of <code>pwaff1</code> and <code>pwaff2</code>. If only one of <code>pwaff1</code> or <code>pwaff2</code> is defined on a given cell, then the associated expression is the defined one. This in contrast to the <code>isl_pw_aff_max</code> function, which is only defined on the shared definition domain of the arguments.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_add_val(
        __isl_take isl_multi_val *mv,
        __isl_take isl_val *v);
__isl_give isl_multi_val *isl_multi_val_mod_val(
        __isl_take isl_multi_val *mv,
        __isl_take isl_val *v);
__isl_give isl_multi_val *isl_multi_val_scale_val(
        __isl_take isl_multi_val *mv,
        __isl_take isl_val *v);
__isl_give isl_multi_val *isl_multi_val_scale_down_val(
        __isl_take isl_multi_val *mv,
        __isl_take isl_val *v);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_mod_val(__isl_take isl_aff *aff,
        __isl_take isl_val *mod);
__isl_give isl_pw_aff *isl_pw_aff_mod_val(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_val *mod);
__isl_give isl_union_pw_aff *isl_union_pw_aff_mod_val(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_val *f);
__isl_give isl_aff *isl_aff_scale_val(__isl_take isl_aff *aff,
        __isl_take isl_val *v);
__isl_give isl_multi_aff *isl_multi_aff_scale_val(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_val *v);
__isl_give isl_pw_aff *isl_pw_aff_scale_val(
        __isl_take isl_pw_aff *pa, __isl_take isl_val *v);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_scale_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_val *v);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_scale_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_val *v);
__isl_give isl_union_pw_aff *isl_union_pw_aff_scale_val(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_val *f);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_scale_val(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_val *val);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_scale_val(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_val *v);
__isl_give isl_aff *isl_aff_scale_down_ui(
        __isl_take isl_aff *aff, unsigned f);
__isl_give isl_aff *isl_aff_scale_down_val(
        __isl_take isl_aff *aff, __isl_take isl_val *v);
__isl_give isl_multi_aff *isl_multi_aff_scale_down_val(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_val *v);
__isl_give isl_pw_aff *isl_pw_aff_scale_down_val(
        __isl_take isl_pw_aff *pa,
        __isl_take isl_val *f);
__isl_give isl_multi_pw_aff *isl_multi_pw_aff_scale_down_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_val *v);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_scale_down_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_val *v);
__isl_give isl_union_pw_aff *isl_union_pw_aff_scale_down_val(
        __isl_take isl_union_pw_aff *upa,
        __isl_take isl_val *v);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_scale_down_val(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_val *val);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_scale_down_val(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_val *v);

#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_scale_val(
        __isl_take isl_qpolynomial *qp,
        __isl_take isl_val *v);
__isl_give isl_qpolynomial_fold *
isl_qpolynomial_fold_scale_val(
        __isl_take isl_qpolynomial_fold *fold,
        __isl_take isl_val *v);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_scale_val(
        __isl_take isl_pw_qpolynomial *pwqp,
        __isl_take isl_val *v);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_scale_val(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_val *v);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_scale_val(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_val *v);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_scale_val(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_val *v);
__isl_give isl_qpolynomial *
isl_qpolynomial_scale_down_val(
        __isl_take isl_qpolynomial *qp,
        __isl_take isl_val *v);
__isl_give isl_qpolynomial_fold *
isl_qpolynomial_fold_scale_down_val(
        __isl_take isl_qpolynomial_fold *fold,
        __isl_take isl_val *v);
__isl_give isl_pw_qpolynomial *
isl_pw_qpolynomial_scale_down_val(
        __isl_take isl_pw_qpolynomial *pwqp,
        __isl_take isl_val *v);
__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_fold_scale_down_val(
        __isl_take isl_pw_qpolynomial_fold *pwf,
        __isl_take isl_val *v);
__isl_give isl_union_pw_qpolynomial *
isl_union_pw_qpolynomial_scale_down_val(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        __isl_take isl_val *v);
__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_fold_scale_down_val(
        __isl_take isl_union_pw_qpolynomial_fold *upwf,
        __isl_take isl_val *v);

#include &lt;isl/val.h&gt;
__isl_give isl_multi_val *isl_multi_val_mod_multi_val(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *isl_multi_val_scale_multi_val(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);
__isl_give isl_multi_val *
isl_multi_val_scale_down_multi_val(
        __isl_take isl_multi_val *mv1,
        __isl_take isl_multi_val *mv2);

#include &lt;isl/aff.h&gt;
__isl_give isl_multi_aff *isl_multi_aff_mod_multi_val(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_mod_multi_val(
        __isl_take isl_multi_union_pw_aff *upma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_mod_multi_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_aff *isl_multi_aff_scale_multi_val(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_val *mv);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_scale_multi_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_scale_multi_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_scale_multi_val(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_multi_val *mv);
__isl_give isl_union_pw_multi_aff *
isl_union_pw_multi_aff_scale_multi_val(
        __isl_take isl_union_pw_multi_aff *upma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_aff *
isl_multi_aff_scale_down_multi_val(
        __isl_take isl_multi_aff *ma,
        __isl_take isl_multi_val *mv);
__isl_give isl_pw_multi_aff *
isl_pw_multi_aff_scale_down_multi_val(
        __isl_take isl_pw_multi_aff *pma,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_pw_aff *
isl_multi_pw_aff_scale_down_multi_val(
        __isl_take isl_multi_pw_aff *mpa,
        __isl_take isl_multi_val *mv);
__isl_give isl_multi_union_pw_aff *
isl_multi_union_pw_aff_scale_down_multi_val(
        __isl_take isl_multi_union_pw_aff *mupa,
        __isl_take isl_multi_val *mv);</code></pre>

<p><code>isl_multi_aff_scale_multi_val</code> scales the elements of <code>ma</code> by the corresponding elements of <code>mv</code>.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_aff *isl_aff_mul(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_aff *isl_aff_div(
        __isl_take isl_aff *aff1,
        __isl_take isl_aff *aff2);
__isl_give isl_pw_aff *isl_pw_aff_mul(
        __isl_take isl_pw_aff *pwaff1,
        __isl_take isl_pw_aff *pwaff2);
__isl_give isl_pw_aff *isl_pw_aff_div(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_pw_aff *isl_pw_aff_tdiv_q(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);
__isl_give isl_pw_aff *isl_pw_aff_tdiv_r(
        __isl_take isl_pw_aff *pa1,
        __isl_take isl_pw_aff *pa2);</code></pre>

<p>When multiplying two affine expressions, at least one of the two needs to be a constant. Similarly, when dividing an affine expression by another, the second expression needs to be a constant. <code>isl_pw_aff_tdiv_q</code> computes the quotient of an integer division with rounding towards zero. <code>isl_pw_aff_tdiv_r</code> computes the corresponding remainder.</p>

<pre><code>#include &lt;isl/polynomial.h&gt;
__isl_give isl_qpolynomial *isl_qpolynomial_mul(
        __isl_take isl_qpolynomial *qp1,
        __isl_take isl_qpolynomial *qp2);
__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_mul(
        __isl_take isl_pw_qpolynomial *pwqp1,
        __isl_take isl_pw_qpolynomial *pwqp2);
__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_mul(
        __isl_take isl_union_pw_qpolynomial *upwqp1,
        __isl_take isl_union_pw_qpolynomial *upwqp2);</code></pre>

</li>
</ul>

<h3 id="Lexicographic-Optimization">Lexicographic Optimization</h3>

<p>Given a (basic) set <code>set</code> (or <code>bset</code>) and a zero-dimensional domain <code>dom</code>, the following functions compute a set that contains the lexicographic minimum or maximum of the elements in <code>set</code> (or <code>bset</code>) for those values of the parameters that satisfy <code>dom</code>. If <code>empty</code> is not <code>NULL</code>, then <code>*empty</code> is assigned a set that contains the parameter values in <code>dom</code> for which <code>set</code> (or <code>bset</code>) has no elements. In other words, the union of the parameter values for which the result is non-empty and of <code>*empty</code> is equal to <code>dom</code>.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_basic_set_partial_lexmin(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_set *isl_basic_set_partial_lexmax(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_set *isl_set_partial_lexmin(
        __isl_take isl_set *set, __isl_take isl_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_set *isl_set_partial_lexmax(
        __isl_take isl_set *set, __isl_take isl_set *dom,
        __isl_give isl_set **empty);</code></pre>

<p>Given a (basic) set <code>set</code> (or <code>bset</code>), the following functions simply return a set containing the lexicographic minimum or maximum of the elements in <code>set</code> (or <code>bset</code>). In case of union sets, the optimum is computed per space.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set *isl_basic_set_lexmin(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_basic_set_lexmax(
        __isl_take isl_basic_set *bset);
__isl_give isl_set *isl_set_lexmin(
        __isl_take isl_set *set);
__isl_give isl_set *isl_set_lexmax(
        __isl_take isl_set *set);
__isl_give isl_union_set *isl_union_set_lexmin(
        __isl_take isl_union_set *uset);
__isl_give isl_union_set *isl_union_set_lexmax(
        __isl_take isl_union_set *uset);</code></pre>

<p>Given a (basic) relation <code>map</code> (or <code>bmap</code>) and a domain <code>dom</code>, the following functions compute a relation that maps each element of <code>dom</code> to the single lexicographic minimum or maximum of the elements that are associated to that same element in <code>map</code> (or <code>bmap</code>). If <code>empty</code> is not <code>NULL</code>, then <code>*empty</code> is assigned a set that contains the elements in <code>dom</code> that do not map to any elements in <code>map</code> (or <code>bmap</code>). In other words, the union of the domain of the result and of <code>*empty</code> is equal to <code>dom</code>.</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_basic_map_partial_lexmax(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_map *isl_basic_map_partial_lexmin(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_map *isl_map_partial_lexmax(
        __isl_take isl_map *map, __isl_take isl_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_map *isl_map_partial_lexmin(
        __isl_take isl_map *map, __isl_take isl_set *dom,
        __isl_give isl_set **empty);</code></pre>

<p>Given a (basic) map <code>map</code> (or <code>bmap</code>), the following functions simply return a map mapping each element in the domain of <code>map</code> (or <code>bmap</code>) to the lexicographic minimum or maximum of all elements associated to that element. In case of union relations, the optimum is computed per space.</p>

<pre><code>#include &lt;isl/map.h&gt;
__isl_give isl_map *isl_basic_map_lexmin(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_basic_map_lexmax(
        __isl_take isl_basic_map *bmap);
__isl_give isl_map *isl_map_lexmin(
        __isl_take isl_map *map);
__isl_give isl_map *isl_map_lexmax(
        __isl_take isl_map *map);
__isl_give isl_union_map *isl_union_map_lexmin(
        __isl_take isl_union_map *umap);
__isl_give isl_union_map *isl_union_map_lexmax(
        __isl_take isl_union_map *umap);</code></pre>

<p>The following functions return their result in the form of a piecewise multi-affine expression, but are otherwise equivalent to the corresponding functions returning a basic set or relation.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_pw_multi_aff *
isl_basic_set_partial_lexmin_pw_multi_aff(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_pw_multi_aff *
isl_basic_set_partial_lexmax_pw_multi_aff(
        __isl_take isl_basic_set *bset,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_pw_multi_aff *isl_set_lexmin_pw_multi_aff(
        __isl_take isl_set *set);
__isl_give isl_pw_multi_aff *isl_set_lexmax_pw_multi_aff(
        __isl_take isl_set *set);

#include &lt;isl/map.h&gt;
__isl_give isl_pw_multi_aff *
isl_basic_map_lexmin_pw_multi_aff(
        __isl_take isl_basic_map *bmap);
__isl_give isl_pw_multi_aff *
isl_basic_map_partial_lexmin_pw_multi_aff(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_pw_multi_aff *
isl_basic_map_partial_lexmax_pw_multi_aff(
        __isl_take isl_basic_map *bmap,
        __isl_take isl_basic_set *dom,
        __isl_give isl_set **empty);
__isl_give isl_pw_multi_aff *isl_map_lexmin_pw_multi_aff(
        __isl_take isl_map *map);
__isl_give isl_pw_multi_aff *isl_map_lexmax_pw_multi_aff(
        __isl_take isl_map *map);</code></pre>

<p>The following functions return the lexicographic minimum or maximum on the shared domain of the inputs and the single defined function on those parts of the domain where only a single function is defined.</p>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_lexmin(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);
__isl_give isl_pw_multi_aff *isl_pw_multi_aff_union_lexmax(
        __isl_take isl_pw_multi_aff *pma1,
        __isl_take isl_pw_multi_aff *pma2);</code></pre>

<p>If the input to a lexicographic optimization problem has multiple constraints with the same coefficients for the optimized variables, then, by default, this symmetry is exploited by replacing those constraints by a single constraint with an abstract bound, which is in turn bounded by the corresponding terms in the original constraints. Without this optimization, the solver would typically consider all possible orderings of those original bounds, resulting in a needless decomposition of the domain. However, the optimization can also result in slowdowns since an extra parameter is introduced that may get used in additional integer divisions. The following option determines whether symmetry detection is applied during lexicographic optimization.</p>

<pre><code>#include &lt;isl/options.h&gt;
isl_stat isl_options_set_pip_symmetry(isl_ctx *ctx,
        int val);
int isl_options_get_pip_symmetry(isl_ctx *ctx);</code></pre>

<h2 id="Ternary-Operations">Ternary Operations</h2>

<pre><code>#include &lt;isl/aff.h&gt;
__isl_give isl_pw_aff *isl_pw_aff_cond(
        __isl_take isl_pw_aff *cond,
        __isl_take isl_pw_aff *pwaff_true,
        __isl_take isl_pw_aff *pwaff_false);</code></pre>

<p>The function <code>isl_pw_aff_cond</code> performs a conditional operator and returns an expression that is equal to <code>pwaff_true</code> for elements where <code>cond</code> is non-zero and equal to <code>pwaff_false</code> for elements where <code>cond</code> is zero.</p>

<h2 id="Lists">Lists</h2>

<p>Lists are defined over several element types, including <code>isl_val</code>, <code>isl_id</code>, <code>isl_aff</code>, <code>isl_pw_aff</code>, <code>isl_pw_multi_aff</code>, <code>isl_union_pw_aff</code>, <code>isl_union_pw_multi_aff</code>, <code>isl_qpolynomial</code>, <code>isl_pw_qpolynomial</code>, <code>isl_pw_qpolynomial_fold</code>, <code>isl_constraint</code>, <code>isl_basic_set</code>, <code>isl_set</code>, <code>isl_basic_map</code>, <code>isl_map</code>, <code>isl_union_set</code>, <code>isl_union_map</code>, <code>isl_ast_expr</code> and <code>isl_ast_node</code>. Here we take lists of <code>isl_set</code>s as an example. Lists can be created, copied, modified and freed using the following functions.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_set_list *isl_set_to_list(
        __isl_take isl_set *el);
__isl_give isl_set_list *isl_set_list_from_set(
        __isl_take isl_set *el);
__isl_give isl_set_list *isl_set_list_alloc(
        isl_ctx *ctx, int n);
__isl_give isl_set_list *isl_set_list_copy(
        __isl_keep isl_set_list *list);
__isl_give isl_set_list *isl_set_list_insert(
        __isl_take isl_set_list *list, unsigned pos,
        __isl_take isl_set *el);
__isl_give isl_set_list *isl_set_list_add(
        __isl_take isl_set_list *list,
        __isl_take isl_set *el);
__isl_give isl_set_list *isl_set_list_drop(
        __isl_take isl_set_list *list,
        unsigned first, unsigned n);
__isl_give isl_set_list *isl_set_list_clear(
        __isl_take isl_set_list *list);
__isl_give isl_set_list *isl_set_list_swap(
        __isl_take isl_set_list *list,
        unsigned pos1, unsigned pos2);
__isl_give isl_set_list *isl_set_list_reverse(
        __isl_take isl_set_list *list);
__isl_give isl_set_list *isl_set_list_set_at(
        __isl_take isl_set_list *list, int index,
        __isl_take isl_set *set);
__isl_give isl_set_list *isl_set_list_set_set(
        __isl_take isl_set_list *list, int index,
        __isl_take isl_set *set);
__isl_give isl_set_list *isl_set_list_concat(
        __isl_take isl_set_list *list1,
        __isl_take isl_set_list *list2);
__isl_give isl_set_list *isl_set_list_map(
        __isl_take isl_set_list *list,
        __isl_give isl_set *(*fn)(__isl_take isl_set *el,
                void *user),
        void *user);
__isl_give isl_set_list *isl_set_list_sort(
        __isl_take isl_set_list *list,
        int (*cmp)(__isl_keep isl_set *a,
                __isl_keep isl_set *b, void *user),
        void *user);
__isl_null isl_set_list *isl_set_list_free(
        __isl_take isl_set_list *list);</code></pre>

<p><code>isl_set_list_alloc</code> creates an empty list with an initial capacity for <code>n</code> elements. <code>isl_set_list_insert</code> and <code>isl_set_list_add</code> add elements to a list, increasing its capacity as needed. <code>isl_set_to_list</code> creates a list with a single element. <code>isl_set_list_from_set</code> performs the same operation. <code>isl_set_list_clear</code> removes all elements from a list. <code>isl_set_list_swap</code> swaps the elements at the specified locations. <code>isl_set_list_reverse</code> reverses the elements in the list. <code>isl_set_list_set_set</code> is an alternative name for <code>isl_set_list_set_at</code>.</p>

<p>Lists can be inspected using the following functions.</p>

<pre><code>#include &lt;isl/set.h&gt;
isl_size isl_set_list_size(__isl_keep isl_set_list *list);
isl_size isl_set_list_n_set(__isl_keep isl_set_list *list);
__isl_give isl_set *isl_set_list_get_at(
        __isl_keep isl_set_list *list, int index);
__isl_give isl_set *isl_set_list_get_set(
        __isl_keep isl_set_list *list, int index);
isl_stat isl_set_list_foreach(__isl_keep isl_set_list *list,
        isl_stat (*fn)(__isl_take isl_set *el, void *user),
        void *user);
isl_bool isl_set_list_every(__isl_keep isl_set_list *list,
        isl_bool (*test)(__isl_take isl_set *el,
                void *user),
        void *user);
isl_stat isl_set_list_foreach_scc(
        __isl_keep isl_set_list *list,
        isl_bool (*follows)(__isl_keep isl_set *a,
                __isl_keep isl_set *b, void *user),
        void *follows_user,
        isl_stat (*fn)(__isl_take isl_set_list *scc,
                void *user),
        void *fn_user);</code></pre>

<p><code>isl_set_list_n_set</code> is an alternative name for <code>isl_set_list_size</code>. Similarly, <code>isl_set_list_get_set</code> is an alternative name for <code>isl_set_list_get_at</code>. The function <code>isl_set_list_foreach_scc</code> calls <code>fn</code> on each of the strongly connected components of the graph with as vertices the elements of <code>list</code> and a directed edge from vertex <code>b</code> to vertex <code>a</code> iff <code>follows(a, b)</code> returns <code>isl_bool_true</code>. The callbacks <code>follows</code> and <code>fn</code> should return <code>isl_bool_error</code> or <code>isl_stat_error</code> on error.</p>

<p>Lists can be printed using</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give isl_printer *isl_printer_print_set_list(
        __isl_take isl_printer *p,
        __isl_keep isl_set_list *list);</code></pre>

<p>Alternatively, a string representation can be obtained directly using the following function, which always prints in isl format.</p>

<pre><code>#include &lt;isl/set.h&gt;
__isl_give char *isl_set_list_to_str(
        __isl_keep isl_set_list *list);</code></pre>

<p>An <code>isl_val_list</code>, <code>isl_id_list</code>, <code>isl_aff_list</code>, <code>isl_pw_aff_list</code>, <code>isl_pw_multi_aff_list</code>, <code>isl_union_pw_aff_list</code>, <code>isl_set_list</code>, <code>isl_map_list</code> or <code>isl_union_set_list</code> object can also be read from input using the following functions.</p>

<pre><code>#include &lt;isl/val.h&gt;
__isl_give isl_val_list *isl_val_list_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/id.h&gt;
__isl_give isl_id_list *isl_id_list_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/aff.h&gt;
__isl_give isl_aff_list *
isl_aff_list_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_pw_aff_list *
isl_pw_aff_list_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_pw_multi_aff_list *
isl_pw_multi_aff_list_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_union_pw_aff_list *
isl_union_pw_aff_list_read_from_str(isl_ctx *ctx,
        const char *str);

#include &lt;isl/set.h&gt;
__isl_give isl_set_list *isl_set_list_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/map.h&gt;
__isl_give isl_map_list *isl_map_list_read_from_str(
        isl_ctx *ctx, const char *str);

#include &lt;isl/union_set.h&gt;
__isl_give isl_union_set_list *
isl_union_set_list_read_from_str(isl_ctx *ctx,
        const char *str);</code></pre>

<h2 id="Associative-arrays">Associative arrays</h2>

<p>Associative arrays map isl objects of a specific type to isl objects of some (other) specific type. They are defined for several pairs of types, including (<code>isl_map</code>, <code>isl_basic_set</code>), (<code>isl_id</code>, <code>isl_ast_expr</code>), (<code>isl_id</code>, <code>isl_id</code>) and (<code>isl_id</code>, <code>isl_pw_aff</code>). Here, we take associative arrays that map <code>isl_id</code>s to <code>isl_ast_expr</code>s as an example.</p>

<p>Associative arrays can be created, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
__isl_give isl_id_to_ast_expr *isl_id_to_ast_expr_alloc(
        isl_ctx *ctx, int min_size);
__isl_give isl_id_to_ast_expr *isl_id_to_ast_expr_copy(
        __isl_keep isl_id_to_ast_expr *id2expr);
__isl_null isl_id_to_ast_expr *isl_id_to_ast_expr_free(
        __isl_take isl_id_to_ast_expr *id2expr);</code></pre>

<p>The <code>min_size</code> argument to <code>isl_id_to_ast_expr_alloc</code> can be used to specify the expected size of the associative array. The associative array will be grown automatically as needed.</p>

<p>Associative arrays can be inspected using the following functions.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
__isl_give isl_maybe_isl_ast_expr
isl_id_to_ast_expr_try_get(
        __isl_keep isl_id_to_ast_expr *id2expr,
        __isl_keep isl_id *key);
isl_bool isl_id_to_ast_expr_has(
        __isl_keep isl_id_to_ast_expr *id2expr,
        __isl_keep isl_id *key);
__isl_give isl_ast_expr *isl_id_to_ast_expr_get(
        __isl_keep isl_id_to_ast_expr *id2expr,
        __isl_take isl_id *key);
isl_stat isl_id_to_ast_expr_foreach(
        __isl_keep isl_id_to_ast_expr *id2expr,
        isl_stat (*fn)(__isl_take isl_id *key,
                __isl_take isl_ast_expr *val, void *user),
        void *user);
isl_bool isl_id_to_ast_expr_every(
        __isl_keep isl_id_to_ast_expr *id2expr,
        isl_bool (*test)(__isl_keep isl_id *key,
                __isl_keep isl_ast_expr *val, void *user),
        void *user);</code></pre>

<p>The function <code>isl_id_to_ast_expr_try_get</code> returns a structure containing two elements, <code>valid</code> and <code>value</code>. If there is a value associated to the key, then <code>valid</code> is set to <code>isl_bool_true</code> and <code>value</code> contains a copy of the associated value. Otherwise <code>value</code> is <code>NULL</code> and <code>valid</code> may be <code>isl_bool_error</code> or <code>isl_bool_false</code> depending on whether some error has occurred or there simply is no associated value. The function <code>isl_id_to_ast_expr_has</code> returns the <code>valid</code> field in the structure and the function <code>isl_id_to_ast_expr_get</code> returns the <code>value</code> field.</p>

<p>Associative arrays can be modified using the following functions.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
__isl_give isl_id_to_ast_expr *isl_id_to_ast_expr_set(
        __isl_take isl_id_to_ast_expr *id2expr,
        __isl_take isl_id *key,
        __isl_take isl_ast_expr *val);
__isl_give isl_id_to_ast_expr *isl_id_to_ast_expr_drop(
        __isl_take isl_id_to_ast_expr *id2expr,
        __isl_take isl_id *key);</code></pre>

<p>Associative arrays can be checked for (obvious) equality using the following function.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
isl_bool isl_id_to_ast_expr_is_equal(
        __isl_take isl_id_to_ast_expr *id2expr1,
        __isl_take isl_id_to_ast_expr *id2expr2);</code></pre>

<p>Note that depending on how the keys and values are being compared, for other types of keys and/or values, this function may be called <code>plain_is_equal</code> rather than <code>is_equal</code>.</p>

<p>Associative arrays can be printed using the following functions.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
__isl_give isl_printer *isl_printer_print_id_to_ast_expr(
        __isl_take isl_printer *p,
        __isl_keep isl_id_to_ast_expr *id2expr);
__isl_give char *isl_id_to_ast_expr_to_str(
        __isl_keep isl_id_to_ast_expr *id2expr);</code></pre>

<p>They can be read from input using the following function.</p>

<pre><code>#include &lt;isl/id_to_ast_expr.h&gt;
__isl_give isl_id_to_ast_expr *
isl_id_to_ast_expr_read_from_str(isl_ctx *ctx,
        const char *str);</code></pre>

<h2 id="Vectors">Vectors</h2>

<p>Vectors can be created, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/vec.h&gt;
__isl_give isl_vec *isl_vec_alloc(isl_ctx *ctx,
        unsigned size);
__isl_give isl_vec *isl_vec_zero(isl_ctx *ctx,
        unsigned size);
__isl_give isl_vec *isl_vec_copy(__isl_keep isl_vec *vec);
__isl_null isl_vec *isl_vec_free(__isl_take isl_vec *vec);</code></pre>

<p>Note that the elements of a vector created by <code>isl_vec_alloc</code> may have arbitrary values. A vector created by <code>isl_vec_zero</code> has elements with value zero. The elements can be changed and inspected using the following functions.</p>

<pre><code>isl_size isl_vec_size(__isl_keep isl_vec *vec);
__isl_give isl_val *isl_vec_get_element_val(
        __isl_keep isl_vec *vec, int pos);
__isl_give isl_vec *isl_vec_set_element_si(
        __isl_take isl_vec *vec, int pos, int v);
__isl_give isl_vec *isl_vec_set_element_val(
        __isl_take isl_vec *vec, int pos,
        __isl_take isl_val *v);
__isl_give isl_vec *isl_vec_set_si(__isl_take isl_vec *vec,
        int v);
__isl_give isl_vec *isl_vec_set_val(
        __isl_take isl_vec *vec, __isl_take isl_val *v);
int isl_vec_cmp_element(__isl_keep isl_vec *vec1,
        __isl_keep isl_vec *vec2, int pos);</code></pre>

<p><code>isl_vec_get_element</code> will return a negative value if anything went wrong. In that case, the value of <code>*v</code> is undefined.</p>

<p>The following function can be used to concatenate two vectors.</p>

<pre><code>__isl_give isl_vec *isl_vec_concat(__isl_take isl_vec *vec1,
        __isl_take isl_vec *vec2);</code></pre>

<h2 id="Matrices">Matrices</h2>

<p>Matrices can be created, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/mat.h&gt;
__isl_give isl_mat *isl_mat_alloc(isl_ctx *ctx,
        unsigned n_row, unsigned n_col);
__isl_give isl_mat *isl_mat_copy(__isl_keep isl_mat *mat);
__isl_null isl_mat *isl_mat_free(__isl_take isl_mat *mat);</code></pre>

<p>Note that the elements of a newly created matrix may have arbitrary values. The elements can be changed and inspected using the following functions.</p>

<pre><code>isl_size isl_mat_rows(__isl_keep isl_mat *mat);
isl_size isl_mat_cols(__isl_keep isl_mat *mat);
__isl_give isl_val *isl_mat_get_element_val(
        __isl_keep isl_mat *mat, int row, int col);
__isl_give isl_mat *isl_mat_set_element_si(__isl_take isl_mat *mat,
        int row, int col, int v);
__isl_give isl_mat *isl_mat_set_element_val(
        __isl_take isl_mat *mat, int row, int col,
        __isl_take isl_val *v);</code></pre>

<p>The following function computes the rank of a matrix. The return value may be -1 if some error occurred.</p>

<pre><code>#include &lt;isl/mat.h&gt;
isl_size isl_mat_rank(__isl_keep isl_mat *mat);</code></pre>

<p>The following function can be used to compute the (right) inverse of a matrix, i.e., a matrix such that the product of the original and the inverse (in that order) is a multiple of the identity matrix. The input matrix is assumed to be of full row-rank.</p>

<pre><code>__isl_give isl_mat *isl_mat_right_inverse(__isl_take isl_mat *mat);</code></pre>

<p>The following function can be used to compute the (right) kernel (or null space) of a matrix, i.e., a matrix such that the product of the original and the kernel (in that order) is the zero matrix.</p>

<pre><code>__isl_give isl_mat *isl_mat_right_kernel(__isl_take isl_mat *mat);</code></pre>

<p>The following function computes a basis for the space spanned by the rows of a matrix.</p>

<pre><code>__isl_give isl_mat *isl_mat_row_basis(
        __isl_take isl_mat *mat);</code></pre>

<p>The following function computes rows that extend a basis of <code>mat1</code> to a basis that also covers <code>mat2</code>.</p>

<pre><code>__isl_give isl_mat *isl_mat_row_basis_extension(
        __isl_take isl_mat *mat1,
        __isl_take isl_mat *mat2);</code></pre>

<p>The following function checks whether there is no linear dependence among the combined rows of &quot;mat1&quot; and &quot;mat2&quot; that is not already present in &quot;mat1&quot; or &quot;mat2&quot; individually. If &quot;mat1&quot; and &quot;mat2&quot; have linearly independent rows by themselves, then this means that there is no linear dependence among all rows together.</p>

<pre><code>isl_bool isl_mat_has_linearly_independent_rows(
        __isl_keep isl_mat *mat1,
        __isl_keep isl_mat *mat2);</code></pre>

<h2 id="Bounds-on-Piecewise-Quasipolynomials-and-Piecewise-Quasipolynomial-Reductions">Bounds on Piecewise Quasipolynomials and Piecewise Quasipolynomial Reductions</h2>

<p>The following functions determine an upper or lower bound on a quasipolynomial over its domain.</p>

<pre><code>__isl_give isl_pw_qpolynomial_fold *
isl_pw_qpolynomial_bound(
        __isl_take isl_pw_qpolynomial *pwqp,
        enum isl_fold type, isl_bool *tight);

__isl_give isl_union_pw_qpolynomial_fold *
isl_union_pw_qpolynomial_bound(
        __isl_take isl_union_pw_qpolynomial *upwqp,
        enum isl_fold type, isl_bool *tight);</code></pre>

<p>The <code>type</code> argument may be either <code>isl_fold_min</code> or <code>isl_fold_max</code>. If <code>tight</code> is not <code>NULL</code>, then <code>*tight</code> is set to <code>1</code> is the returned bound is known be tight, i.e., for each value of the parameters there is at least one element in the domain that reaches the bound. If the domain of <code>pwqp</code> is not wrapping, then the bound is computed over all elements in that domain and the result has a purely parametric domain. If the domain of <code>pwqp</code> is wrapping, then the bound is computed over the range of the wrapped relation. The domain of the wrapped relation becomes the domain of the result.</p>

<h2 id="Parametric-Vertex-Enumeration">Parametric Vertex Enumeration</h2>

<p>The parametric vertex enumeration described in this section is mainly intended to be used internally and by the <code>barvinok</code> library.</p>

<pre><code>#include &lt;isl/vertices.h&gt;
__isl_give isl_vertices *isl_basic_set_compute_vertices(
        __isl_keep isl_basic_set *bset);</code></pre>

<p>The function <code>isl_basic_set_compute_vertices</code> performs the actual computation of the parametric vertices and the chamber decomposition and stores the result in an <code>isl_vertices</code> object. This information can be queried by either iterating over all the vertices or iterating over all the chambers or cells and then iterating over all vertices that are active on the chamber.</p>

<pre><code>isl_stat isl_vertices_foreach_vertex(
        __isl_keep isl_vertices *vertices,
        isl_stat (*fn)(__isl_take isl_vertex *vertex,
                void *user), void *user);

isl_stat isl_vertices_foreach_cell(
        __isl_keep isl_vertices *vertices,
        isl_stat (*fn)(__isl_take isl_cell *cell,
                void *user), void *user);
isl_stat isl_cell_foreach_vertex(__isl_keep isl_cell *cell,
        isl_stat (*fn)(__isl_take isl_vertex *vertex,
                void *user), void *user);</code></pre>

<p>Other operations that can be performed on an <code>isl_vertices</code> object are the following.</p>

<pre><code>isl_size isl_vertices_get_n_vertices(
        __isl_keep isl_vertices *vertices);
__isl_null isl_vertices *isl_vertices_free(
        __isl_take isl_vertices *vertices);</code></pre>

<p>Vertices can be inspected and destroyed using the following functions.</p>

<pre><code>isl_size isl_vertex_get_id(__isl_keep isl_vertex *vertex);
__isl_give isl_basic_set *isl_vertex_get_domain(
        __isl_keep isl_vertex *vertex);
__isl_give isl_multi_aff *isl_vertex_get_expr(
        __isl_keep isl_vertex *vertex);
__isl_null isl_vertex *isl_vertex_free(
        __isl_take isl_vertex *vertex);</code></pre>

<p><code>isl_vertex_get_expr</code> returns a multiple quasi-affine expression describing the vertex in terms of the parameters, while <code>isl_vertex_get_domain</code> returns the activity domain of the vertex.</p>

<p>Chambers can be inspected and destroyed using the following functions.</p>

<pre><code>__isl_give isl_basic_set *isl_cell_get_domain(
        __isl_keep isl_cell *cell);
__isl_null isl_cell *isl_cell_free(
        __isl_take isl_cell *cell);</code></pre>

<h1 id="Polyhedral-Compilation-Library">Polyhedral Compilation Library</h1>

<p>This section collects functionality in <code>isl</code> that has been specifically designed for use during polyhedral compilation.</p>

<h2 id="Schedule-Trees">Schedule Trees</h2>

<p>A schedule tree is a structured representation of a schedule, assigning a relative order to a set of domain elements. The relative order expressed by the schedule tree is defined recursively. In particular, the order between two domain elements is determined by the node that is closest to the root that refers to both elements and that orders them apart. Each node in the tree is of one of several types. The root node is always of type <code>isl_schedule_node_domain</code> (or <code>isl_schedule_node_extension</code>) and it describes the (extra) domain elements to which the schedule applies. The other types of nodes are as follows.</p>

<dl>

<dt id="isl_schedule_node_band"><code>isl_schedule_node_band</code></dt>
<dd>

<p>A band of schedule dimensions. Each schedule dimension is represented by a union piecewise quasi-affine expression. If this expression assigns a different value to two domain elements, while all previous schedule dimensions in the same band assign them the same value, then the two domain elements are ordered according to these two different values. Each expression is required to be total in the domain elements that reach the band node.</p>

</dd>
<dt id="isl_schedule_node_expansion"><code>isl_schedule_node_expansion</code></dt>
<dd>

<p>An expansion node maps each of the domain elements that reach the node to one or more domain elements. The image of this mapping forms the set of domain elements that reach the child of the expansion node. The function that maps each of the expanded domain elements to the original domain element from which it was expanded is called the contraction.</p>

</dd>
<dt id="isl_schedule_node_filter"><code>isl_schedule_node_filter</code></dt>
<dd>

<p>A filter node does not impose any ordering, but rather intersects the set of domain elements that the current subtree refers to with a given union set. The subtree of the filter node only refers to domain elements in the intersection. A filter node is typically only used as a child of a sequence or set node.</p>

</dd>
<dt id="isl_schedule_node_leaf"><code>isl_schedule_node_leaf</code></dt>
<dd>

<p>A leaf of the schedule tree. Leaf nodes do not impose any ordering.</p>

</dd>
<dt id="isl_schedule_node_mark"><code>isl_schedule_node_mark</code></dt>
<dd>

<p>A mark node can be used to attach any kind of information to a subtree of the schedule tree.</p>

</dd>
<dt id="isl_schedule_node_sequence"><code>isl_schedule_node_sequence</code></dt>
<dd>

<p>A sequence node has one or more children, each of which is a filter node. The filters on these filter nodes form a partition of the domain elements that the current subtree refers to. If two domain elements appear in distinct filters then the sequence node orders them according to the child positions of the corresponding filter nodes.</p>

</dd>
<dt id="isl_schedule_node_set"><code>isl_schedule_node_set</code></dt>
<dd>

<p>A set node is similar to a sequence node, except that it expresses that domain elements appearing in distinct filters may have any order. The order of the children of a set node is therefore also immaterial.</p>

</dd>
</dl>

<p>The following node types are only supported by the AST generator.</p>

<dl>

<dt id="isl_schedule_node_context"><code>isl_schedule_node_context</code></dt>
<dd>

<p>The context describes constraints on the parameters and the schedule dimensions of outer bands that the AST generator may assume to hold. It is also the only kind of node that may introduce additional parameters. The space of the context is that of the flat product of the outer band nodes. In particular, if there are no outer band nodes, then this space is the unnamed zero-dimensional space. Since a context node references the outer band nodes, any tree containing a context node is considered to be anchored.</p>

</dd>
<dt id="isl_schedule_node_extension"><code>isl_schedule_node_extension</code></dt>
<dd>

<p>An extension node instructs the AST generator to add additional domain elements that need to be scheduled. The additional domain elements are described by the range of the extension map in terms of the outer schedule dimensions, i.e., the flat product of the outer band nodes. Note that domain elements are added whenever the AST generator reaches the extension node, meaning that there are still some active domain elements for which an AST needs to be generated. The conditions under which some domain elements are still active may however not be completely described by the outer AST nodes generated at that point. Since an extension node references the outer band nodes, any tree containing an extension node is considered to be anchored.</p>

<p>An extension node may also appear as the root of a schedule tree, when it is intended to be inserted into another tree using <code>isl_schedule_node_graft_before</code> or <code>isl_schedule_node_graft_after</code>. In this case, the domain of the extension node should correspond to the flat product of the outer band nodes in this other schedule tree at the point where the extension tree will be inserted.</p>

</dd>
<dt id="isl_schedule_node_guard"><code>isl_schedule_node_guard</code></dt>
<dd>

<p>The guard describes constraints on the parameters and the schedule dimensions of outer bands that need to be enforced by the outer nodes in the generated AST. That is, the part of the AST that is generated from descendants of the guard node can assume that these constraints are satisfied. The space of the guard is that of the flat product of the outer band nodes. In particular, if there are no outer band nodes, then this space is the unnamed zero-dimensional space. Since a guard node references the outer band nodes, any tree containing a guard node is considered to be anchored.</p>

</dd>
</dl>

<p>Except for the <code>isl_schedule_node_context</code> nodes, none of the nodes may introduce any parameters that were not already present in the root domain node.</p>

<p>A schedule tree is encapsulated in an <code>isl_schedule</code> object. The simplest such objects, those with a tree consisting of single domain node, can be created using the following functions with either an empty domain or a given domain.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_empty(
        __isl_take isl_space *space);
__isl_give isl_schedule *isl_schedule_from_domain(
        __isl_take isl_union_set *domain);</code></pre>

<p>The function <code>isl_schedule_constraints_compute_schedule</code> described in <a href="#Scheduling">&quot;Scheduling&quot;</a> can also be used to construct schedules.</p>

<p><code>isl_schedule</code> objects may be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_copy(
        __isl_keep isl_schedule *sched);
__isl_null isl_schedule *isl_schedule_free(
        __isl_take isl_schedule *sched);</code></pre>

<p>The following functions checks whether two <code>isl_schedule</code> objects are obviously the same.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
isl_bool isl_schedule_plain_is_equal(
        __isl_keep isl_schedule *schedule1,
        __isl_keep isl_schedule *schedule2);</code></pre>

<p>The domain of the schedule, i.e., the domain described by the root node, can be obtained using the following function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_union_set *isl_schedule_get_domain(
        __isl_keep isl_schedule *schedule);</code></pre>

<p>An extra top-level band node (right underneath the domain node) can be introduced into the schedule using the following function. The schedule tree is assumed not to have any anchored nodes.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *
isl_schedule_insert_partial_schedule(
        __isl_take isl_schedule *schedule,
        __isl_take isl_multi_union_pw_aff *partial);</code></pre>

<p>A top-level context node (right underneath the domain node) can be introduced into the schedule using the following function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_insert_context(
        __isl_take isl_schedule *schedule,
        __isl_take isl_set *context)</code></pre>

<p>A top-level guard node (right underneath the domain node) can be introduced into the schedule using the following function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_insert_guard(
        __isl_take isl_schedule *schedule,
        __isl_take isl_set *guard)</code></pre>

<p>A schedule that combines two schedules either in the given order or in an arbitrary order, i.e., with an <code>isl_schedule_node_sequence</code> or an <code>isl_schedule_node_set</code> node, can be created using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_sequence(
        __isl_take isl_schedule *schedule1,
        __isl_take isl_schedule *schedule2);
__isl_give isl_schedule *isl_schedule_set(
        __isl_take isl_schedule *schedule1,
        __isl_take isl_schedule *schedule2);</code></pre>

<p>The domains of the two input schedules need to be disjoint.</p>

<p>The following function can be used to restrict the domain of a schedule with a domain node as root to be a subset of the given union set. This operation may remove nodes in the tree that have become redundant.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_intersect_domain(
        __isl_take isl_schedule *schedule,
        __isl_take isl_union_set *domain);</code></pre>

<p>The following function can be used to simplify the domain of a schedule with a domain node as root with respect to the given parameter domain.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_gist_domain_params(
        __isl_take isl_schedule *schedule,
        __isl_take isl_set *context);</code></pre>

<p>The following function resets the user pointers on all parameter and tuple identifiers referenced by the nodes of the given schedule.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_reset_user(
        __isl_take isl_schedule *schedule);</code></pre>

<p>The following function aligns the parameters of all nodes in the given schedule to the given space.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_align_params(
        __isl_take isl_schedule *schedule,
        __isl_take isl_space *space);</code></pre>

<p>The following function allows the user to plug in a given function in the iteration domains. The input schedule is not allowed to contain any expansion nodes.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *
isl_schedule_pullback_union_pw_multi_aff(
        __isl_take isl_schedule *schedule,
        __isl_take isl_union_pw_multi_aff *upma);</code></pre>

<p>The following function can be used to plug in the schedule <code>expansion</code> in the leaves of <code>schedule</code>, where <code>contraction</code> describes how the domain elements of <code>expansion</code> map to the domain elements at the original leaves of <code>schedule</code>. The resulting schedule will contain expansion nodes, unless <code>contraction</code> is an identity function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_expand(
        __isl_take isl_schedule *schedule,
        __isl_take isl_union_pw_multi_aff *contraction,
        __isl_take isl_schedule *expansion);</code></pre>

<p>An <code>isl_union_map</code> representation of the schedule can be obtained from an <code>isl_schedule</code> using the following function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_union_map *isl_schedule_get_map(
        __isl_keep isl_schedule *sched);</code></pre>

<p>The resulting relation encodes the same relative ordering as the schedule by mapping the domain elements to a common schedule space. If the schedule_separate_components option is set, then the order of the children of a set node is explicitly encoded in the result. If the tree contains any expansion nodes, then the relation is formulated in terms of the expanded domain elements.</p>

<p>Schedules can be read from input using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_schedule_read_from_file(
        isl_ctx *ctx, FILE *input);
__isl_give isl_schedule *isl_schedule_read_from_str(
        isl_ctx *ctx, const char *str);</code></pre>

<p>A representation of the schedule can be printed using</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_printer *isl_printer_print_schedule(
        __isl_take isl_printer *p,
        __isl_keep isl_schedule *schedule);
__isl_give char *isl_schedule_to_str(
        __isl_keep isl_schedule *schedule);</code></pre>

<p><code>isl_schedule_to_str</code> prints the schedule in flow format.</p>

<p>The schedule tree can be traversed through the use of <code>isl_schedule_node</code> objects that point to a particular position in the schedule tree. Whenever a <code>isl_schedule_node</code> is used to modify a node in the schedule tree, the original schedule tree is left untouched and the modifications are performed to a copy of the tree. The returned <code>isl_schedule_node</code> then points to this modified copy of the tree.</p>

<p>The root of the schedule tree can be obtained using the following function.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule_node *isl_schedule_get_root(
        __isl_keep isl_schedule *schedule);</code></pre>

<p>A pointer to a newly created schedule tree with a single domain node can be created using the following functions.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_from_domain(
        __isl_take isl_union_set *domain);
__isl_give isl_schedule_node *
isl_schedule_node_from_extension(
        __isl_take isl_union_map *extension);</code></pre>

<p><code>isl_schedule_node_from_extension</code> creates a tree with an extension node as root.</p>

<p>Schedule nodes can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_copy(
        __isl_keep isl_schedule_node *node);
__isl_null isl_schedule_node *isl_schedule_node_free(
        __isl_take isl_schedule_node *node);</code></pre>

<p>The following functions can be used to check if two schedule nodes point to the same position in the same schedule.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_bool isl_schedule_node_is_equal(
        __isl_keep isl_schedule_node *node1,
        __isl_keep isl_schedule_node *node2);</code></pre>

<p>The following properties can be obtained from a schedule node.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
enum isl_schedule_node_type isl_schedule_node_get_type(
        __isl_keep isl_schedule_node *node);
enum isl_schedule_node_type
isl_schedule_node_get_parent_type(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule *isl_schedule_node_get_schedule(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The function <code>isl_schedule_node_get_type</code> returns the type of the node, while <code>isl_schedule_node_get_parent_type</code> returns type of the parent of the node, which is required to exist. The function <code>isl_schedule_node_get_schedule</code> returns a copy to the schedule to which the node belongs.</p>

<p>The following functions can be used to move the schedule node to a different position in the tree or to check if such a position exists.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_bool isl_schedule_node_has_parent(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *isl_schedule_node_parent(
        __isl_take isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_grandparent(
        __isl_take isl_schedule_node *node);
__isl_give isl_schedule_node *isl_schedule_node_root(
        __isl_take isl_schedule_node *node);
__isl_give isl_schedule_node *isl_schedule_node_ancestor(
        __isl_take isl_schedule_node *node,
        int generation);
isl_size isl_schedule_node_n_children(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *isl_schedule_node_child(
        __isl_take isl_schedule_node *node, int pos);
isl_bool isl_schedule_node_has_children(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_grandchild(
        __isl_take isl_schedule_node *node,
        int pos1, int pos2);
__isl_give isl_schedule_node *isl_schedule_node_first_child(
        __isl_take isl_schedule_node *node);
isl_bool isl_schedule_node_has_previous_sibling(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_previous_sibling(
        __isl_take isl_schedule_node *node);
isl_bool isl_schedule_node_has_next_sibling(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_next_sibling(
        __isl_take isl_schedule_node *node);</code></pre>

<p>For <code>isl_schedule_node_ancestor</code>, the ancestor of generation 0 is the node itself, the ancestor of generation 1 is its parent and so on.</p>

<p>It is also possible to query the number of ancestors of a node, the position of the current node within the children of its parent, the position of the subtree containing a node within the children of an ancestor or to obtain a copy of a given child without destroying the current node. Given two nodes that point to the same schedule, their closest shared ancestor can be obtained using <code>isl_schedule_node_get_shared_ancestor</code>.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_size isl_schedule_node_get_tree_depth(
        __isl_keep isl_schedule_node *node);
isl_size isl_schedule_node_get_child_position(
        __isl_keep isl_schedule_node *node);
isl_size isl_schedule_node_get_ancestor_child_position(
        __isl_keep isl_schedule_node *node,
        __isl_keep isl_schedule_node *ancestor);
__isl_give isl_schedule_node *isl_schedule_node_get_child(
        __isl_keep isl_schedule_node *node, int pos);
__isl_give isl_schedule_node *
isl_schedule_node_get_shared_ancestor(
        __isl_keep isl_schedule_node *node1,
        __isl_keep isl_schedule_node *node2);</code></pre>

<p>All nodes in a schedule tree or all descendants of a specific node (including the node) can be visited in depth-first pre-order using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
isl_stat isl_schedule_foreach_schedule_node_top_down(
        __isl_keep isl_schedule *sched,
        isl_bool (*fn)(__isl_keep isl_schedule_node *node,
                void *user), void *user);

#include &lt;isl/schedule_node.h&gt;
isl_stat isl_schedule_node_foreach_descendant_top_down(
        __isl_keep isl_schedule_node *node,
        isl_bool (*fn)(__isl_keep isl_schedule_node *node,
                void *user), void *user);</code></pre>

<p>The callback function is slightly different from the usual callbacks in that it not only indicates success (non-negative result) or failure (negative result), but also indicates whether the children of the given node should be visited. In particular, if the callback returns a positive value, then the children are visited, but if the callback returns zero, then the children are not visited.</p>

<p>The following functions checks whether all descendants of a specific node (including the node itself) satisfy a user-specified test.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_bool isl_schedule_node_every_descendant(
        __isl_keep isl_schedule_node *node,
        isl_bool (*test)(__isl_keep isl_schedule_node *node,
                void *user), void *user)</code></pre>

<p>The ancestors of a node in a schedule tree can be visited from the root down to and including the parent of the node using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_stat isl_schedule_node_foreach_ancestor_top_down(
        __isl_keep isl_schedule_node *node,
        isl_stat (*fn)(__isl_keep isl_schedule_node *node,
                void *user), void *user);</code></pre>

<p>The following functions allows for a depth-first post-order traversal of the nodes in a schedule tree or of the descendants of a specific node (including the node itself), where the user callback is allowed to modify the visited node.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *
isl_schedule_map_schedule_node_bottom_up(
        __isl_take isl_schedule *schedule,
        __isl_give isl_schedule_node *(*fn)(
                __isl_take isl_schedule_node *node,
                void *user), void *user);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_map_descendant_bottom_up(
        __isl_take isl_schedule_node *node,
        __isl_give isl_schedule_node *(*fn)(
                __isl_take isl_schedule_node *node,
                void *user), void *user);</code></pre>

<p>The traversal continues from the node returned by the callback function. It is the responsibility of the user to ensure that this does not lead to an infinite loop. It is safest to always return a pointer to the same position (same ancestors and child positions) as the input node.</p>

<p>The following function removes a node (along with its descendants) from a schedule tree and returns a pointer to the leaf at the same position in the updated tree. It is not allowed to remove the root of a schedule tree or a child of a set or sequence node.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_cut(
        __isl_take isl_schedule_node *node);</code></pre>

<p>The following function removes a single node from a schedule tree and returns a pointer to the child of the node, now located at the position of the original node or to a leaf node at that position if there was no child. It is not allowed to remove the root of a schedule tree, a set or sequence node, a child of a set or sequence node or a band node with an anchored subtree.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_delete(
        __isl_take isl_schedule_node *node);</code></pre>

<p>Most nodes in a schedule tree only contain local information. In some cases, however, a node may also refer to the schedule dimensions of its outer band nodes. This means that the position of the node within the tree should not be changed, or at least that no changes are performed to the outer band nodes. The following function can be used to test whether the subtree rooted at a given node contains any such nodes.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_bool isl_schedule_node_is_subtree_anchored(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The following function resets the user pointers on all parameter and tuple identifiers referenced by the given schedule node.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_reset_user(
        __isl_take isl_schedule_node *node);</code></pre>

<p>The following function aligns the parameters of the given schedule node to the given space.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_align_params(
        __isl_take isl_schedule_node *node,
        __isl_take isl_space *space);</code></pre>

<p>Several node types have their own functions for querying (and in some cases setting) some node type specific properties.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_space *isl_schedule_node_band_get_space(
        __isl_keep isl_schedule_node *node);
__isl_give isl_multi_union_pw_aff *
isl_schedule_node_band_get_partial_schedule(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_map *
isl_schedule_node_band_get_partial_schedule_union_map(
        __isl_keep isl_schedule_node *node);
isl_size isl_schedule_node_band_n_member(
        __isl_keep isl_schedule_node *node);
isl_bool isl_schedule_node_band_member_get_coincident(
        __isl_keep isl_schedule_node *node, int pos);
__isl_give isl_schedule_node *
isl_schedule_node_band_member_set_coincident(
        __isl_take isl_schedule_node *node, int pos,
        int coincident);
isl_bool isl_schedule_node_band_get_permutable(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_band_set_permutable(
        __isl_take isl_schedule_node *node, int permutable);
enum isl_ast_loop_type
isl_schedule_node_band_member_get_ast_loop_type(
        __isl_keep isl_schedule_node *node, int pos);
__isl_give isl_schedule_node *
isl_schedule_node_band_member_set_ast_loop_type(
        __isl_take isl_schedule_node *node, int pos,
        enum isl_ast_loop_type type);
enum isl_ast_loop_type
isl_schedule_node_band_member_get_isolate_ast_loop_type(
        __isl_keep isl_schedule_node *node, int pos);
__isl_give isl_schedule_node *
isl_schedule_node_band_member_set_isolate_ast_loop_type(
        __isl_take isl_schedule_node *node, int pos,
        enum isl_ast_loop_type type);
__isl_give isl_union_set *
isl_schedule_node_band_get_ast_build_options(
        __isl_keep isl_schedule_node *node);
__isl_give isl_schedule_node *
isl_schedule_node_band_set_ast_build_options(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set *options);
__isl_give isl_set *
isl_schedule_node_band_get_ast_isolate_option(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The function <code>isl_schedule_node_band_get_space</code> returns the space of the partial schedule of the band. The function <code>isl_schedule_node_band_get_partial_schedule_union_map</code> returns a representation of the partial schedule of the band node in the form of an <code>isl_union_map</code>. The coincident and permutable properties are set by <code>isl_schedule_constraints_compute_schedule</code> on the schedule tree it produces. A scheduling dimension is considered to be ``coincident&#39;&#39; if it satisfies the coincidence constraints within its band. That is, if the dependence distances of the coincidence constraints are all zero in that direction (for fixed iterations of outer bands). A band is marked permutable if it was produced using the Pluto-like scheduler. Note that the scheduler may have to resort to a Feautrier style scheduling step even if the default scheduler is used. An <code>isl_ast_loop_type</code> is one of <code>isl_ast_loop_default</code>, <code>isl_ast_loop_atomic</code>, <code>isl_ast_loop_unroll</code> or <code>isl_ast_loop_separate</code>. For the meaning of these loop AST generation types and the difference between the regular loop AST generation type and the isolate loop AST generation type, see <a href="#AST-Generation-Options-Schedule-Tree">&quot;AST Generation Options (Schedule Tree)&quot;</a>. The functions <code>isl_schedule_node_band_member_get_ast_loop_type</code> and <code>isl_schedule_node_band_member_get_isolate_ast_loop_type</code> may return <code>isl_ast_loop_error</code> if an error occurs. The AST build options govern how an AST is generated for the individual schedule dimensions during AST generation. See <a href="#AST-Generation-Options-Schedule-Tree">&quot;AST Generation Options (Schedule Tree)&quot;</a>. The isolate option for the given node can be extracted from these AST build options using the function <code>isl_schedule_node_band_get_ast_isolate_option</code>.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_set *
isl_schedule_node_context_get_context(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_set *
isl_schedule_node_domain_get_domain(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_map *
isl_schedule_node_expansion_get_expansion(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_pw_multi_aff *
isl_schedule_node_expansion_get_contraction(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_map *
isl_schedule_node_extension_get_extension(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_set *
isl_schedule_node_filter_get_filter(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_set *isl_schedule_node_guard_get_guard(
        __isl_keep isl_schedule_node *node);

#include &lt;isl/schedule_node.h&gt;
__isl_give isl_id *isl_schedule_node_mark_get_id(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The following functions can be used to obtain an <code>isl_multi_union_pw_aff</code>, an <code>isl_union_pw_multi_aff</code> or <code>isl_union_map</code> representation of partial schedules related to the node.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_multi_union_pw_aff *
isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_pw_multi_aff *
isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_map *
isl_schedule_node_get_prefix_schedule_union_map(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_map *
isl_schedule_node_get_prefix_schedule_relation(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_map *
isl_schedule_node_get_subtree_schedule_union_map(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>In particular, the functions <code>isl_schedule_node_get_prefix_schedule_multi_union_pw_aff</code>, <code>isl_schedule_node_get_prefix_schedule_union_pw_multi_aff</code> and <code>isl_schedule_node_get_prefix_schedule_union_map</code> return a relative ordering on the domain elements that reach the given node determined by its ancestors. The function <code>isl_schedule_node_get_prefix_schedule_relation</code> additionally includes the domain constraints in the result. The function <code>isl_schedule_node_get_subtree_schedule_union_map</code> returns a representation of the partial schedule defined by the subtree rooted at the given node. If the tree contains any expansion nodes, then the subtree schedule is formulated in terms of the expanded domain elements. The tree passed to functions returning a prefix schedule may only contain extension nodes if these would not affect the result of these functions. That is, if one of the ancestors is an extension node, then all of the domain elements that were added by the extension node need to have been filtered out by filter nodes between the extension node and the input node. The tree passed to <code>isl_schedule_node_get_subtree_schedule_union_map</code> may not contain in extension nodes in the selected subtree.</p>

<p>The expansion/contraction defined by an entire subtree, combining the expansions/contractions on the expansion nodes in the subtree, can be obtained using the following functions.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_map *
isl_schedule_node_get_subtree_expansion(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_pw_multi_aff *
isl_schedule_node_get_subtree_contraction(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The total number of outer band members of given node, i.e., the shared output dimension of the maps in the result of <code>isl_schedule_node_get_prefix_schedule_union_map</code> can be obtained using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
isl_size isl_schedule_node_get_schedule_depth(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The following functions return the elements that reach the given node or the union of universes in the spaces that contain these elements.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_union_set *
isl_schedule_node_get_domain(
        __isl_keep isl_schedule_node *node);
__isl_give isl_union_set *
isl_schedule_node_get_universe_domain(
        __isl_keep isl_schedule_node *node);</code></pre>

<p>The input tree of <code>isl_schedule_node_get_domain</code> may only contain extension nodes if these would not affect the result of this function. That is, if one of the ancestors is an extension node, then all of the domain elements that were added by the extension node need to have been filtered out by filter nodes between the extension node and the input node.</p>

<p>The following functions can be used to introduce additional nodes in the schedule tree. The new node is introduced at the point in the tree where the <code>isl_schedule_node</code> points to and the results points to the new node.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_partial_schedule(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_union_pw_aff *schedule);</code></pre>

<p>This function inserts a new band node with (the greatest integer part of) the given partial schedule. The subtree rooted at the given node is assumed not to have any anchored nodes.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_context(
        __isl_take isl_schedule_node *node,
        __isl_take isl_set *context);</code></pre>

<p>This function inserts a new context node with the given context constraints.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_filter(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set *filter);</code></pre>

<p>This function inserts a new filter node with the given filter. If the original node already pointed to a filter node, then the two filter nodes are merged into one.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_guard(
        __isl_take isl_schedule_node *node,
        __isl_take isl_set *guard);</code></pre>

<p>This function inserts a new guard node with the given guard constraints.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_mark(
        __isl_take isl_schedule_node *node,
        __isl_take isl_id *mark);</code></pre>

<p>This function inserts a new mark node with the give mark identifier.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_insert_sequence(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set_list *filters);
__isl_give isl_schedule_node *
isl_schedule_node_insert_set(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set_list *filters);</code></pre>

<p>These functions insert a new sequence or set node with the given filters as children.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_group(
        __isl_take isl_schedule_node *node,
        __isl_take isl_id *group_id);</code></pre>

<p>This function introduces an expansion node in between the current node and its parent that expands instances of a space with tuple identifier <code>group_id</code> to the original domain elements that reach the node. The group instances are identified by the prefix schedule of those domain elements. The ancestors of the node are adjusted to refer to the group instances instead of the original domain elements. The return value points to the same node in the updated schedule tree as the input node, i.e., to the child of the newly introduced expansion node. Grouping instances of different statements ensures that they will be treated as a single statement by the AST generator up to the point of the expansion node.</p>

<p>The following functions can be used to flatten a nested sequence.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_sequence_splice_child(
        __isl_take isl_schedule_node *node, int pos);
__isl_give isl_schedule_node *
isl_schedule_node_sequence_splice_children(
        __isl_take isl_schedule_node *node);</code></pre>

<p>That is, given a sequence node <code>node</code> that has another sequence node in its child at position <code>pos</code> (in particular, the child of that filter node is a sequence node), the function <code>isl_schedule_node_sequence_splice_child</code> attaches the children of that other sequence node as children of <code>node</code>, replacing the original child at position <code>pos</code>. <code>isl_schedule_node_sequence_splice_children</code> does this for all such children.</p>

<p>The partial schedule of a band node can be scaled (down) or reduced using the following functions.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_band_scale(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_val *mv);
__isl_give isl_schedule_node *
isl_schedule_node_band_scale_down(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_val *mv);
__isl_give isl_schedule_node *
isl_schedule_node_band_mod(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_val *mv);</code></pre>

<p>The spaces of the two arguments need to match. After scaling, the partial schedule is replaced by its greatest integer part to ensure that the schedule remains integral.</p>

<p>The partial schedule of a band node can be shifted by an <code>isl_multi_union_pw_aff</code> with a domain that is a superset of the domain of the partial schedule using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_band_shift(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_union_pw_aff *shift);</code></pre>

<p>A band node can be tiled using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_band_tile(
        __isl_take isl_schedule_node *node,
        __isl_take isl_multi_val *sizes);

isl_stat isl_options_set_tile_scale_tile_loops(isl_ctx *ctx,
        int val);
int isl_options_get_tile_scale_tile_loops(isl_ctx *ctx);
isl_stat isl_options_set_tile_shift_point_loops(isl_ctx *ctx,
        int val);
int isl_options_get_tile_shift_point_loops(isl_ctx *ctx);</code></pre>

<p>The <code>isl_schedule_node_band_tile</code> function tiles the band using the given tile sizes inside its schedule. A new child band node is created to represent the point loops and it is inserted between the modified band and its children. The subtree rooted at the given node is assumed not to have any anchored nodes. The <code>tile_scale_tile_loops</code> option specifies whether the tile loops iterators should be scaled by the tile sizes. If the <code>tile_shift_point_loops</code> option is set, then the point loops are shifted to start at zero.</p>

<p>A band node can be split into two nested band nodes using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_band_split(
        __isl_take isl_schedule_node *node, int pos);</code></pre>

<p>The resulting outer band node contains the first <code>pos</code> dimensions of the schedule of <code>node</code> while the inner band contains the remaining dimensions. The schedules of the two band nodes live in anonymous spaces. The loop AST generation type options and the isolate option are split over the two band nodes.</p>

<p>A band node can be moved down to the leaves of the subtree rooted at the band node using the following function.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *isl_schedule_node_band_sink(
        __isl_take isl_schedule_node *node);</code></pre>

<p>The subtree rooted at the given node is assumed not to have any anchored nodes. The result points to the node in the resulting tree that is in the same position as the node pointed to by <code>node</code> in the original tree.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_order_before(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set *filter);
__isl_give isl_schedule_node *
isl_schedule_node_order_after(
        __isl_take isl_schedule_node *node,
        __isl_take isl_union_set *filter);</code></pre>

<p>These functions split the domain elements that reach <code>node</code> into those that satisfy <code>filter</code> and those that do not and arranges for the elements that do satisfy the filter to be executed before (in case of <code>isl_schedule_node_order_before</code>) or after (in case of <code>isl_schedule_node_order_after</code>) those that do not. The order is imposed by a sequence node, possibly reusing the grandparent of <code>node</code> on two copies of the subtree attached to the original <code>node</code>. Both copies are simplified with respect to their filter.</p>

<p>Return a pointer to the copy of the subtree that does not satisfy <code>filter</code>. If there is no such copy (because all reaching domain elements satisfy the filter), then return the original pointer.</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_schedule_node *
isl_schedule_node_graft_before(
        __isl_take isl_schedule_node *node,
        __isl_take isl_schedule_node *graft);
__isl_give isl_schedule_node *
isl_schedule_node_graft_after(
        __isl_take isl_schedule_node *node,
        __isl_take isl_schedule_node *graft);</code></pre>

<p>This function inserts the <code>graft</code> tree into the tree containing <code>node</code> such that it is executed before (in case of <code>isl_schedule_node_graft_before</code>) or after (in case of <code>isl_schedule_node_graft_after</code>) <code>node</code>. The root node of <code>graft</code> should be an extension node where the domain of the extension is the flat product of all outer band nodes of <code>node</code>. The root node may also be a domain node. The elements of the domain or the range of the extension may not intersect with the domain elements that reach &quot;node&quot;. The schedule tree of <code>graft</code> may not be anchored.</p>

<p>The schedule tree of <code>node</code> is modified to include an extension node corresponding to the root node of <code>graft</code> as a child of the original parent of <code>node</code>. The original node that <code>node</code> points to and the child of the root node of <code>graft</code> are attached to this extension node through a sequence, with appropriate filters and with the child of <code>graft</code> appearing before or after the original <code>node</code>.</p>

<p>If <code>node</code> already appears inside a sequence that is the child of an extension node and if the spaces of the new domain elements do not overlap with those of the original domain elements, then that extension node is extended with the new extension rather than introducing a new segment of extension and sequence nodes.</p>

<p>Return a pointer to the same node in the modified tree that <code>node</code> pointed to in the original tree.</p>

<p>A representation of the schedule node can be printed using</p>

<pre><code>#include &lt;isl/schedule_node.h&gt;
__isl_give isl_printer *isl_printer_print_schedule_node(
        __isl_take isl_printer *p,
        __isl_keep isl_schedule_node *node);
__isl_give char *isl_schedule_node_to_str(
        __isl_keep isl_schedule_node *node);</code></pre>

<p><code>isl_schedule_node_to_str</code> prints the schedule node in block format.</p>

<h2 id="Dependence-Analysis">Dependence Analysis</h2>

<p><code>isl</code> contains specialized functionality for performing array dataflow analysis. That is, given a <i>sink</i> access relation, a collection of possible <i>source</i> accesses and a collection of <i>kill</i> accesses, <code>isl</code> can compute relations that describe for each iteration of the sink access, which iterations of which of the source access relations may have accessed the same data element before the given iteration of the sink access without any intermediate kill of that data element. The resulting dependence relations map source iterations to either the corresponding sink iterations or pairs of corresponding sink iterations and accessed data elements. To compute standard flow dependences, the sink should be a read, while the sources should be writes. If no kills are specified, then memory based dependence analysis is performed. If, on the other hand, all sources are also kills, then value based dependence analysis is performed. If any of the source accesses are marked as being <i>must</i> accesses, then they are also treated as kills. Furthermore, the specification of must-sources results in the computation of must-dependences. Only dependences originating in a must access not coscheduled with any other access to the same element and without any may accesses between the must access and the sink access are considered to be must dependences.</p>

<h3 id="High-level-Interface">High-level Interface</h3>

<p>A high-level interface to dependence analysis is provided by the following function.</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_union_flow *
isl_union_access_info_compute_flow(
        __isl_take isl_union_access_info *access);</code></pre>

<p>The input <code>isl_union_access_info</code> object describes the sink access relations, the source access relations and a schedule, while the output <code>isl_union_flow</code> object describes the resulting dependence relations and the subsets of the sink relations for which no source was found.</p>

<p>An <code>isl_union_access_info</code> is created, modified, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_union_access_info *
isl_union_access_info_from_sink(
        __isl_take isl_union_map *sink);
__isl_give isl_union_access_info *
isl_union_access_info_set_kill(
        __isl_take isl_union_access_info *access,
        __isl_take isl_union_map *kill);
__isl_give isl_union_access_info *
isl_union_access_info_set_may_source(
        __isl_take isl_union_access_info *access,
        __isl_take isl_union_map *may_source);
__isl_give isl_union_access_info *
isl_union_access_info_set_must_source(
        __isl_take isl_union_access_info *access,
        __isl_take isl_union_map *must_source);
__isl_give isl_union_access_info *
isl_union_access_info_set_schedule(
        __isl_take isl_union_access_info *access,
        __isl_take isl_schedule *schedule);
__isl_give isl_union_access_info *
isl_union_access_info_set_schedule_map(
        __isl_take isl_union_access_info *access,
        __isl_take isl_union_map *schedule_map);
__isl_give isl_union_access_info *
isl_union_access_info_copy(
        __isl_keep isl_union_access_info *access);
__isl_null isl_union_access_info *
isl_union_access_info_free(
        __isl_take isl_union_access_info *access);</code></pre>

<p>The may sources set by <code>isl_union_access_info_set_may_source</code> do not need to include the must sources set by <code>isl_union_access_info_set_must_source</code> as a subset. The kills set by <code>isl_union_access_info_set_kill</code> may overlap with the may-sources and/or must-sources. The user is free not to call one (or more) of these functions, in which case the corresponding set is kept to its empty default. Similarly, the default schedule initialized by <code>isl_union_access_info_from_sink</code> is empty. The current schedule is determined by the last call to either <code>isl_union_access_info_set_schedule</code> or <code>isl_union_access_info_set_schedule_map</code>. The domain of the schedule corresponds to the domains of the access relations. In particular, the domains of the access relations are effectively intersected with the domain of the schedule and only the resulting accesses are considered by the dependence analysis.</p>

<p>An <code>isl_union_access_info</code> object can be read from input using the following function.</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_union_access_info *
isl_union_access_info_read_from_file(isl_ctx *ctx,
        FILE *input);</code></pre>

<p>A representation of the information contained in an object of type <code>isl_union_access_info</code> can be obtained using</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_printer *
isl_printer_print_union_access_info(
        __isl_take isl_printer *p,
        __isl_keep isl_union_access_info *access);
__isl_give char *isl_union_access_info_to_str(
        __isl_keep isl_union_access_info *access);</code></pre>

<p><code>isl_union_access_info_to_str</code> prints the information in flow format.</p>

<p>The output of <code>isl_union_access_info_compute_flow</code> can be examined, copied, and freed using the following functions.</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_union_map *isl_union_flow_get_must_dependence(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_map *isl_union_flow_get_may_dependence(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_map *
isl_union_flow_get_full_must_dependence(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_map *
isl_union_flow_get_full_may_dependence(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_map *isl_union_flow_get_must_no_source(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_map *isl_union_flow_get_may_no_source(
        __isl_keep isl_union_flow *flow);
__isl_give isl_union_flow *isl_union_flow_copy(
        __isl_keep isl_union_flow *flow);
__isl_null isl_union_flow *isl_union_flow_free(
        __isl_take isl_union_flow *flow);</code></pre>

<p>The relation returned by <code>isl_union_flow_get_must_dependence</code> relates domain elements of must sources to domain elements of the sink. The relation returned by <code>isl_union_flow_get_may_dependence</code> relates domain elements of must or may sources to domain elements of the sink and includes the previous relation as a subset. The relation returned by <code>isl_union_flow_get_full_must_dependence</code> relates domain elements of must sources to pairs of domain elements of the sink and accessed data elements. The relation returned by <code>isl_union_flow_get_full_may_dependence</code> relates domain elements of must or may sources to pairs of domain elements of the sink and accessed data elements. This relation includes the previous relation as a subset. The relation returned by <code>isl_union_flow_get_must_no_source</code> is the subset of the sink relation for which no dependences have been found. The relation returned by <code>isl_union_flow_get_may_no_source</code> is the subset of the sink relation for which no definite dependences have been found. That is, it contains those sink access that do not contribute to any of the elements in the relation returned by <code>isl_union_flow_get_must_dependence</code>.</p>

<p>A representation of the information contained in an object of type <code>isl_union_flow</code> can be obtained using</p>

<pre><code>#include &lt;isl/flow.h&gt;
__isl_give isl_printer *isl_printer_print_union_flow(
        __isl_take isl_printer *p,
        __isl_keep isl_union_flow *flow);
__isl_give char *isl_union_flow_to_str(
        __isl_keep isl_union_flow *flow);</code></pre>

<p><code>isl_union_flow_to_str</code> prints the information in flow format.</p>

<h3 id="Low-level-Interface">Low-level Interface</h3>

<p>A lower-level interface is provided by the following functions.</p>

<pre><code>#include &lt;isl/flow.h&gt;

typedef int (*isl_access_level_before)(void *first, void *second);

__isl_give isl_access_info *isl_access_info_alloc(
        __isl_take isl_map *sink,
        void *sink_user, isl_access_level_before fn,
        int max_source);
__isl_give isl_access_info *isl_access_info_add_source(
        __isl_take isl_access_info *acc,
        __isl_take isl_map *source, int must,
        void *source_user);
__isl_null isl_access_info *isl_access_info_free(
        __isl_take isl_access_info *acc);

__isl_give isl_flow *isl_access_info_compute_flow(
        __isl_take isl_access_info *acc);

isl_stat isl_flow_foreach(__isl_keep isl_flow *deps,
        isl_stat (*fn)(__isl_take isl_map *dep, int must,
                  void *dep_user, void *user),
        void *user);
__isl_give isl_map *isl_flow_get_no_source(
        __isl_keep isl_flow *deps, int must);
__isl_null isl_flow *isl_flow_free(
        __isl_take isl_flow *deps);</code></pre>

<p>The function <code>isl_access_info_compute_flow</code> performs the actual dependence analysis. The other functions are used to construct the input for this function or to read off the output.</p>

<p>The input is collected in an <code>isl_access_info</code>, which can be created through a call to <code>isl_access_info_alloc</code>. The arguments to this functions are the sink access relation <code>sink</code>, a token <code>sink_user</code> used to identify the sink access to the user, a callback function for specifying the relative order of source and sink accesses, and the number of source access relations that will be added.</p>

<p>The callback function has type <code>int (*)(void *first, void *second)</code>. The function is called with two user supplied tokens identifying either a source or the sink and it should return the shared nesting level and the relative order of the two accesses. In particular, let <i>n</i> be the number of loops shared by the two accesses. If <code>first</code> precedes <code>second</code> textually, then the function should return <i>2 * n + 1</i>; otherwise, it should return <i>2 * n</i>. The low-level interface assumes that no sources are coscheduled. If the information returned by the callback does not allow the relative order to be determined, then one of the sources is arbitrarily taken to be executed after the other(s).</p>

<p>The sources can be added to the <code>isl_access_info</code> object by performing (at most) <code>max_source</code> calls to <code>isl_access_info_add_source</code>. <code>must</code> indicates whether the source is a <i>must</i> access or a <i>may</i> access. Note that a multi-valued access relation should only be marked <i>must</i> if every iteration in the domain of the relation accesses <i>all</i> elements in its image. The <code>source_user</code> token is again used to identify the source access. The range of the source access relation <code>source</code> should have the same dimension as the range of the sink access relation. The <code>isl_access_info_free</code> function should usually not be called explicitly, because it is already called implicitly by <code>isl_access_info_compute_flow</code>.</p>

<p>The result of the dependence analysis is collected in an <code>isl_flow</code>. There may be elements of the sink access for which no preceding source access could be found or for which all preceding sources are <i>may</i> accesses. The relations containing these elements can be obtained through calls to <code>isl_flow_get_no_source</code>, the first with <code>must</code> set and the second with <code>must</code> unset. In the case of standard flow dependence analysis, with the sink a read and the sources <i>must</i> writes, the first relation corresponds to the reads from uninitialized array elements and the second relation is empty. The actual flow dependences can be extracted using <code>isl_flow_foreach</code>. This function will call the user-specified callback function <code>fn</code> for each <b>non-empty</b> dependence between a source and the sink. The callback function is called with four arguments, the actual flow dependence relation mapping source iterations to sink iterations, a boolean that indicates whether it is a <i>must</i> or <i>may</i> dependence, a token identifying the source and an additional <code>void *</code> with value equal to the third argument of the <code>isl_flow_foreach</code> call. A dependence is marked <i>must</i> if it originates from a <i>must</i> source and if it is not followed by any <i>may</i> sources.</p>

<p>After finishing with an <code>isl_flow</code>, the user should call <code>isl_flow_free</code> to free all associated memory.</p>

<h3 id="Interaction-with-the-Low-level-Interface">Interaction with the Low-level Interface</h3>

<p>During the dependence analysis, we frequently need to perform the following operation. Given a relation between sink iterations and potential source iterations from a particular source domain, what is the last potential source iteration corresponding to each sink iteration. It can sometimes be convenient to adjust the set of potential source iterations before or after each such operation. The prototypical example is fuzzy array dataflow analysis, where we need to analyze if, based on data-dependent constraints, the sink iteration can ever be executed without one or more of the corresponding potential source iterations being executed. If so, we can introduce extra parameters and select an unknown but fixed source iteration from the potential source iterations. To be able to perform such manipulations, <code>isl</code> provides the following function.</p>

<pre><code>#include &lt;isl/flow.h&gt;

typedef __isl_give isl_restriction *(*isl_access_restrict)(
        __isl_keep isl_map *source_map,
        __isl_keep isl_set *sink, void *source_user,
        void *user);
__isl_give isl_access_info *isl_access_info_set_restrict(
        __isl_take isl_access_info *acc,
        isl_access_restrict fn, void *user);</code></pre>

<p>The function <code>isl_access_info_set_restrict</code> should be called before calling <code>isl_access_info_compute_flow</code> and registers a callback function that will be called any time <code>isl</code> is about to compute the last potential source. The first argument is the (reverse) proto-dependence, mapping sink iterations to potential source iterations. The second argument represents the sink iterations for which we want to compute the last source iteration. The third argument is the token corresponding to the source and the final argument is the token passed to <code>isl_access_info_set_restrict</code>. The callback is expected to return a restriction on either the input or the output of the operation computing the last potential source. If the input needs to be restricted then restrictions are needed for both the source and the sink iterations. The sink iterations and the potential source iterations will be intersected with these sets. If the output needs to be restricted then only a restriction on the source iterations is required. If any error occurs, the callback should return <code>NULL</code>. An <code>isl_restriction</code> object can be created, freed and inspected using the following functions.</p>

<pre><code>#include &lt;isl/flow.h&gt;

__isl_give isl_restriction *isl_restriction_input(
        __isl_take isl_set *source_restr,
        __isl_take isl_set *sink_restr);
__isl_give isl_restriction *isl_restriction_output(
        __isl_take isl_set *source_restr);
__isl_give isl_restriction *isl_restriction_none(
        __isl_take isl_map *source_map);
__isl_give isl_restriction *isl_restriction_empty(
        __isl_take isl_map *source_map);
__isl_null isl_restriction *isl_restriction_free(
        __isl_take isl_restriction *restr);</code></pre>

<p><code>isl_restriction_none</code> and <code>isl_restriction_empty</code> are special cases of <code>isl_restriction_input</code>. <code>isl_restriction_none</code> is essentially equivalent to</p>

<pre><code>isl_restriction_input(isl_set_universe(
    isl_space_range(isl_map_get_space(source_map))),
                    isl_set_universe(
    isl_space_domain(isl_map_get_space(source_map))));</code></pre>

<p>whereas <code>isl_restriction_empty</code> is essentially equivalent to</p>

<pre><code>isl_restriction_input(isl_set_empty(
    isl_space_range(isl_map_get_space(source_map))),
                    isl_set_universe(
    isl_space_domain(isl_map_get_space(source_map))));</code></pre>

<h2 id="Scheduling">Scheduling</h2>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *
isl_schedule_constraints_compute_schedule(
        __isl_take isl_schedule_constraints *sc);</code></pre>

<p>The function <code>isl_schedule_constraints_compute_schedule</code> can be used to compute a schedule that satisfies the given schedule constraints. These schedule constraints include the iteration domain for which a schedule should be computed and dependences between pairs of iterations. In particular, these dependences include <i>validity</i> dependences and <i>proximity</i> dependences. By default, the algorithm used to construct the schedule is similar to that of <code>Pluto</code>. Alternatively, Feautrier&#39;s multi-dimensional scheduling algorithm can be selected. The generated schedule respects all validity dependences. That is, all dependence distances over these dependences in the scheduled space are lexicographically positive.</p>

<p>The default algorithm tries to ensure that the dependence distances over coincidence constraints are zero and to minimize the dependence distances over proximity dependences. Moreover, it tries to obtain sequences (bands) of schedule dimensions for groups of domains where the dependence distances over validity dependences have only non-negative values. Note that when minimizing the maximal dependence distance over proximity dependences, a single affine expression in the parameters is constructed that bounds all dependence distances. If no such expression exists, then the algorithm will fail and resort to an alternative scheduling algorithm. In particular, this means that adding proximity dependences may eliminate valid solutions. A typical example where this phenomenon may occur is when some subset of the proximity dependences has no restriction on some parameter, forcing the coefficient of that parameter to be zero, while some other subset forces the dependence distance to depend on that parameter, requiring the same coefficient to be non-zero. When using Feautrier&#39;s algorithm, the coincidence and proximity constraints are only taken into account during the extension to a full-dimensional schedule.</p>

<p>An <code>isl_schedule_constraints</code> object can be constructed and manipulated using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule_constraints *
isl_schedule_constraints_copy(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_on_domain(
        __isl_take isl_union_set *domain);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_set_context(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_set *context);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_set_validity(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_union_map *validity);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_set_coincidence(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_union_map *coincidence);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_set_proximity(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_union_map *proximity);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_set_conditional_validity(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_union_map *condition,
        __isl_take isl_union_map *validity);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_apply(
        __isl_take isl_schedule_constraints *sc,
        __isl_take isl_union_map *umap);
__isl_null isl_schedule_constraints *
isl_schedule_constraints_free(
        __isl_take isl_schedule_constraints *sc);</code></pre>

<p>The initial <code>isl_schedule_constraints</code> object created by <code>isl_schedule_constraints_on_domain</code> does not impose any constraints. That is, it has an empty set of dependences. The function <code>isl_schedule_constraints_set_context</code> allows the user to specify additional constraints on the parameters that may be assumed to hold during the construction of the schedule. The function <code>isl_schedule_constraints_set_validity</code> replaces the validity dependences, mapping domain elements <i>i</i> to domain elements that should be scheduled after <i>i</i>. The function <code>isl_schedule_constraints_set_coincidence</code> replaces the coincidence dependences, mapping domain elements <i>i</i> to domain elements that should be scheduled together with <i>I</i>, if possible. The function <code>isl_schedule_constraints_set_proximity</code> replaces the proximity dependences, mapping domain elements <i>i</i> to domain elements that should be scheduled either before <i>I</i> or as early as possible after <i>i</i>.</p>

<p>The function <code>isl_schedule_constraints_set_conditional_validity</code> replaces the conditional validity constraints. A conditional validity constraint is only imposed when any of the corresponding conditions is satisfied, i.e., when any of them is non-zero. That is, the scheduler ensures that within each band if the dependence distances over the condition constraints are not all zero then all corresponding conditional validity constraints are respected. A conditional validity constraint corresponds to a condition if the two are adjacent, i.e., if the domain of one relation intersect the range of the other relation. The typical use case of conditional validity constraints is to allow order constraints between live ranges to be violated as long as the live ranges themselves are local to the band. To allow more fine-grained control over which conditions correspond to which conditional validity constraints, the domains and ranges of these relations may include <i>tags</i>. That is, the domains and ranges of those relation may themselves be wrapped relations where the iteration domain appears in the domain of those wrapped relations and the range of the wrapped relations can be arbitrarily chosen by the user. Conditions and conditional validity constraints are only considered adjacent to each other if the entire wrapped relation matches. In particular, a relation with a tag will never be considered adjacent to a relation without a tag.</p>

<p>The function <code>isl_schedule_constraints_apply</code> takes schedule constraints that are defined on some set of domain elements and transforms them to schedule constraints on the elements to which these domain elements are mapped by the given transformation.</p>

<p>An <code>isl_schedule_constraints</code> object can be inspected using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_union_set *
isl_schedule_constraints_get_domain(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_set *isl_schedule_constraints_get_context(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_union_map *
isl_schedule_constraints_get_validity(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_union_map *
isl_schedule_constraints_get_coincidence(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_union_map *
isl_schedule_constraints_get_proximity(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_union_map *
isl_schedule_constraints_get_conditional_validity(
        __isl_keep isl_schedule_constraints *sc);
__isl_give isl_union_map *
isl_schedule_constraints_get_conditional_validity_condition(
        __isl_keep isl_schedule_constraints *sc);</code></pre>

<p>An <code>isl_schedule_constraints</code> object can be read from input using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule_constraints *
isl_schedule_constraints_read_from_str(isl_ctx *ctx,
        const char *str);
__isl_give isl_schedule_constraints *
isl_schedule_constraints_read_from_file(isl_ctx *ctx,
        FILE *input);</code></pre>

<p>The contents of an <code>isl_schedule_constraints</code> object can be printed using the following functions.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_printer *
isl_printer_print_schedule_constraints(
        __isl_take isl_printer *p,
        __isl_keep isl_schedule_constraints *sc);
__isl_give char *isl_schedule_constraints_to_str(
        __isl_keep isl_schedule_constraints *sc);</code></pre>

<p>The following function computes a schedule directly from an iteration domain and validity and proximity dependences and is implemented in terms of the functions described above. The use of <code>isl_union_set_compute_schedule</code> is discouraged.</p>

<pre><code>#include &lt;isl/schedule.h&gt;
__isl_give isl_schedule *isl_union_set_compute_schedule(
        __isl_take isl_union_set *domain,
        __isl_take isl_union_map *validity,
        __isl_take isl_union_map *proximity);</code></pre>

<p>The generated schedule represents a schedule tree. For more information on schedule trees, see <a href="#Schedule-Trees">&quot;Schedule Trees&quot;</a>.</p>

<h3 id="Options">Options</h3>

<pre><code>#include &lt;isl/schedule.h&gt;
isl_stat isl_options_set_schedule_max_coefficient(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_max_coefficient(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_max_constant_term(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_max_constant_term(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_serialize_sccs(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_serialize_sccs(isl_ctx *ctx);
isl_stat isl_options_set_schedule_whole_component(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_whole_component(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_maximize_band_depth(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_maximize_band_depth(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_maximize_coincidence(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_maximize_coincidence(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_outer_coincidence(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_outer_coincidence(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_split_scaled(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_split_scaled(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_treat_coalescing(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_treat_coalescing(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_algorithm(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_algorithm(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_carry_self_first(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_carry_self_first(
        isl_ctx *ctx);
isl_stat isl_options_set_schedule_separate_components(
        isl_ctx *ctx, int val);
int isl_options_get_schedule_separate_components(
        isl_ctx *ctx);</code></pre>

<ul>

<li><p>schedule_max_coefficient</p>

<p>This option enforces that the coefficients for variable and parameter dimensions in the calculated schedule are not larger than the specified value. This option can significantly increase the speed of the scheduling calculation and may also prevent fusing of unrelated dimensions. A value of -1 means that this option does not introduce bounds on the variable or parameter coefficients. This option has no effect on the Feautrier style scheduler.</p>

</li>
<li><p>schedule_max_constant_term</p>

<p>This option enforces that the constant coefficients in the calculated schedule are not larger than the maximal constant term. This option can significantly increase the speed of the scheduling calculation and may also prevent fusing of unrelated dimensions. A value of -1 means that this option does not introduce bounds on the constant coefficients.</p>

</li>
<li><p>schedule_serialize_sccs</p>

<p>If this option is set, then all strongly connected components in the dependence graph are serialized as soon as they are detected. This means in particular that instances of statements will only appear in the same band node if these statements belong to the same strongly connected component at the point where the band node is constructed.</p>

</li>
<li><p>schedule_whole_component</p>

<p>If this option is set, then entire (weakly) connected components in the dependence graph are scheduled together as a whole. Otherwise, each strongly connected component within such a weakly connected component is first scheduled separately and then combined with other strongly connected components. This option has no effect if <code>schedule_serialize_sccs</code> is set.</p>

</li>
<li><p>schedule_maximize_band_depth</p>

<p>If this option is set, then the scheduler tries to maximize the width of the bands. Wider bands give more possibilities for tiling. In particular, if the <code>schedule_whole_component</code> option is set, then bands are split if this might result in wider bands. Otherwise, the effect of this option is to only allow strongly connected components to be combined if this does not reduce the width of the bands. Note that if the <code>schedule_serialize_sccs</code> options is set, then the <code>schedule_maximize_band_depth</code> option therefore has no effect.</p>

</li>
<li><p>schedule_maximize_coincidence</p>

<p>This option is only effective if the <code>schedule_whole_component</code> option is turned off. If the <code>schedule_maximize_coincidence</code> option is set, then (clusters of) strongly connected components are only combined with each other if this does not reduce the number of coincident band members.</p>

</li>
<li><p>schedule_outer_coincidence</p>

<p>If this option is set, then we try to construct schedules where the outermost scheduling dimension in each band satisfies the coincidence constraints.</p>

</li>
<li><p>schedule_algorithm</p>

<p>Selects the scheduling algorithm to be used. Available scheduling algorithms are <code>ISL_SCHEDULE_ALGORITHM_ISL</code> and <code>ISL_SCHEDULE_ALGORITHM_FEAUTRIER</code>.</p>

</li>
<li><p>schedule_split_scaled</p>

<p>If this option is set, then we try to construct schedules in which the constant term is split off from the linear part if the linear parts of the scheduling rows for all nodes in the graph have a common non-trivial divisor. The constant term is then dropped and the linear part is reduced. This option is only effective when the Feautrier style scheduler is being used, either as the main scheduler or as a fallback for the Pluto-like scheduler.</p>

</li>
<li><p>schedule_treat_coalescing</p>

<p>If this option is set, then the scheduler will try and avoid producing schedules that perform loop coalescing. In particular, for the Pluto-like scheduler, this option places bounds on the schedule coefficients based on the sizes of the instance sets. For the Feautrier style scheduler, this option detects potentially coalescing schedules and then tries to adjust the schedule to avoid the coalescing.</p>

</li>
<li><p>schedule_carry_self_first</p>

<p>If this option is set, then the Feautrier style scheduler (when used as a fallback for the Pluto-like scheduler) will first try to only carry self-dependences.</p>

</li>
<li><p>schedule_separate_components</p>

<p>If this option is set then the function <code>isl_schedule_get_map</code> will treat set nodes in the same way as sequence nodes.</p>

</li>
</ul>

<h2 id="AST-Generation">AST Generation</h2>

<p>This section describes the <code>isl</code> functionality for generating ASTs that visit all the elements in a domain in an order specified by a schedule tree or a schedule map. In case the schedule given as a <code>isl_union_map</code>, an AST is generated that visits all the elements in the domain of the <code>isl_union_map</code> according to the lexicographic order of the corresponding image element(s). If the range of the <code>isl_union_map</code> consists of elements in more than one space, then each of these spaces is handled separately in an arbitrary order. It should be noted that the schedule tree or the image elements in a schedule map only specify the <i>order</i> in which the corresponding domain elements should be visited. No direct relation between the partial schedule values or the image elements on the one hand and the loop iterators in the generated AST on the other hand should be assumed.</p>

<p>Each AST is generated within a build. The initial build simply specifies the constraints on the parameters (if any) and can be created, inspected, copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_build *isl_ast_build_alloc(
        isl_ctx *ctx);
__isl_give isl_ast_build *isl_ast_build_from_context(
        __isl_take isl_set *set);
__isl_give isl_ast_build *isl_ast_build_copy(
        __isl_keep isl_ast_build *build);
__isl_null isl_ast_build *isl_ast_build_free(
        __isl_take isl_ast_build *build);</code></pre>

<p>The <code>set</code> argument is usually a parameter set with zero or more parameters. In fact, when creating an AST using <code>isl_ast_build_node_from_schedule</code>, this set is required to be a parameter set. An <code>isl_ast_build</code> created using <code>isl_ast_build_alloc</code> does not specify any parameter constraints. More <code>isl_ast_build</code> functions are described in <a href="#Nested-AST-Generation">&quot;Nested AST Generation&quot;</a> and <a href="#Fine-grained-Control-over-AST-Generation">&quot;Fine-grained Control over AST Generation&quot;</a>. Finally, the AST itself can be constructed using one of the following functions.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_node *isl_ast_build_node_from_schedule(
        __isl_keep isl_ast_build *build,
        __isl_take isl_schedule *schedule);
__isl_give isl_ast_node *
isl_ast_build_node_from_schedule_map(
        __isl_keep isl_ast_build *build,
        __isl_take isl_union_map *schedule);</code></pre>

<h3 id="Inspecting-the-AST">Inspecting the AST</h3>

<p>The basic properties of an AST node can be obtained as follows.</p>

<pre><code>#include &lt;isl/ast.h&gt;
enum isl_ast_node_type isl_ast_node_get_type(
        __isl_keep isl_ast_node *node);</code></pre>

<p>The type of an AST node is one of <code>isl_ast_node_for</code>, <code>isl_ast_node_if</code>, <code>isl_ast_node_block</code>, <code>isl_ast_node_mark</code> or <code>isl_ast_node_user</code>. An <code>isl_ast_node_for</code> represents a for node. An <code>isl_ast_node_if</code> represents an if node. An <code>isl_ast_node_block</code> represents a compound node. An <code>isl_ast_node_mark</code> introduces a mark in the AST. An <code>isl_ast_node_user</code> represents an expression statement. An expression statement typically corresponds to a domain element, i.e., one of the elements that is visited by the AST.</p>

<p>Each type of node has its own additional properties.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_node_for_get_iterator(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_expr *isl_ast_node_for_get_init(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_expr *isl_ast_node_for_get_cond(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_expr *isl_ast_node_for_get_inc(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_for_get_body(
        __isl_keep isl_ast_node *node);
isl_bool isl_ast_node_for_is_degenerate(
        __isl_keep isl_ast_node *node);</code></pre>

<p>An <code>isl_ast_for</code> is considered degenerate if it is known to execute exactly once.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_node_if_get_cond(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_if_get_then_node(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_if_get_then(
        __isl_keep isl_ast_node *node);
isl_bool isl_ast_node_if_has_else_node(
        __isl_keep isl_ast_node *node);
isl_bool isl_ast_node_if_has_else(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_if_get_else_node(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_if_get_else(
        __isl_keep isl_ast_node *node);</code></pre>

<p><code>isl_ast_node_if_get_then</code>, <code>isl_ast_node_if_has_else</code> and <code>isl_ast_node_if_get_else</code> are alternative names for <code>isl_ast_node_if_get_then_node</code>, <code>isl_ast_node_if_has_else_node</code> and <code>isl_ast_node_if_get_else_node</code>, respectively.</p>

<pre><code>__isl_give isl_ast_node_list *
isl_ast_node_block_get_children(
        __isl_keep isl_ast_node *node);

__isl_give isl_id *isl_ast_node_mark_get_id(
        __isl_keep isl_ast_node *node);
__isl_give isl_ast_node *isl_ast_node_mark_get_node(
        __isl_keep isl_ast_node *node);</code></pre>

<p><code>isl_ast_node_mark_get_id</code> returns the identifier of the mark. <code>isl_ast_node_mark_get_node</code> returns the child node that is being marked.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_node_user_get_expr(
        __isl_keep isl_ast_node *node);</code></pre>

<p>All descendants of a specific node in the AST (including the node itself) can be visited in depth-first pre-order using the following function.</p>

<pre><code>#include &lt;isl/ast.h&gt;
isl_stat isl_ast_node_foreach_descendant_top_down(
        __isl_keep isl_ast_node *node,
        isl_bool (*fn)(__isl_keep isl_ast_node *node,
                void *user), void *user);</code></pre>

<p>The callback function should return <code>isl_bool_true</code> if the children of the given node should be visited and <code>isl_bool_false</code> if they should not. It should return <code>isl_bool_error</code> in case of failure, in which case the entire traversal is aborted.</p>

<p>Each of the returned <code>isl_ast_expr</code>s can in turn be inspected using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
enum isl_ast_expr_type isl_ast_expr_get_type(
        __isl_keep isl_ast_expr *expr);</code></pre>

<p>The type of an AST expression is one of <code>isl_ast_expr_op</code>, <code>isl_ast_expr_id</code> or <code>isl_ast_expr_int</code>. An <code>isl_ast_expr_op</code> represents the result of an operation. An <code>isl_ast_expr_id</code> represents an identifier. An <code>isl_ast_expr_int</code> represents an integer value.</p>

<p>Each type of expression has its own additional properties.</p>

<pre><code>#include &lt;isl/ast.h&gt;
enum isl_ast_expr_op_type isl_ast_expr_op_get_type(
        __isl_keep isl_ast_expr *expr);
enum isl_ast_expr_op_type isl_ast_expr_get_op_type(
        __isl_keep isl_ast_expr *expr);
isl_size isl_ast_expr_op_get_n_arg(__isl_keep isl_ast_expr *expr);
isl_size isl_ast_expr_get_op_n_arg(__isl_keep isl_ast_expr *expr);
__isl_give isl_ast_expr *isl_ast_expr_op_get_arg(
        __isl_keep isl_ast_expr *expr, int pos);
__isl_give isl_ast_expr *isl_ast_expr_get_op_arg(
        __isl_keep isl_ast_expr *expr, int pos);
isl_stat isl_ast_expr_foreach_ast_expr_op_type(
        __isl_keep isl_ast_expr *expr,
        isl_stat (*fn)(enum isl_ast_expr_op_type type,
                void *user), void *user);
isl_stat isl_ast_expr_foreach_ast_op_type(
        __isl_keep isl_ast_expr *expr,
        isl_stat (*fn)(enum isl_ast_expr_op_type type,
                void *user), void *user);
isl_stat isl_ast_node_foreach_ast_expr_op_type(
        __isl_keep isl_ast_node *node,
        isl_stat (*fn)(enum isl_ast_expr_op_type type,
                void *user), void *user);
isl_stat isl_ast_node_foreach_ast_op_type(
        __isl_keep isl_ast_node *node,
        isl_stat (*fn)(enum isl_ast_expr_op_type type,
                void *user), void *user);</code></pre>

<p><code>isl_ast_expr_op_get_type</code> returns the type of the operation performed. <code>isl_ast_expr_op_get_n_arg</code> returns the number of arguments. <code>isl_ast_expr_get_op_arg</code> returns the specified argument. <code>isl_ast_expr_get_op_type</code> is an alternative name for <code>isl_ast_expr_op_get_type</code>. Similarly, <code>isl_ast_expr_get_op_n_arg</code> is an alternative name for <code>isl_ast_expr_op_get_n_arg</code> and <code>isl_ast_expr_get_op_arg</code> is an alternative name for <code>isl_ast_expr_op_get_arg</code>.</p>

<p><code>isl_ast_expr_foreach_ast_expr_op_type</code> calls <code>fn</code> for each distinct <code>isl_ast_expr_op_type</code> that appears in <code>expr</code>. <code>isl_ast_expr_foreach_ast_op_type</code> is an alternative name for <code>isl_ast_expr_foreach_ast_expr_op_type</code>. <code>isl_ast_node_foreach_ast_expr_op_type</code> does the same for each distinct <code>isl_ast_expr_op_type</code> that appears in <code>node</code>. <code>isl_ast_node_foreach_ast_op_type</code> is an alternative name for <code>isl_ast_node_foreach_ast_expr_op_type</code>. The operation type is one of the following.</p>

<dl>

<dt id="isl_ast_expr_op_and"><code>isl_ast_expr_op_and</code></dt>
<dd>

<p>Logical <i>and</i> of two arguments. Both arguments can be evaluated.</p>

</dd>
<dt id="isl_ast_expr_op_and_then"><code>isl_ast_expr_op_and_then</code></dt>
<dd>

<p>Logical <i>and</i> of two arguments. The second argument can only be evaluated if the first evaluates to true.</p>

</dd>
<dt id="isl_ast_expr_op_or"><code>isl_ast_expr_op_or</code></dt>
<dd>

<p>Logical <i>or</i> of two arguments. Both arguments can be evaluated.</p>

</dd>
<dt id="isl_ast_expr_op_or_else"><code>isl_ast_expr_op_or_else</code></dt>
<dd>

<p>Logical <i>or</i> of two arguments. The second argument can only be evaluated if the first evaluates to false.</p>

</dd>
<dt id="isl_ast_expr_op_max"><code>isl_ast_expr_op_max</code></dt>
<dd>

<p>Maximum of two or more arguments.</p>

</dd>
<dt id="isl_ast_expr_op_min"><code>isl_ast_expr_op_min</code></dt>
<dd>

<p>Minimum of two or more arguments.</p>

</dd>
<dt id="isl_ast_expr_op_minus"><code>isl_ast_expr_op_minus</code></dt>
<dd>

<p>Change sign.</p>

</dd>
<dt id="isl_ast_expr_op_add"><code>isl_ast_expr_op_add</code></dt>
<dd>

<p>Sum of two arguments.</p>

</dd>
<dt id="isl_ast_expr_op_sub"><code>isl_ast_expr_op_sub</code></dt>
<dd>

<p>Difference of two arguments.</p>

</dd>
<dt id="isl_ast_expr_op_mul"><code>isl_ast_expr_op_mul</code></dt>
<dd>

<p>Product of two arguments.</p>

</dd>
<dt id="isl_ast_expr_op_div"><code>isl_ast_expr_op_div</code></dt>
<dd>

<p>Exact division. That is, the result is known to be an integer.</p>

</dd>
<dt id="isl_ast_expr_op_fdiv_q"><code>isl_ast_expr_op_fdiv_q</code></dt>
<dd>

<p>Result of integer division, rounded towards negative infinity. The divisor is known to be positive.</p>

</dd>
<dt id="isl_ast_expr_op_pdiv_q"><code>isl_ast_expr_op_pdiv_q</code></dt>
<dd>

<p>Result of integer division, where dividend is known to be non-negative. The divisor is known to be positive.</p>

</dd>
<dt id="isl_ast_expr_op_pdiv_r"><code>isl_ast_expr_op_pdiv_r</code></dt>
<dd>

<p>Remainder of integer division, where dividend is known to be non-negative. The divisor is known to be positive.</p>

</dd>
<dt id="isl_ast_expr_op_zdiv_r"><code>isl_ast_expr_op_zdiv_r</code></dt>
<dd>

<p>Equal to zero iff the remainder on integer division is zero. The divisor is known to be positive.</p>

</dd>
<dt id="isl_ast_expr_op_cond"><code>isl_ast_expr_op_cond</code></dt>
<dd>

<p>Conditional operator defined on three arguments. If the first argument evaluates to true, then the result is equal to the second argument. Otherwise, the result is equal to the third argument. The second and third argument may only be evaluated if the first argument evaluates to true and false, respectively. Corresponds to <code>a ? b : c</code> in C.</p>

</dd>
<dt id="isl_ast_expr_op_select"><code>isl_ast_expr_op_select</code></dt>
<dd>

<p>Conditional operator defined on three arguments. If the first argument evaluates to true, then the result is equal to the second argument. Otherwise, the result is equal to the third argument. The second and third argument may be evaluated independently of the value of the first argument. Corresponds to <code>a * b + (1 - a) * c</code> in C.</p>

</dd>
<dt id="isl_ast_expr_op_eq"><code>isl_ast_expr_op_eq</code></dt>
<dd>

<p>Equality relation.</p>

</dd>
<dt id="isl_ast_expr_op_le"><code>isl_ast_expr_op_le</code></dt>
<dd>

<p>Less than or equal relation.</p>

</dd>
<dt id="isl_ast_expr_op_lt"><code>isl_ast_expr_op_lt</code></dt>
<dd>

<p>Less than relation.</p>

</dd>
<dt id="isl_ast_expr_op_ge"><code>isl_ast_expr_op_ge</code></dt>
<dd>

<p>Greater than or equal relation.</p>

</dd>
<dt id="isl_ast_expr_op_gt"><code>isl_ast_expr_op_gt</code></dt>
<dd>

<p>Greater than relation.</p>

</dd>
<dt id="isl_ast_expr_op_call"><code>isl_ast_expr_op_call</code></dt>
<dd>

<p>A function call. The number of arguments of the <code>isl_ast_expr</code> is one more than the number of arguments in the function call, the first argument representing the function being called.</p>

</dd>
<dt id="isl_ast_expr_op_access"><code>isl_ast_expr_op_access</code></dt>
<dd>

<p>An array access. The number of arguments of the <code>isl_ast_expr</code> is one more than the number of index expressions in the array access, the first argument representing the array being accessed.</p>

</dd>
<dt id="isl_ast_expr_op_member"><code>isl_ast_expr_op_member</code></dt>
<dd>

<p>A member access. This operation has two arguments, a structure and the name of the member of the structure being accessed.</p>

</dd>
<dt id="isl_ast_expr_op_address_of"><code>isl_ast_expr_op_address_of</code></dt>
<dd>

<p>The address of its single argument, which is always an array access.</p>

</dd>
</dl>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_id *isl_ast_expr_id_get_id(
        __isl_keep isl_ast_expr *expr);
__isl_give isl_id *isl_ast_expr_get_id(
        __isl_keep isl_ast_expr *expr);</code></pre>

<p>Return the identifier represented by the AST expression. <code>isl_ast_expr_get_id</code> is an alternative name for <code>isl_ast_expr_id_get_id</code>.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_val *isl_ast_expr_int_get_val(
        __isl_keep isl_ast_expr *expr);
__isl_give isl_val *isl_ast_expr_get_val(
        __isl_keep isl_ast_expr *expr);</code></pre>

<p>Return the integer represented by the AST expression. <code>isl_ast_expr_get_val</code> is an alternative name for <code>isl_ast_expr_int_get_val</code>.</p>

<h3 id="Properties-of-ASTs">Properties of ASTs</h3>

<pre><code>#include &lt;isl/ast.h&gt;
isl_bool isl_ast_expr_is_equal(
        __isl_keep isl_ast_expr *expr1,
        __isl_keep isl_ast_expr *expr2);</code></pre>

<p>Check if two <code>isl_ast_expr</code>s are equal to each other.</p>

<h3 id="Manipulating-and-printing-the-AST">Manipulating and printing the AST</h3>

<p>AST nodes can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_node *isl_ast_node_copy(
        __isl_keep isl_ast_node *node);
__isl_null isl_ast_node *isl_ast_node_free(
        __isl_take isl_ast_node *node);</code></pre>

<p>AST expressions can be copied and freed using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_expr_copy(
        __isl_keep isl_ast_expr *expr);
__isl_null isl_ast_expr *isl_ast_expr_free(
        __isl_take isl_ast_expr *expr);</code></pre>

<p>New AST expressions can be created either directly or within the context of an <code>isl_ast_build</code>.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_expr_from_val(
        __isl_take isl_val *v);
__isl_give isl_ast_expr *isl_ast_expr_from_id(
        __isl_take isl_id *id);
__isl_give isl_ast_expr *isl_ast_expr_neg(
        __isl_take isl_ast_expr *expr);
__isl_give isl_ast_expr *isl_ast_expr_address_of(
        __isl_take isl_ast_expr *expr);
__isl_give isl_ast_expr *isl_ast_expr_add(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_sub(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_mul(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_div(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_pdiv_q(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_pdiv_r(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_and(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2)
__isl_give isl_ast_expr *isl_ast_expr_and_then(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2)
__isl_give isl_ast_expr *isl_ast_expr_or(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2)
__isl_give isl_ast_expr *isl_ast_expr_or_else(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2)
__isl_give isl_ast_expr *isl_ast_expr_eq(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_le(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_lt(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_ge(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_gt(
        __isl_take isl_ast_expr *expr1,
        __isl_take isl_ast_expr *expr2);
__isl_give isl_ast_expr *isl_ast_expr_access(
        __isl_take isl_ast_expr *array,
        __isl_take isl_ast_expr_list *indices);
__isl_give isl_ast_expr *isl_ast_expr_call(
        __isl_take isl_ast_expr *function,
        __isl_take isl_ast_expr_list *arguments);</code></pre>

<p>The function <code>isl_ast_expr_address_of</code> can be applied to an <code>isl_ast_expr</code> of type <code>isl_ast_expr_op_access</code> only. It is meant to represent the address of the <code>isl_ast_expr_access</code>. The second argument of the functions <code>isl_ast_expr_pdiv_q</code> and <code>isl_ast_expr_pdiv_r</code> should always evaluate to a positive number. The function <code>isl_ast_expr_and_then</code> as well as <code>isl_ast_expr_or_else</code> are short-circuit versions of <code>isl_ast_expr_and</code> and <code>isl_ast_expr_or</code>, respectively.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_expr *isl_ast_build_expr_from_set(
        __isl_keep isl_ast_build *build,
        __isl_take isl_set *set);
__isl_give isl_ast_expr *isl_ast_build_expr_from_pw_aff(
        __isl_keep isl_ast_build *build,
        __isl_take isl_pw_aff *pa);
__isl_give isl_ast_expr *
isl_ast_build_access_from_pw_multi_aff(
        __isl_keep isl_ast_build *build,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_ast_expr *
isl_ast_build_access_from_multi_pw_aff(
        __isl_keep isl_ast_build *build,
        __isl_take isl_multi_pw_aff *mpa);
__isl_give isl_ast_expr *
isl_ast_build_call_from_pw_multi_aff(
        __isl_keep isl_ast_build *build,
        __isl_take isl_pw_multi_aff *pma);
__isl_give isl_ast_expr *
isl_ast_build_call_from_multi_pw_aff(
        __isl_keep isl_ast_build *build,
        __isl_take isl_multi_pw_aff *mpa);</code></pre>

<p>The set <code>set</code> and the domains of <code>pa</code>, <code>mpa</code> and <code>pma</code> should correspond to the schedule space of <code>build</code>. The tuple id of <code>mpa</code> or <code>pma</code> is used as the array being accessed or the function being called. If the accessed space is a nested relation, then it is taken to represent an access of the member specified by the range of this nested relation of the structure specified by the domain of the nested relation.</p>

<p>The following functions can be used to modify an <code>isl_ast_expr</code>.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_expr_set_op_arg(
        __isl_take isl_ast_expr *expr, int pos,
        __isl_take isl_ast_expr *arg);</code></pre>

<p>Replace the argument of <code>expr</code> at position <code>pos</code> by <code>arg</code>.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_expr *isl_ast_expr_substitute_ids(
        __isl_take isl_ast_expr *expr,
        __isl_take isl_id_to_ast_expr *id2expr);</code></pre>

<p>The function <code>isl_ast_expr_substitute_ids</code> replaces the subexpressions of <code>expr</code> of type <code>isl_ast_expr_id</code> by the corresponding expression in <code>id2expr</code>, if there is any.</p>

<p>The following function can be used to modify the descendants of a specific node in an AST using a depth-first post-order traversal of those descendants (including the node itself).</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_node *
isl_ast_node_map_descendant_bottom_up(
        __isl_take isl_ast_node *node,
        __isl_give isl_ast_node *(*fn)(
                __isl_take isl_ast_node *node,
                void *user), void *user);</code></pre>

<p>User specified data can be attached to an <code>isl_ast_node</code> and obtained from the same <code>isl_ast_node</code> using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_node *isl_ast_node_set_annotation(
        __isl_take isl_ast_node *node,
        __isl_take isl_id *annotation);
__isl_give isl_id *isl_ast_node_get_annotation(
        __isl_keep isl_ast_node *node);</code></pre>

<p>Basic printing can be performed using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_printer *isl_printer_print_ast_expr(
        __isl_take isl_printer *p,
        __isl_keep isl_ast_expr *expr);
__isl_give isl_printer *isl_printer_print_ast_node(
        __isl_take isl_printer *p,
        __isl_keep isl_ast_node *node);
__isl_give char *isl_ast_expr_to_str(
        __isl_keep isl_ast_expr *expr);
__isl_give char *isl_ast_node_to_str(
        __isl_keep isl_ast_node *node);
__isl_give char *isl_ast_expr_to_C_str(
        __isl_keep isl_ast_expr *expr);
__isl_give char *isl_ast_node_to_C_str(
        __isl_keep isl_ast_node *node);</code></pre>

<p>The functions <code>isl_ast_expr_to_C_str</code> and <code>isl_ast_node_to_C_str</code> are convenience functions that return a string representation of the input in C format.</p>

<p>More advanced printing can be performed using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_printer *
isl_ast_expr_op_type_set_print_name(
        __isl_take isl_printer *p,
        enum isl_ast_expr_op_type type,
        __isl_keep const char *name);
__isl_give isl_printer *isl_ast_op_type_set_print_name(
        __isl_take isl_printer *p,
        enum isl_ast_expr_op_type type,
        __isl_keep const char *name);
isl_stat isl_options_set_ast_print_macro_once(
        isl_ctx *ctx, int val);
int isl_options_get_ast_print_macro_once(isl_ctx *ctx);
__isl_give isl_printer *isl_ast_expr_op_type_print_macro(
        enum isl_ast_expr_op_type type,
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_ast_op_type_print_macro(
        enum isl_ast_expr_op_type type,
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_ast_expr_print_macros(
        __isl_keep isl_ast_expr *expr,
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_ast_node_print_macros(
        __isl_keep isl_ast_node *node,
        __isl_take isl_printer *p);
__isl_give isl_printer *isl_ast_node_print(
        __isl_keep isl_ast_node *node,
        __isl_take isl_printer *p,
        __isl_take isl_ast_print_options *options);
__isl_give isl_printer *isl_ast_node_for_print(
        __isl_keep isl_ast_node *node,
        __isl_take isl_printer *p,
        __isl_take isl_ast_print_options *options);
__isl_give isl_printer *isl_ast_node_if_print(
        __isl_keep isl_ast_node *node,
        __isl_take isl_printer *p,
        __isl_take isl_ast_print_options *options);</code></pre>

<p>While printing an <code>isl_ast_node</code> in <code>ISL_FORMAT_C</code>, <code>isl</code> may print out an AST that makes use of macros such as <code>floord</code>, <code>min</code> and <code>max</code>. The names of these macros may be modified by a call to <code>isl_ast_expr_op_type_set_print_name</code>. The user-specified names are associated to the printer object. <code>isl_ast_op_type_set_print_name</code> is an alternative name for <code>isl_ast_expr_op_type_set_print_name</code>. <code>isl_ast_expr_op_type_print_macro</code> prints out the macro corresponding to a specific <code>isl_ast_expr_op_type</code>. If the print-macro-once option is set, then a given macro definition is only printed once to any given printer object. <code>isl_ast_op_type_print_macro</code> is an alternative name for <code>isl_ast_expr_op_type_print_macro</code>. <code>isl_ast_expr_print_macros</code> scans the <code>isl_ast_expr</code> for subexpressions where these macros would be used and prints out the required macro definitions. Essentially, <code>isl_ast_expr_print_macros</code> calls <code>isl_ast_expr_foreach_ast_expr_op_type</code> with <code>isl_ast_expr_op_type_print_macro</code> as function argument. <code>isl_ast_node_print_macros</code> does the same for expressions in its <code>isl_ast_node</code> argument. <code>isl_ast_node_print</code>, <code>isl_ast_node_for_print</code> and <code>isl_ast_node_if_print</code> print an <code>isl_ast_node</code> in <code>ISL_FORMAT_C</code>, but allow for some extra control through an <code>isl_ast_print_options</code> object. This object can be created using the following functions.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_print_options *
isl_ast_print_options_alloc(isl_ctx *ctx);
__isl_give isl_ast_print_options *
isl_ast_print_options_copy(
        __isl_keep isl_ast_print_options *options);
__isl_null isl_ast_print_options *
isl_ast_print_options_free(
        __isl_take isl_ast_print_options *options);

__isl_give isl_ast_print_options *
isl_ast_print_options_set_print_user(
        __isl_take isl_ast_print_options *options,
        __isl_give isl_printer *(*print_user)(
                __isl_take isl_printer *p,
                __isl_take isl_ast_print_options *options,
                __isl_keep isl_ast_node *node, void *user),
        void *user);
__isl_give isl_ast_print_options *
isl_ast_print_options_set_print_for(
        __isl_take isl_ast_print_options *options,
        __isl_give isl_printer *(*print_for)(
                __isl_take isl_printer *p,
                __isl_take isl_ast_print_options *options,
                __isl_keep isl_ast_node *node, void *user),
        void *user);</code></pre>

<p>The callback set by <code>isl_ast_print_options_set_print_user</code> is called whenever a node of type <code>isl_ast_node_user</code> needs to be printed. The callback set by <code>isl_ast_print_options_set_print_for</code> is called whenever a node of type <code>isl_ast_node_for</code> needs to be printed. Note that <code>isl_ast_node_for_print</code> will <i>not</i> call the callback set by <code>isl_ast_print_options_set_print_for</code> on the node on which <code>isl_ast_node_for_print</code> is called, but only on nested nodes of type <code>isl_ast_node_for</code>. It is therefore safe to call <code>isl_ast_node_for_print</code> from within the callback set by <code>isl_ast_print_options_set_print_for</code>.</p>

<p>The following option determines the type to be used for iterators while printing the AST.</p>

<pre><code>isl_stat isl_options_set_ast_iterator_type(
        isl_ctx *ctx, const char *val);
const char *isl_options_get_ast_iterator_type(
        isl_ctx *ctx);</code></pre>

<p>The AST printer only prints body nodes of <code>if</code> and <code>for</code> nodes as blocks if these blocks cannot be safely omitted. For example, a <code>for</code> node with one body node will not be surrounded with braces in <code>ISL_FORMAT_C</code>. A block will always be printed by setting the following option.</p>

<pre><code>isl_stat isl_options_set_ast_always_print_block(isl_ctx *ctx,
        int val);
int isl_options_get_ast_always_print_block(isl_ctx *ctx);</code></pre>

<p>Explicit block nodes that appear inside the AST are always printed as blocks. If the block node appears as the outermost node, then it is only printed if the following option is set.</p>

<pre><code>isl_stat isl_options_set_ast_print_outermost_block(
        isl_ctx *ctx, int val);
int isl_options_get_ast_print_outermost_block(
        isl_ctx *ctx);</code></pre>

<h3 id="Options1">Options</h3>

<pre><code>#include &lt;isl/ast_build.h&gt;
isl_stat isl_options_set_ast_build_atomic_upper_bound(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_atomic_upper_bound(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_prefer_pdiv(isl_ctx *ctx,
        int val);
int isl_options_get_ast_build_prefer_pdiv(isl_ctx *ctx);
isl_stat isl_options_set_ast_build_detect_min_max(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_detect_min_max(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_exploit_nested_bounds(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_exploit_nested_bounds(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_group_coscheduled(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_group_coscheduled(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_separation_bounds(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_separation_bounds(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_scale_strides(
        isl_ctx *ctx, int val);
int isl_options_get_ast_build_scale_strides(
        isl_ctx *ctx);
isl_stat isl_options_set_ast_build_allow_else(isl_ctx *ctx,
        int val);
int isl_options_get_ast_build_allow_else(isl_ctx *ctx);
isl_stat isl_options_set_ast_build_allow_or(isl_ctx *ctx,
        int val);
int isl_options_get_ast_build_allow_or(isl_ctx *ctx);</code></pre>

<ul>

<li><p>ast_build_atomic_upper_bound</p>

<p>Generate loop upper bounds that consist of the current loop iterator, an operator and an expression not involving the iterator. If this option is not set, then the current loop iterator may appear several times in the upper bound. For example, when this option is turned off, AST generation for the schedule</p>

<pre><code>[n] -&gt; { A[i] -&gt; [i] : 0 &lt;= i &lt;= 100, n }</code></pre>

<p>produces</p>

<pre><code>for (int c0 = 0; c0 &lt;= 100 &amp;&amp; n &gt;= c0; c0 += 1)
  A(c0);</code></pre>

<p>When the option is turned on, the following AST is generated</p>

<pre><code>for (int c0 = 0; c0 &lt;= min(100, n); c0 += 1)
  A(c0);</code></pre>

</li>
<li><p>ast_build_prefer_pdiv</p>

<p>If this option is turned off, then the AST generation will produce ASTs that may only contain <code>isl_ast_expr_op_fdiv_q</code> operators, but no <code>isl_ast_expr_op_pdiv_q</code> or <code>isl_ast_expr_op_pdiv_r</code> operators. If this option is turned on, then <code>isl</code> will try to convert some of the <code>isl_ast_expr_op_fdiv_q</code> operators to (expressions containing) <code>isl_ast_expr_op_pdiv_q</code> or <code>isl_ast_expr_op_pdiv_r</code> operators.</p>

</li>
<li><p>ast_build_detect_min_max</p>

<p>If this option is turned on, then <code>isl</code> will try and detect min or max-expressions when building AST expressions from piecewise affine expressions.</p>

</li>
<li><p>ast_build_exploit_nested_bounds</p>

<p>Simplify conditions based on bounds of nested for loops. In particular, remove conditions that are implied by the fact that one or more nested loops have at least one iteration, meaning that the upper bound is at least as large as the lower bound. For example, when this option is turned off, AST generation for the schedule</p>

<pre><code>[N,M] -&gt; { A[i,j] -&gt; [i,j] : 0 &lt;= i &lt;= N and
                                0 &lt;= j &lt;= M }</code></pre>

<p>produces</p>

<pre><code>if (M &gt;= 0)
  for (int c0 = 0; c0 &lt;= N; c0 += 1)
    for (int c1 = 0; c1 &lt;= M; c1 += 1)
      A(c0, c1);</code></pre>

<p>When the option is turned on, the following AST is generated</p>

<pre><code>for (int c0 = 0; c0 &lt;= N; c0 += 1)
  for (int c1 = 0; c1 &lt;= M; c1 += 1)
    A(c0, c1);</code></pre>

</li>
<li><p>ast_build_group_coscheduled</p>

<p>If two domain elements are assigned the same schedule point, then they may be executed in any order and they may even appear in different loops. If this options is set, then the AST generator will make sure that coscheduled domain elements do not appear in separate parts of the AST. This is useful in case of nested AST generation if the outer AST generation is given only part of a schedule and the inner AST generation should handle the domains that are coscheduled by this initial part of the schedule together. For example if an AST is generated for a schedule</p>

<pre><code>{ A[i] -&gt; [0]; B[i] -&gt; [0] }</code></pre>

<p>then the <code>isl_ast_build_set_create_leaf</code> callback described below may get called twice, once for each domain. Setting this option ensures that the callback is only called once on both domains together.</p>

</li>
<li><p>ast_build_separation_bounds</p>

<p>This option specifies which bounds to use during separation. If this option is set to <code>ISL_AST_BUILD_SEPARATION_BOUNDS_IMPLICIT</code> then all (possibly implicit) bounds on the current dimension will be used during separation. If this option is set to <code>ISL_AST_BUILD_SEPARATION_BOUNDS_EXPLICIT</code> then only those bounds that are explicitly available will be used during separation.</p>

</li>
<li><p>ast_build_scale_strides</p>

<p>This option specifies whether the AST generator is allowed to scale down iterators of strided loops.</p>

</li>
<li><p>ast_build_allow_else</p>

<p>This option specifies whether the AST generator is allowed to construct if statements with else branches.</p>

</li>
<li><p>ast_build_allow_or</p>

<p>This option specifies whether the AST generator is allowed to construct if conditions with disjunctions.</p>

</li>
</ul>

<h3 id="AST-Generation-Options-Schedule-Tree">AST Generation Options (Schedule Tree)</h3>

<p>In case of AST construction from a schedule tree, the options that control how an AST is created from the individual schedule dimensions are stored in the band nodes of the tree (see <a href="#Schedule-Trees">&quot;Schedule Trees&quot;</a>).</p>

<p>In particular, a schedule dimension can be handled in four different ways, atomic, separate, unroll or the default. This loop AST generation type can be set using <code>isl_schedule_node_band_member_set_ast_loop_type</code>. Alternatively, the first three can be selected by including a one-dimensional element with as value the position of the schedule dimension within the band and as name one of <code>atomic</code>, <code>separate</code> or <code>unroll</code> in the options set by <code>isl_schedule_node_band_set_ast_build_options</code>. Only one of these three may be specified for any given schedule dimension within a band node. If none of these is specified, then the default is used. The meaning of the options is as follows.</p>

<dl>

<dt id="atomic"><code>atomic</code></dt>
<dd>

<p>When this option is specified, the AST generator will make sure that a given domain space only appears in a single loop at the specified level.</p>

<p>For example, for the schedule tree</p>

<pre><code>domain: &quot;{ a[i] : 0 &lt;= i &lt; 10; b[i] : 0 &lt;= i &lt; 10 }&quot;
child:
  schedule: &quot;[{ a[i] -&gt; [i]; b[i] -&gt; [i+1] }]&quot;
  options: &quot;{ atomic[x] }&quot;</code></pre>

<p>the following AST will be generated</p>

<pre><code>for (int c0 = 0; c0 &lt;= 10; c0 += 1) {
  if (c0 &gt;= 1)
    b(c0 - 1);
  if (c0 &lt;= 9)
    a(c0);
}</code></pre>

<p>On the other hand, for the schedule tree</p>

<pre><code>domain: &quot;{ a[i] : 0 &lt;= i &lt; 10; b[i] : 0 &lt;= i &lt; 10 }&quot;
child:
  schedule: &quot;[{ a[i] -&gt; [i]; b[i] -&gt; [i+1] }]&quot;
  options: &quot;{ separate[x] }&quot;</code></pre>

<p>the following AST will be generated</p>

<pre><code>{
  a(0);
  for (int c0 = 1; c0 &lt;= 9; c0 += 1) {
    b(c0 - 1);
    a(c0);
  }
  b(9);
}</code></pre>

<p>If neither <code>atomic</code> nor <code>separate</code> is specified, then the AST generator may produce either of these two results or some intermediate form.</p>

</dd>
<dt id="separate"><code>separate</code></dt>
<dd>

<p>When this option is specified, the AST generator will split the domain of the specified schedule dimension into pieces with a fixed set of statements for which instances need to be executed by the iterations in the schedule domain part. This option tends to avoid the generation of guards inside the corresponding loops. See also the <code>atomic</code> option.</p>

</dd>
<dt id="unroll"><code>unroll</code></dt>
<dd>

<p>When this option is specified, the AST generator will <i>completely</i> unroll the corresponding schedule dimension. It is the responsibility of the user to ensure that such unrolling is possible. To obtain a partial unrolling, the user should apply an additional strip-mining to the schedule and fully unroll the inner schedule dimension.</p>

</dd>
</dl>

<p>The <code>isolate</code> option is a bit more involved. It allows the user to isolate a range of schedule dimension values from smaller and greater values. Additionally, the user may specify a different atomic/separate/unroll choice for the isolated part and the remaining parts. The typical use case of the <code>isolate</code> option is to isolate full tiles from partial tiles. The part that needs to be isolated may depend on outer schedule dimensions. The option therefore needs to be able to reference those outer schedule dimensions. In particular, the space of the <code>isolate</code> option is that of a wrapped map with as domain the flat product of all outer band nodes and as range the space of the current band node. The atomic/separate/unroll choice for the isolated part is determined by an option that lives in an unnamed wrapped space with as domain a zero-dimensional <code>isolate</code> space and as range the regular <code>atomic</code>, <code>separate</code> or <code>unroll</code> space. This option may also be set directly using <code>isl_schedule_node_band_member_set_isolate_ast_loop_type</code>. The atomic/separate/unroll choice for the remaining part is determined by the regular <code>atomic</code>, <code>separate</code> or <code>unroll</code> option. Since the <code>isolate</code> option references outer schedule dimensions, its use in a band node causes any tree containing the node to be considered anchored.</p>

<p>As an example, consider the isolation of full tiles from partial tiles in a tiling of a triangular domain. The original schedule is as follows.</p>

<pre><code>domain: &quot;{ A[i,j] : 0 &lt;= i,j and i + j &lt;= 100 }&quot;
child:
  schedule: &quot;[{ A[i,j] -&gt; [floor(i/10)] }, \
        { A[i,j] -&gt; [floor(j/10)] }, \
        { A[i,j] -&gt; [i] }, { A[i,j] -&gt; [j] }]&quot;</code></pre>

<p>The output is</p>

<pre><code>for (int c0 = 0; c0 &lt;= 10; c0 += 1)
  for (int c1 = 0; c1 &lt;= -c0 + 10; c1 += 1)
    for (int c2 = 10 * c0;
         c2 &lt;= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
      for (int c3 = 10 * c1;
           c3 &lt;= min(10 * c1 + 9, -c2 + 100); c3 += 1)
        A(c2, c3);</code></pre>

<p>Isolating the full tiles, we have the following input</p>

<pre><code>domain: &quot;{ A[i,j] : 0 &lt;= i,j and i + j &lt;= 100 }&quot;
child:
  schedule: &quot;[{ A[i,j] -&gt; [floor(i/10)] }, \
        { A[i,j] -&gt; [floor(j/10)] }, \
        { A[i,j] -&gt; [i] }, { A[i,j] -&gt; [j] }]&quot;
  options: &quot;{ isolate[[] -&gt; [a,b,c,d]] : 0 &lt;= 10a,10b and \
        10a+9+10b+9 &lt;= 100 }&quot;</code></pre>

<p>and output</p>

<pre><code>{
  for (int c0 = 0; c0 &lt;= 8; c0 += 1) {
    for (int c1 = 0; c1 &lt;= -c0 + 8; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= 10 * c0 + 9; c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= 10 * c1 + 9; c3 += 1)
          A(c2, c3);
    for (int c1 = -c0 + 9; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(10 * c1 + 9, -c2 + 100); c3 += 1)
          A(c2, c3);
  }
  for (int c0 = 9; c0 &lt;= 10; c0 += 1)
    for (int c1 = 0; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(10 * c1 + 9, -c2 + 100); c3 += 1)
          A(c2, c3);
}</code></pre>

<p>We may then additionally unroll the innermost loop of the isolated part</p>

<pre><code>domain: &quot;{ A[i,j] : 0 &lt;= i,j and i + j &lt;= 100 }&quot;
child:
  schedule: &quot;[{ A[i,j] -&gt; [floor(i/10)] }, \
        { A[i,j] -&gt; [floor(j/10)] }, \
        { A[i,j] -&gt; [i] }, { A[i,j] -&gt; [j] }]&quot;
  options: &quot;{ isolate[[] -&gt; [a,b,c,d]] : 0 &lt;= 10a,10b and \
        10a+9+10b+9 &lt;= 100; [isolate[] -&gt; unroll[3]] }&quot;</code></pre>

<p>to obtain</p>

<pre><code>{
  for (int c0 = 0; c0 &lt;= 8; c0 += 1) {
    for (int c1 = 0; c1 &lt;= -c0 + 8; c1 += 1)
      for (int c2 = 10 * c0; c2 &lt;= 10 * c0 + 9; c2 += 1) {
        A(c2, 10 * c1);
        A(c2, 10 * c1 + 1);
        A(c2, 10 * c1 + 2);
        A(c2, 10 * c1 + 3);
        A(c2, 10 * c1 + 4);
        A(c2, 10 * c1 + 5);
        A(c2, 10 * c1 + 6);
        A(c2, 10 * c1 + 7);
        A(c2, 10 * c1 + 8);
        A(c2, 10 * c1 + 9);
      }
    for (int c1 = -c0 + 9; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(10 * c1 + 9, -c2 + 100); c3 += 1)
          A(c2, c3);
  }
  for (int c0 = 9; c0 &lt;= 10; c0 += 1)
    for (int c1 = 0; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(10 * c0 + 9, -10 * c1 + 100); c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(10 * c1 + 9, -c2 + 100); c3 += 1)
          A(c2, c3);
}</code></pre>

<h3 id="AST-Generation-Options-Schedule-Map">AST Generation Options (Schedule Map)</h3>

<p>In case of AST construction using <code>isl_ast_build_node_from_schedule_map</code>, the options that control how an AST is created from the individual schedule dimensions are stored in the <code>isl_ast_build</code>. They can be set using the following function.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_build *
isl_ast_build_set_options(
        __isl_take isl_ast_build *build,
        __isl_take isl_union_map *options);</code></pre>

<p>The options are encoded in an <code>isl_union_map</code>. The domain of this union relation refers to the schedule domain, i.e., the range of the schedule passed to <code>isl_ast_build_node_from_schedule_map</code>. In the case of nested AST generation (see <a href="#Nested-AST-Generation">&quot;Nested AST Generation&quot;</a>), the domain of <code>options</code> should refer to the extra piece of the schedule. That is, it should be equal to the range of the wrapped relation in the range of the schedule. The range of the options can consist of elements in one or more spaces, the names of which determine the effect of the option. The values of the range typically also refer to the schedule dimension to which the option applies, with value <code>0</code> representing the outermost schedule dimension. In case of nested AST generation (see <a href="#Nested-AST-Generation">&quot;Nested AST Generation&quot;</a>), these values refer to the position of the schedule dimension within the innermost AST generation. The constraints on the domain elements of the option should only refer to this dimension and earlier dimensions. We consider the following spaces.</p>

<dl>

<dt id="separation_class"><code>separation_class</code></dt>
<dd>

<p><b>This option has been deprecated. Use the isolate option on schedule trees instead.</b></p>

<p>This space is a wrapped relation between two one dimensional spaces. The input space represents the schedule dimension to which the option applies and the output space represents the separation class. While constructing a loop corresponding to the specified schedule dimension(s), the AST generator will try to generate separate loops for domain elements that are assigned different classes. If only some of the elements are assigned a class, then those elements that are not assigned any class will be treated as belonging to a class that is separate from the explicitly assigned classes. The typical use case for this option is to separate full tiles from partial tiles. The other options, described below, are applied after the separation into classes.</p>

<p>As an example, consider the separation into full and partial tiles of a tiling of a triangular domain. Take, for example, the domain</p>

<pre><code>{ A[i,j] : 0 &lt;= i,j and i + j &lt;= 100 }</code></pre>

<p>and a tiling into tiles of 10 by 10. The input to the AST generator is then the schedule</p>

<pre><code>{ A[i,j] -&gt; [([i/10]),[j/10],i,j] : 0 &lt;= i,j and
                                        i + j &lt;= 100 }</code></pre>

<p>Without any options, the following AST is generated</p>

<pre><code>for (int c0 = 0; c0 &lt;= 10; c0 += 1)
  for (int c1 = 0; c1 &lt;= -c0 + 10; c1 += 1)
    for (int c2 = 10 * c0;
         c2 &lt;= min(-10 * c1 + 100, 10 * c0 + 9);
         c2 += 1)
      for (int c3 = 10 * c1;
           c3 &lt;= min(10 * c1 + 9, -c2 + 100);
           c3 += 1)
        A(c2, c3);</code></pre>

<p>Separation into full and partial tiles can be obtained by assigning a class, say <code>0</code>, to the full tiles. The full tiles are represented by those values of the first and second schedule dimensions for which there are values of the third and fourth dimensions to cover an entire tile. That is, we need to specify the following option</p>

<pre><code>{ [a,b,c,d] -&gt; separation_class[[0]-&gt;[0]] :
        exists b&#39;: 0 &lt;= 10a,10b&#39; and
                   10a+9+10b&#39;+9 &lt;= 100;
  [a,b,c,d] -&gt; separation_class[[1]-&gt;[0]] :
        0 &lt;= 10a,10b and 10a+9+10b+9 &lt;= 100 }</code></pre>

<p>which simplifies to</p>

<pre><code>{ [a, b, c, d] -&gt; separation_class[[1] -&gt; [0]] :
        a &gt;= 0 and b &gt;= 0 and b &lt;= 8 - a;
  [a, b, c, d] -&gt; separation_class[[0] -&gt; [0]] :
        a &gt;= 0 and a &lt;= 8 }</code></pre>

<p>With this option, the generated AST is as follows</p>

<pre><code>{
  for (int c0 = 0; c0 &lt;= 8; c0 += 1) {
    for (int c1 = 0; c1 &lt;= -c0 + 8; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= 10 * c0 + 9; c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= 10 * c1 + 9; c3 += 1)
          A(c2, c3);
    for (int c1 = -c0 + 9; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(-10 * c1 + 100, 10 * c0 + 9);
           c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(-c2 + 100, 10 * c1 + 9);
             c3 += 1)
          A(c2, c3);
  }
  for (int c0 = 9; c0 &lt;= 10; c0 += 1)
    for (int c1 = 0; c1 &lt;= -c0 + 10; c1 += 1)
      for (int c2 = 10 * c0;
           c2 &lt;= min(-10 * c1 + 100, 10 * c0 + 9);
           c2 += 1)
        for (int c3 = 10 * c1;
             c3 &lt;= min(10 * c1 + 9, -c2 + 100);
             c3 += 1)
          A(c2, c3);
}</code></pre>

</dd>
<dt id="separate1"><code>separate</code></dt>
<dd>

<p>This is a single-dimensional space representing the schedule dimension(s) to which ``separation&#39;&#39; should be applied. Separation tries to split a loop into several pieces if this can avoid the generation of guards inside the loop. See also the <code>atomic</code> option.</p>

</dd>
<dt id="atomic1"><code>atomic</code></dt>
<dd>

<p>This is a single-dimensional space representing the schedule dimension(s) for which the domains should be considered ``atomic&#39;&#39;. That is, the AST generator will make sure that any given domain space will only appear in a single loop at the specified level.</p>

<p>Consider the following schedule</p>

<pre><code>{ a[i] -&gt; [i] : 0 &lt;= i &lt; 10;
  b[i] -&gt; [i+1] : 0 &lt;= i &lt; 10 }</code></pre>

<p>If the following option is specified</p>

<pre><code>{ [i] -&gt; separate[x] }</code></pre>

<p>then the following AST will be generated</p>

<pre><code>{
  a(0);
  for (int c0 = 1; c0 &lt;= 9; c0 += 1) {
    a(c0);
    b(c0 - 1);
  }
  b(9);
}</code></pre>

<p>If, on the other hand, the following option is specified</p>

<pre><code>{ [i] -&gt; atomic[x] }</code></pre>

<p>then the following AST will be generated</p>

<pre><code>for (int c0 = 0; c0 &lt;= 10; c0 += 1) {
  if (c0 &lt;= 9)
    a(c0);
  if (c0 &gt;= 1)
    b(c0 - 1);
}</code></pre>

<p>If neither <code>atomic</code> nor <code>separate</code> is specified, then the AST generator may produce either of these two results or some intermediate form.</p>

</dd>
<dt id="unroll1"><code>unroll</code></dt>
<dd>

<p>This is a single-dimensional space representing the schedule dimension(s) that should be <i>completely</i> unrolled. To obtain a partial unrolling, the user should apply an additional strip-mining to the schedule and fully unroll the inner loop.</p>

</dd>
</dl>

<h3 id="Fine-grained-Control-over-AST-Generation">Fine-grained Control over AST Generation</h3>

<p>Besides specifying the constraints on the parameters, an <code>isl_ast_build</code> object can be used to control various aspects of the AST generation process. In case of AST construction using <code>isl_ast_build_node_from_schedule_map</code>, the most prominent way of control is through ``options&#39;&#39;, as explained above.</p>

<p>Additional control is available through the following functions.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_build *
isl_ast_build_set_iterators(
        __isl_take isl_ast_build *build,
        __isl_take isl_id_list *iterators);</code></pre>

<p>The function <code>isl_ast_build_set_iterators</code> allows the user to specify a list of iterator <code>isl_id</code>s to be used as iterators. If the input schedule is injective, then the number of elements in this list should be as large as the dimension of the schedule space, but no direct correspondence should be assumed between dimensions and elements. If the input schedule is not injective, then an additional number of <code>isl_id</code>s equal to the largest dimension of the input domains may be required. If the number of provided <code>isl_id</code>s is insufficient, then additional names are automatically generated.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_build *
isl_ast_build_set_create_leaf(
        __isl_take isl_ast_build *build,
        __isl_give isl_ast_node *(*fn)(
                __isl_take isl_ast_build *build,
                void *user), void *user);</code></pre>

<p>The <code>isl_ast_build_set_create_leaf</code> function allows for the specification of a callback that should be called whenever the AST generator arrives at an element of the schedule domain. The callback should return an AST node that should be inserted at the corresponding position of the AST. The default action (when the callback is not set) is to continue generating parts of the AST to scan all the domain elements associated to the schedule domain element and to insert user nodes, ``calling&#39;&#39; the domain element, for each of them. The <code>build</code> argument contains the current state of the <code>isl_ast_build</code>. To ease nested AST generation (see <a href="#Nested-AST-Generation">&quot;Nested AST Generation&quot;</a>), all control information that is specific to the current AST generation such as the options and the callbacks has been removed from this <code>isl_ast_build</code>. The callback would typically return the result of a nested AST generation or a user defined node created using the following function.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_node *isl_ast_node_user_from_expr(
        __isl_take isl_ast_expr *expr);
__isl_give isl_ast_node *isl_ast_node_alloc_user(
        __isl_take isl_ast_expr *expr);</code></pre>

<p><code>isl_ast_node_alloc_user</code> is an alternative name for <code>isl_ast_node_user_from_expr</code>.</p>

<p>In some cases, a single user defined node is not enough, in which case the following function can be used to create a block node from multiple AST nodes.</p>

<pre><code>#include &lt;isl/ast.h&gt;
__isl_give isl_ast_node *isl_ast_node_block_from_children(
        __isl_take isl_ast_node_list *list);

#include &lt;isl/ast_build.h&gt;
__isl_give isl_ast_build *
isl_ast_build_set_at_each_domain(
        __isl_take isl_ast_build *build,
        __isl_give isl_ast_node *(*fn)(
                __isl_take isl_ast_node *node,
                __isl_keep isl_ast_build *build,
                void *user), void *user);
__isl_give isl_ast_build *
isl_ast_build_set_before_each_for(
        __isl_take isl_ast_build *build,
        __isl_give isl_id *(*fn)(
                __isl_keep isl_ast_build *build,
                void *user), void *user);
__isl_give isl_ast_build *
isl_ast_build_set_after_each_for(
        __isl_take isl_ast_build *build,
        __isl_give isl_ast_node *(*fn)(
                __isl_take isl_ast_node *node,
                __isl_keep isl_ast_build *build,
                void *user), void *user);
__isl_give isl_ast_build *
isl_ast_build_set_before_each_mark(
        __isl_take isl_ast_build *build,
        isl_stat (*fn)(__isl_keep isl_id *mark,
                __isl_keep isl_ast_build *build,
                void *user), void *user);
__isl_give isl_ast_build *
isl_ast_build_set_after_each_mark(
        __isl_take isl_ast_build *build,
        __isl_give isl_ast_node *(*fn)(
                __isl_take isl_ast_node *node,
                __isl_keep isl_ast_build *build,
                void *user), void *user);</code></pre>

<p>The callback set by <code>isl_ast_build_set_at_each_domain</code> will be called for each domain AST node. The callbacks set by <code>isl_ast_build_set_before_each_for</code> and <code>isl_ast_build_set_after_each_for</code> will be called for each for AST node. The first will be called in depth-first pre-order, while the second will be called in depth-first post-order. Since <code>isl_ast_build_set_before_each_for</code> is called before the for node is actually constructed, it is only passed an <code>isl_ast_build</code>. The returned <code>isl_id</code> will be added as an annotation (using <code>isl_ast_node_set_annotation</code>) to the constructed for node. In particular, if the user has also specified an <code>after_each_for</code> callback, then the annotation can be retrieved from the node passed to that callback using <code>isl_ast_node_get_annotation</code>. The callbacks set by <code>isl_ast_build_set_before_each_mark</code> and <code>isl_ast_build_set_after_each_mark</code> will be called for each mark AST node that is created, i.e., for each mark schedule node in the input schedule tree. The first will be called in depth-first pre-order, while the second will be called in depth-first post-order. Since the callback set by <code>isl_ast_build_set_before_each_mark</code> is called before the mark AST node is actually constructed, it is passed the identifier of the mark node. All callbacks should <code>NULL</code> (or <code>isl_stat_error</code>) on failure. The given <code>isl_ast_build</code> can be used to create new <code>isl_ast_expr</code> objects using <code>isl_ast_build_expr_from_pw_aff</code> or <code>isl_ast_build_call_from_pw_multi_aff</code>.</p>

<h3 id="Nested-AST-Generation">Nested AST Generation</h3>

<p><code>isl</code> allows the user to create an AST within the context of another AST. These nested ASTs are created using the same <code>isl_ast_build_node_from_schedule_map</code> function that is used to create the outer AST. The <code>build</code> argument should be an <code>isl_ast_build</code> passed to a callback set by <code>isl_ast_build_set_create_leaf</code>. The space of the range of the <code>schedule</code> argument should refer to this build. In particular, the space should be a wrapped relation and the domain of this wrapped relation should be the same as that of the range of the schedule returned by <code>isl_ast_build_get_schedule</code> below. In practice, the new schedule is typically created by calling <code>isl_union_map_range_product</code> on the old schedule and some extra piece of the schedule. The space of the schedule domain is also available from the <code>isl_ast_build</code>.</p>

<pre><code>#include &lt;isl/ast_build.h&gt;
__isl_give isl_union_map *isl_ast_build_get_schedule(
        __isl_keep isl_ast_build *build);
__isl_give isl_space *isl_ast_build_get_schedule_space(
        __isl_keep isl_ast_build *build);
__isl_give isl_ast_build *isl_ast_build_restrict(
        __isl_take isl_ast_build *build,
        __isl_take isl_set *set);</code></pre>

<p>The <code>isl_ast_build_get_schedule</code> function returns a (partial) schedule for the domains elements for which part of the AST still needs to be generated in the current build. In particular, the domain elements are mapped to those iterations of the loops enclosing the current point of the AST generation inside which the domain elements are executed. No direct correspondence between the input schedule and this schedule should be assumed. The space obtained from <code>isl_ast_build_get_schedule_space</code> can be used to create a set for <code>isl_ast_build_restrict</code> to intersect with the current build. In particular, the set passed to <code>isl_ast_build_restrict</code> can have additional parameters. The ids of the set dimensions in the space returned by <code>isl_ast_build_get_schedule_space</code> correspond to the iterators of the already generated loops. The user should not rely on the ids of the output dimensions of the relations in the union relation returned by <code>isl_ast_build_get_schedule</code> having any particular value.</p>

<h1 id="Applications">Applications</h1>

<p>Although <code>isl</code> is mainly meant to be used as a library, it also contains some basic applications that use some of the functionality of <code>isl</code>. For applications that take one or more polytopes or polyhedra as input, this input may be specified in either the <a href="#isl-format">&quot;isl format&quot;</a> or the <a href="#PolyLib-format">&quot;PolyLib format&quot;</a>.</p>

<h2 id="isl_polyhedron_sample"><code>isl_polyhedron_sample</code></h2>

<p><code>isl_polyhedron_sample</code> takes a polyhedron as input and prints an integer element of the polyhedron, if there is any. The first column in the output is the denominator and is always equal to 1. If the polyhedron contains no integer points, then a vector of length zero is printed.</p>

<h2 id="isl_pip"><code>isl_pip</code></h2>

<p><code>isl_pip</code> takes the same input as the <code>example</code> program from the <code>piplib</code> distribution, i.e., a set of constraints on the parameters, a line containing only -1 and finally a set of constraints on a parametric polyhedron. The coefficients of the parameters appear in the last columns (but before the final constant column). The output is the lexicographic minimum of the parametric polyhedron. As <code>isl</code> currently does not have its own output format, the output is just a dump of the internal state.</p>

<h2 id="isl_polyhedron_minimize"><code>isl_polyhedron_minimize</code></h2>

<p><code>isl_polyhedron_minimize</code> computes the minimum of some linear or affine objective function over the integer points in a polyhedron. If an affine objective function is given, then the constant should appear in the last column.</p>

<h2 id="isl_polytope_scan"><code>isl_polytope_scan</code></h2>

<p>Given a polytope, <code>isl_polytope_scan</code> prints all integer points in the polytope.</p>

<h2 id="isl_flow"><code>isl_flow</code></h2>

<p>Given an <code>isl_union_access_info</code> object as input, <code>isl_flow</code> prints out the corresponding dependences, as computed by <code>isl_union_access_info_compute_flow</code>.</p>

<h2 id="isl_codegen"><code>isl_codegen</code></h2>

<p>Given either a schedule tree or a sequence consisting of a schedule map, a context set and an options relation, <code>isl_codegen</code> prints out an AST that scans the domain elements of the schedule in the order of their image(s) taking into account the constraints in the context set.</p>

<h2 id="isl_schedule"><code>isl_schedule</code></h2>

<p>Given an <code>isl_schedule_constraints</code> object as input, <code>isl_schedule</code> prints out a schedule that satisfies the given constraints.</p>


</body>

</html>


